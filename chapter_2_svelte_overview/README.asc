//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr 25 08:30:26 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_2_svelte_overview]]
= Chapter-2 Svelte overview

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_why_svelte[Why Svelte]
| 2.    | xref:_svelte_basics[Svelte Basic]
| 3.    | xref:_data_reactivity[Data Reactivity]
| 4.    | xref:_props[Props]
|====
//}}}

// {{{ 1 == Why Svelte
[[_why_svelte]]
== Why Svelte
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead
:fn-write_less_code: https://svelte.dev/blog/write-less-code
:fn-svelte_is_compiler: https://svelte.dev/blog/frameworks-without-the-framework

So the obviousness question that a lot of people have is,  *what is Svelte*?

Exactly a lot of different ways to answer that question.

It's a lot of different things,  but it's probably easiest to understand it is
as an *alternative* to other existing projects that you're familiar with,  "React"
and "Vue" of the two most popular "*Component* - frameworks",  and Svelte
essentially solved a similar problem that
they do.

So,  what is a "Component - framework? Component Frameworks exist to help you
write applications more *declaratively*.

We use that word declare Actively a lot in programming. So it's helpful to
understand exactly what we mean by that.

This declarative code that I'm looking at here.

//{{{ svelte - example
[source,  html]
----
// svelte - example
<script>
    let count = 0;
</script>

<button on:click={() => count += 1}>
    Clicks: {count}
</button>
----
//}}}

This is some Svelte code is roughly equivalent to the vanilla JavaScript
beneath it.

//{{{ vanillaJS - example
[source, javascript]
----
// vanillaJS - example
function component() {
    let count = 0;

    const button = document.createElement('button');
    button.textContent = `Clicks: ${count}`;

    button.addEventListener('click',  () => {
            count += 1;
            button.textContent = `Clicks: ${count}`;
            });

    return button;
}
----
//}}}

You can see what's happening with creating a button using
`document.createElement()` and then we're putting some text inside it.

Then adding an "Event Listener" to,  when you click the button,  it increments
the value of `"count"` and then it updates the `"textContent"` inside the
button.

Then we return that. That's our component.

So the difference is in the *"imperative"* - version with telling the browser
exactly what to do.

In the *"declarative"* - version. We're just saying what outcome we want; And
that's obviously a lot simpler for the developer,  because we're not having to
work through the process of explaining to the browser exactly what it needs to
do each given moment.

More to the point. There's no duplication. Here We've got this initial
`"button.textcontent"` equals "blah"; and then inside the "update Handler",
we've got the same thing.

You tend to find that when you're building web applications,  you have a lot of
that kind of *duplication*. You have the "initial render" and then you have the
"update".

But if you're doing things declaratively,  that's no longer the case.

But it gets worse for the *"imperative"* story. If you want to make a very
small change to your component. For example,  you want to wrap that `"count"` -
variable in a *strong element*. Then if you're doing it,  imperatively,  you need
to almost rewrite the entire component. That's for a very small change.

So you can imagine,  if you're building a large application,  the amount of work
that you would have to do is,  you're *iterating on your design* is much - much
greater with *"imperative'* - code.


So that's the value that component framework provide. They make it a lot easier
for us as developers to build applications.

Historically,  though there has been a little bit of an implicit "trade-off".
Because the framework acts as a *middleman* between you and the browser. With
the middleman introduces inefficiency.

=== How is Svelte Different?

So,  Svelte began back in 2016. Is an experiment to prove that is,  in fact,  a
*"FALSE - DICHOTOMY"*. There is no tension between *"developer - experience"*,
and *"user - experience"*.

Svelte is a *COMPILER*. It takes your *"declarative"* - code and it turns it
into the equivalent *"imperative"* - JavaScript.

Then this has a number of really useful advantages.

- First. Your apps will *generally be quite a lot smaller*.

Because we don't need to have the *actual framework runtime* in the browser.
Normally, the framework has to anticipate every possible use case,  but because
Svelte understands exactly what is going into your app. It can discard most of
it in just ship the code that is actually needed for your specific use case.

JavaScript is the most expensive thing on the web bite for bite. Because you
don't just have to download it. You also have to pause and evaluate it,  and so
if we can use less of it than your apps are going to launch quicker and your
users will be happier.

- Second. You apps will be *Faster*.

Once your applications have already launched,  your apps are going to be faster.
Because we don't need to use costly techniques like *"re-rendering"* the
{fn-virtual_dom}["virtual Dom"] and then dipping it to find out what needs to
change on the page.

Instead,  we can make surgical granular updates. The compiler knows which bits
of the application could change for a given "State" - change,  and it can just
change the "Dom" directly the same way that you would do,  if you using the "Dom
- API" manually.

- Finally,  Your app will be *easier to write*.

Because we have a lot more control over the *"authoring"* - experience. We
don't have the same constraints that are the people do. What this means in
particular,  is that if you're using Svelte,  you will be able to write less
code.


There's a blog post link there that I invite you to check out which explains
why {fn-write_less_code}[writing less code] is so important.  Writing less
code,  means that you'll have fewer *"bugs"* and to be able to spend more time
Outdoors.

Beyond that Svelte aims to make your life easier by shipping a lot of the
things that normally you would have to do as third party liability would
install from "NPM".

So things like *"State - management"*,  *"Element - transitions"*,  *"handling
input"* via "Form" - elements,  scope - CSS. All of those things. Normally with
a framework,  those are things that you have to figure out a solution to
yourself.

But was Svelte,  it's already *built in*,  and we can do that because again,
{fn-svelte_is_compiler}[*we're a "compiler"*],  we can discard the bits that
we're not using.

=== Who Make Svelte?

Well,  it is very much a *community project*.

It's not a project with full-time engineers and corporate funding. It's a
project that is developed in the open by a group of volunteers who work on it,
in their free time. Because we believe in the project.

There is a core team of developers who do the day-to-day stuff,  but the broader
contributor Community is large,  and every decision that we make about,  the
future of the framework is done to the greatest extent possible out in the
open.

Egalitarians,  Communitarian project. We welcome developers of all backgrounds
and with all skill levels,  and we would love for you to be involved as well.

So with that,  I'm going to move on to the next part of the workshop where we're
going to run through the entire Svelte tutorial to learn how to build stock
components.

**⬆xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Svelte Basics
[[_svelte_basics]]
== Svelte Basics
:fn-svelte_dev_tutorial: https://Svelte.dev/tutorial/basic
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead


Okay. So in this section, we're going to go through the entire "Interactors" Svelte
tutorial. By the end of it, you'll have a complete grasp of what's Svelte
can do and how you're right Svelte Component.

So what I invite you to do is in a new tab in you browser, go to
{fn-svelte_dev_tutorial}[Svelte-tutorial,window=_blank] and we're just going to
go through the whole thing top to bottom, Soup To Nuts.

Now, this has some introductory Spiel that I've already basically explained. So
I'm going to just go down there and click on the next button. And we'll begin
with our "Hello world!" - Component.

=== Adding Data

//{{{ image::./images/chapter-2-1.png
[#img-chapter]
[link=./images/chapter-2-1.png,window=_blank]
.Svelte Basic -1
image::./images/chapter-2-1.png[align="center"]
//}}}

So the first thing that you'll notice is that we're writing
HTML into this window here, this `"app.svelte"` - window.

The reason that we use *"HTML"* is our base
language instead of JavaScript is, HTML is *designed to contain* CSS and
JavaScript. So all of the three languages of the web, they all fit together in
Svelte - Component in a very idiomatic way.

//{{{ <h1>Hello World!<h1>
[source, html]
----
<script>
    let name = 'world';
</script>

<h1>Hello {name}!</h1>
----
//}}}

The first thing that we need to do is
*add some data*, so going to create a script tag, Up here; and then we're going to
create a variable, call it `"name"`,  and we'll just give it a value `"world"` like that.

Then inside the *markup*, we can refer to that value by putting it inside
curly braces `"{}"`. Like so.

Now, inside these curly braces (`"{name}"`), we can have any valid
JavaScript. So we can change that to `"{name.toUpperCase}"`, for example.

//{{{ image::./images/chapter-2-1.gif
[#img-chapter]
[link=./images/gif/chapter-2-1.gif,window=_blank]
.Svelte Basic -2
image::./images/gif/chapter-2-1.gif[align="center"]
//}}}

Then obviously as we change that It will re-render the application.

//{{{ image::./images/chapter-2-2.png
[#img-chapter]
[link=./images/chapter-2-2.png,window=_blank]
.Svelte Basic -2
image::./images/chapter-2-2.png[align="center"]
//}}}

NOTE: By the way, if you ever get stuck, while going through these tutorials
and you want to just skip to the end to the end result, then you can click on
the `"Show Me"` - button down here, and it will take you straight to the end
State and then you can click reset back to the beginning.

=== Dynamic Attribute

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img src={src}>
//   ~~~~~~~~
----
//}}}

Now,   in the same way that we can use curly braces
to put text inside our application, we can use it inside Element - attributes.

So our `"<image>"` - tag here is missing a source attribute (`"<src="">"`). Add
one like that and give it the value of `"src={src}"`,  which is in the script
block.

//{{{ image::./images/chapter-2-3.png
[#img-chapter]
[link=./images/chapter-2-3.png,window=_blank]
.Svelte Basic -3
image::./images/chapter-2-3.png[align="center"]
//}}}

This orange bar beneath
beneath. The mark-up is telling us that an image element should have an `alt=""`
- attribute and this is really important, this is an *accessibility* matter.

Most
people, when they're using a website, they can see the content of the image and
they don't need an `alt=""` attribute.

But there are a lot of users for whom that's not true. That includes people
with impaired Vision who are using assistive Technologies like screen readers.

But it also includes people who are on a slow connection and they've got the
marker but it hasn't yet been able to load the content of the image. So it's
very important that we *always add* an `alt=""` - attribute to *describe* what
is in the image.

So, in this case, `alt="A man dances"`.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img alt="A man dances" src={src}>
----
//}}}

Now accessibility is a *big* and *difficult* topic and there's no way that a
framework likes Svelte can automatically check that you are writing accessible
markup in every case.

For example, this `alt=""` - tag could be absolute gibberish, and it
wouldn't know any better.

So you do have to understand the purpose of the
"accessibility" - *warnings* and make sure that you are actually building accessible
markup, and that includes things like making sure that the "contrast ratio" on the
content that you're building a high enough.

But Svelte will do the best that it can to make sure that you're not making any
*obvious mistakes*, like *putting markup* that's *inaccessible* on the page.

Now, we can also use the curly braces inside, attributes.  So,  let's say we
wanted to add Value name. Then we can put that inside the attribute there.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" src={src}>
----
//}}}

Then if I open my "dev - tools" and inspect this
image, You'll see that the alt attribute has been applied as we expect.

//{{{ image::./images/chapter-2-4.png
[#img-chapter]
[link=./images/chapter-2-4.png,window=_blank]
.Svelte Basic -4
image::./images/chapter-2-4.png[align="center"]
//}}}

Now we very often run into this situation here where we have an attribute
- `"name"` and `"value"` (`name='value'`) that match. So we have a convenient
shorthand installed.  We can just get rid of the attribute - `"name"` and the
equals (`" = "`) in this case (`src=""`) and pass it through like this,

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" {src}>
//                       ~~~~~
----
//}}}

*That's something that will do quite a lot in this Workshop*.

=== Styling

Now, I mentioned
before that a small component because it's HTML, it can contain JavaScript and
CSS. So we're going to add some CSS to a component.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<style>
    p {
        color: purple;
        font-family: "Comic Sans MS", cursive;
        font-size: 2em;
    }
</style>

<p>This is paragraph</p>
----
//}}}

We'll open a `"p"` selector and then make it `color: purple`. Give it a nice
"font" (`"font-family:"`), and we'll bump at the size (`"font-size:"`) a little
bit.

Right.And you'll see that it's applied.

//{{{ image::./images/chapter-2-5.png
[#img-chapter]
[link=./images/chapter-2-5.png,window=_blank]
.Svelte Basic -5
image::./images/chapter-2-5.png[align="center"]
//}}}

Those files to the paragraph As we would expect.

=== Nested Component

But wait there's more,  it's Svelte that you have "Nested - Components",
that is to say *a command* can contain *other* components.

In that situation, we don't want the Styles from One Component to *affect*
other Components on the page. Because then it becomes very difficult to
understand where a given style is coming from.

So Svelte actually *Scopes* the Styles inside a component, to just the
markup that belongs in the same Component.

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    p {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

We can show this by During the "script tag" that Imports are "Nested
Component". Just select that whole block and paste it at the top of
`"app.svelte"` that Imports The `:Nest.component"`, which is visible in this
tab here. Then we'll (`"<Nested />"`) put that underneath our paragraph.

//{{{ image::./images/chapter-2-6.png
[#img-chapter]
[link=./images/chapter-2-6.png,window=_blank]
.Svelte Basic -6
image::./images/chapter-2-6.png[align="center"]
//}}}

So the first paragraph `*[1]*` has the Styles defined here but they don't
affect the second paragraph `*[2]*`. Even though it's the same element.

//{{{ image::./images/chapter-2-7.png
[#img-chapter]
[link=./images/chapter-2-7.png,window=_blank]
.Svelte Basic -7
image::./images/chapter-2-7.png[align="center"]
//}}}

The way that this works under the hood is, that *"Svelte - Scopes"* the "CSS -
selector" with a "generated *hash*" (`".svelte-xxx"`).

That is computed from the contents of your style blog. It puts that CSS - class
on the selector in the CSS output, and it also puts it on the element.

With that way, there's no possibility of these selectors *clashing* between
different Components.

Obviously it goes the other way as well.

If I had a style in `"Nested.svelte"`,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    text-transform: uppercase;
    color: blue;
</style>
<p>This is a paragraph.</p>
----
//}}}

//{{{ image::./images/chapter-2-8.png
[#img-chapter]
[link=./images/chapter-2-8.png,window=_blank]
.Svelte Basic -8
image::./images/chapter-2-8.png[align="center"]
//}}}

They will affect the "child - Component" but not the "parent - Component".

We can also do something else. That's quite interesting.

Normally, when you're writing CSS, you have this phenomenon of the *append*
only style-sheet where you add some Styles, and then you add some more Styles
and then you add some more smiles and then you're NOT sure if you still need
these files. But you're *scared* to remove it because you don't know what is
affected by it. Because CSS is inherently Global.

But because we don't have that problem. Because our styles are
Scoped to the Component. We can remove the styles that *aren't used* inside the
Component, by *analyzing* the CSS and the markup together and seeing which select
Being applied.

So if we have this `".unused"` - class here,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    P {
        text-transform: uppercase;
        color: blue;
    }

    .unused {
        color: red;
    }
</style>
<p>This is a paragraph.</p>
----
//}}}

Then we look at the CSS output.

//{{{ image::./images/chapter-2-9.png
[#img-chapter]
[link=./images/chapter-2-9.png,window=_blank]
.Svelte Basic -9
image::./images/chapter-2-9.png[align="center"]
//}}}

That `"color: red"` has been stripped out. It's not included in the CSS that
gets sent to browser.  It's also give a convenient warning tells us that
there's *unused* CSS selector.

So we can go ahead and remove that from our source code.

=== HTML Tags

By default, when you have a curly brace `" {} "` with a Javascript expression
inside. It is evaluated as *"text"*. Which means that I click over the result
- tab, this String contains HTML.  We can actually see the angle bracket `"<
>"` of that time of that tags.

In some situations, you want to put the actual HTML on the page and that's
really easy to do. We just prefix it with `"{@html string}"`. So Special
type of tags.

// {{{  HTML tags App.svelte
[source, html]
----
// App.svelte
<script>
    let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
----
// }}}

Then now you can see that. This "bold" - text now.

//{{{ image::./images/chapter-2-10.png
[#img-chapter]
[link=./images/chapter-2-10.png,window=_blank]
.Svelte Basic -10
image::./images/chapter-2-10.png[align="center"]
//}}}

Now, there is a big caveat here. There's *NO sanitation* that happens.

What that means is, that you could potentially inject some *dangerous* HTML. So
you need to make sure that HTML that you're putting inside your Component comes
from source that you trust.

If it's coming form a source that you don't trust. Like some "user - input"
that you don't control, then you need to make sure that you sanitize that HTML
to remove any "Script - tags" or anything else that could be used in
a *"cross-site scripting attack"* before you include that on a page that is
visible to another user.

=== Add Global Styles

Okay, so we just had a great question about how whether you can add "Global
Styles" if you need to?

So we're going to skip back to the section on "Nested - Component".

We're going to out that nested paragraph inside the Component.

In this time, in our `"App.svelte"` we're going to changes this `"p {}"`
- Selector to a Global `"p {}"` - Selector. We do that using some syntax that
we stole from "CSS - modules" project `":global()"` and we wrap the `"p"`
selector like so,

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    :global(p) {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

Now every `"p {}"` - element on the page will be affected those Styles and the
way that works.

//{{{ image::./images/chapter-2-11.png
[#img-chapter]
[link=./images/chapter-2-11.png,window=_blank]
.Svelte Basic -11
image::./images/chapter-2-11.png[align="center"]
//}}}

If you look at the CSS - output, just hasn't bothered to apply the Scoping
selected "Class - name" do that Selector.

//{{{ image::./images/chapter-2-12.png
[#img-chapter]
[link=./images/chapter-2-12.png,window=_blank]
.Svelte Basic -12
image::./images/chapter-2-12.png[align="center"]
//}}}

So that useful. If you need to do something like change styles on the "Body
- Element". Because obviously you're not going to have the Body - Element
inside your Component.

But generally, that's something that you don't want to use too much if you have
Global Styles.

I personally think they should go in a `"global.css"` - file. That's where
I put my Rules about `"colors"` and `"typography"`. All of my "CSS - Variables"
of the page.

But this techniques is a useful escape hatch for the times that you do need it.

**⬆xref:_table_of_contents[back to top]**
//}}}

// {{{ 3 == Data Reactivity
[[_data_reactivity]]
== Data Reactivity

=== Reactivity / Assignment

So far all the data we've used inside this Components has been *static*. It
hasn't changed.  But a lot of time when you're building web app, the data in
your Components will change and Svelte has a powerful system of *Reactivity* to
make that possible.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
let count  = 0;

function handleClick() {
    count += 1;
}
</script>

<button onclick={handleClick}>
    Clicked {count{ {count === 1 ? "time" : "times"}
</button>
----
// }}}

So first, we're going to add an Event - handler to this "button". We are go
into more detail about Event - handlers.  What they are and how they work in
a later section of this tutorial.

But for now just roll with it. `"on:click"` equals and then `"handleClick"`
give it a reference to this function. Which is defined inside our `<script>`
- block. Then we just need to implement `"handleClick()"`, and is very simple.
`"count += 1"`.

Now when we click this button, the `"count"` clicks up.

The way this works is, that Svelte instruments the "Assignment". When it sees
this `"count += 1"` it replaces that with in "generated code", which we'll look
at in more detail later.

It Instrumented with this call to a function called `*"$$invalidate()"*`

//{{{ image::./images/chapter-2-13.png
[#img-chapter]
[link=./images/chapter-2-13.png,window=_blank]
.Svelte Basic -12
image::./images/chapter-2-13.png[align="center"]
//}}}

Which tells the component that a specific value is changed.

The Component in turn, tells that "Svelte - *Scheduler*" that the Component
needs to be re-rendered.

That is how Reactivity works on a per-value level.

=== Reactivity / Declarations

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;
    let doubled = count * 2;

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>
----
// }}}

Now, very often you'll have some State that is *derived* from other parts of
your State.  So you got button here that increments the "counter".

Let's say we want to add a *double value* which is `"count"` times  `"2"`. We
could do this `"let double = count * 2"` and then add some text beneath it
`"{count} doubled is {doubled}"`.

But it's not updating. The reason for that is, the contents of this
`"<script>"` - block executes *once* when a Component is created per Component.
So this `"let doubled = count * 2"`, that going to run at the start of the
Component - "Life cycle".  Then it's never going to be re-run.

//{{{ image::./images/chapter-2-2.gif
[#img-chapter]
[link=./images/gif/chapter-2-2.gif,window=_blank]
.Svelte Basic -13
image::./images/gif/chapter-2-2.gif[align="center"]
//}}}

We want that statement to re-run every time the value of `"count"` changes, and
we ca do that with a convenient little piece of syntax. Change that `"let"` to
`"$:"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;
    $: doubled = count * 2;
// ~~~

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>
----
// }}}

//{{{ image::./images/chapter-2-3.gif
[#img-chapter]
[link=./images/gif/chapter-2-3.gif,window=_blank]
.Svelte Basic -14
image::./images/gif/chapter-2-3.gif[align="center"]
//}}}

It doubled as you would expect.

Now this might look a little bit strange. Because this isn't JavaScript syntax
that you're probably familiar with, is in fact, valid JavaScript. This `"$:"`
called a *"Label"*, and it's used when you're building a `"while - loop"` or
`"while - loop"`.

You have a *"Label"*, then later you can do break "Label - name". That allows
you to control the flow of your application.

In a way you don't generally don't need. Outside the context of "loop" it has
no value whatsoever.

So when we were buildings Svelte we though, let's just steal that.

The reason that we have to make everything *valid* - JavaScript is, because as
I'll explain you later, we're using off the Svelte - JavaScript passes to pass
everything inside the `"<script>"` - block.

So everything has to be "Syntactically - VALID". But it doesn't mean that this
`"$: doubled = "` need to behave the way that if would ordinary behave inside
JavaScript.

We get to make the rules. So, this `"$:"` here what we call a *"Reactive
- Declaration"*.

We can have as many as we like. So I can have one that depends on Reactive
- Value of `"doubled'.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;

    $: quadrupled = doubled * 2;
    $: doubled = count * 2;
// ~~~

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>

<p>
    {count} quadrupled is {quadrupled}
</p>
----
// }}}

That also works as you would expect.

You will notice that these,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...

    $: quadrupled = doubled * 2;
    $: doubled = count * 2;

    ...
    ...
</script>
----
// }}}

Aren't defined in the order that they wouldn't ordinary need to run.  Instead
they are executed in what's called "Topological - Order".

Which means that Svelte understand the `"quadrupled"` depends on the value of
`"doubled"` and therefore need to calculated `"doubled"` before it calculate
`"quadrupled"`.

So this might look a little bit weird and a little bit alien. But I promise you
that, once you get used to it, it becomes second nature and it's a very
convenient feature.

=== Reactivity / Statement

It's not just Declarations that we can run Reactively. We can also run any
*arbitrary* - Statement in the same way.

So, for example. We can do

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: console.log(`the count is ${count}`)
...
...
</script>
----
// }}}

Then you see in console - column it gets logged every time the value changes.

So that's really useful for debugging.

You also can group Statement together by a *group*.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: {
        console.log(`the count is ${count}`);
        alert(`I SAID THE COUNT IS ${count}`);
    }
...
...
</script>
----
// }}}

You can even put the `"$:"` in front of things like `"if"` - blocks.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: if (count >= 10) {
        alert(`count is dangerously high!`);
        count = 9;
    }
...
...
</script>
----
// }}}

=== Reactivity / Updating Arrays and Objects


It's also not just simple Primitives that we can update in this fashion. We can
also use the Reactivity to updates Arrays and Objects.

But there is a caveat, which we're going to explore here.

// {{{ App.svelte
----
// App.svelte
<script>
    let numbers = [1, 2, 3, 4];

    function addNumber() {
        numbers.push(numbers.length + 1);
    }

    $: sum = numbers.reduce((t, n) => t + n, 0);
</script>

<p>{numbers.join(' + ')} = {sum}</p>

<button on:click={addNumber}>
    Add a number
</button>
----
// }}}

So we have this function `"addNumber()"`, which is going to push to our
`"numbers"` - Array. If I click the button it's not doing anything.

That because `"numbers.push*()"` is not Reactive.

Svelte doesn't look at that and say oh, when you taking this Array, therefore,
we need to recalculate anything that involves `"numbers"`. It needs to see an
assignment, that how the system works.

So we can do underneath `"numbers = numbers"`.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = numbers;
    }
...
...
</script>
----
// }}}

That one way of doing this.

But it's not very idiomatic. It looks a little bit weird. It's useful in
a pinch. But it's actually better if rather than mutating that `"numbers"`
- Arrays and then reassigning it to itself, if we can create a new copy of that
Array.

So, we create a new - Array, spread the existing value into it, spread the
existing value, and then add the new value.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = [...numbers, numbers.length + 1]
    }
...
...
</script>
----
// }}}

Now if you try to click `"Add a number"` - button. It's exactly works the same
way, and you can use similar *pattern* to replace `"pop()"`, `"shift()"`,
`"unshift()"` and `"splice()"`.

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 4 == Props
[[_props]]
== Props

=== Reactivity / Updating Arrays and Objects

We can also assign directly to properties of a recent Objects. The same way
that we assign two free.

So another way that we could do this is,

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = [numbers.length] = numbers.length + 1;
    //            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }
...
...
</script>
----
// }}}

That works exactly how you would expect.

=== Props / Declaring Props

Some point when you're building an application, you're going to need to pass
data from one Component to another, and for that we use something called a *"Prop"*.

A "Prop" is basically like an *attribute* on an Element and it stand for "Properties".

// {{{ Nested.svelte
[source, html]
----
<script>
// Nested.svelte
    let answer;
</script>

<p>The answer is {answer}</p>
----
// }}}

So here we have some State inside the `"Nested.svelte"` Component `"answer"`,
and we are showing it inside this `<p>` - tag, and it's coming across as `"undefined"`.

Even though we're passing it from `<Nested answer={42} />`.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
    import Nested from "./Nested.svelte";
</script>

<Nested answer={42} />
//~~~~~~~~~~~~~~~~
----
// }}}

The reason for that is, that as far Nested - Component (`"Nested.svelte"`) is
concerned, this `"let answer"` is *private State* that nothing else gets to interfere.

With what we need to do is, tells Svelte that answer should be considered
a property that can be set by a Parent - Component.

The way we do that is, again by abusing some existing JavaScript syntax. We're
going to use `"export"` - keyword.

This tell Svelte that, if the Parent sets the value for `"answer"` we just pass
it through, and obviously we change that, it'll update in the manner that you
would expect.

So there's a little caveat down here. This might seem a little bit weird if
you're used to using the `"export"` keyword in your JavaScript modules.

Again, it has to be syntactically valid and this is a really convenient way of
using something that's in the language that we weren't. Otherwise be very
difficult and awkward.

So just kind of roll with it for now, and it will soon become a second nature.

So we can set a d default value for an `"answer"` like,

// {{{ Nested.svelte
[source, html]
----
<script>
// Nested.svelte
    let answer = "a mystery";
    //            ~~~~~~~~~
</script>

<p>The answer is {answer}</p>
----
// }}}

Then if the Parent - Component doesn't provide a value for that `"Prop"` then
it will fall back to the default.

//{{{ image::./images/chapter-2-14.png
[#img-chapter]
[link=./images/chapter-2-14.png,window=_blank]
.Svelte Basic -15
image::./images/chapter-2-14.png[align="center"]
//}}}

First `"answers"` is `"42"`, and the second `"answers"` is determined by the
Child.

=== Props / Spread Props

Finally in Props section we have the concept of "Spread - Props".

Sometimes you have bundle of properties and you want to pass them all through to component.
In some situation, you might not know what it is going to be in that Object and physically unable to say `"a = b"`,
`"b = c"`, `"c = d"`, because you don't know what it's going to be.

So we use Spread - syntax `" ... "` which look like this,

[source, html]
----
<Info {...pkg}/>
----

I'm just get rid all of these individual properties.

[source, html]
----
<Info name={pkg.name} version={pkg.version} speed={pkg.speed} website={pkg.website}/>
----

Pass them through like so,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Info from './Info.svelte';

    const pkg = {
        name: 'svelte',
        version: 3,
        speed: 'blazing',
        website: 'https://svelte.dev'
    };
</script>

<Info {...pkg}/>
----
// }}}

Then inside `"Info.svelte"` we're exporting all of the properties that "Spread
- Object", as "individual - Props".

So nothing needs to change inside the Child - Component.

**⬆xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc
