//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun May  2 05:37:14 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_3_binding_and_lifecycle]]
== Chapter 3 Binding And Lifecycle

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_input_template_binding[Input & Template Binding]
| 2.    | xref:_media_dimension_binding[Media & Dimension Binding]
|====
//}}}

// {{{ 1 == Input & Template Binding
[[_input_template_binding]]
== Input & Template Binding

//{{{ image::./images/chapter-2-1.png
[#img-chapter]
[link=./images/chapter-3-1.png,window=_blank]
.Svelte Binding & Lifecyle -1
image::./images/chapter-3-1.png[align="center"]
//}}}

So now we're going to move on to the "Binding - Section" of the tutorial, and
as general rule data-flow in Svelte as we've seen goes from *"Parent"* - Component
to the *"Child"* - Component.

In other words, it goes TOP - DOWN.

Some times we need to BREAK that rule. Sometimes we want to get information
from an Element or Component back up to its Parent and this is very common when
we're dealing with "form" - Elements, for example.

=== Bindings / Text Inputs

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input value={name}>

<h1>Hello {name}!</h1>
----
// }}}

So, here's  an `"<input>"` - Element. Doesn't currently doing anything.

But what we want to happen is, for the changes in that `"<input>"` - Element to
be reflected in the State of of the Component.

There is one way that we could do this using Events.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input on:input={handleInput} value={name}>
//     ~~~~~~~~~~~~~~~~~~~~~

<h1>Hello {name}!</h1>
----
// }}}

Then we could add Event - Handler and do all of the still that you would
normally do. But it's a little bit *inconvenient*.

Instead in Svelte we can just turn this "Prop" `"value={name}"`, and this
attribute into a "binding" with the "bind - directive" `"bind:value={name}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input bind:value={name}>
//     ~~~~

<h1>Hello {name}!</h1>
----
// }}}

Now, whenever the value of the `"<input>"` - Element changes, the value also
changed.

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Media Dimension Binding
[[_media_dimension_binding]]
== Media & Dimension Binding
:fn-media_element_binding: link:https://svelte.dev/docs#Media_element_bindings

Another type of binding that might no be obvious because it's not a `"<form>"`
- Element is, the Media- Element Binding, and there's a bunch of different
Media Element Bindings.

Media elements (<audio> and <video>) have their own set of bindings — six
readonly ones...

- duration (readonly) — the total duration of the video, in seconds
- buffered (readonly) — an array of {start, end} objects
- played (readonly) — ditto
- seekable (readonly) — ditto
- seeking (readonly) — boolean
- ended (readonly) — boolean

...and five two-way bindings:

- currentTime — the current playback time in the video, in seconds
- playbackRate — how fast or slow to play the video, where 1 is 'normal'
- paused — this one should be self-explanatory
- volume — a value between 0 and 1
- muted — a boolean value where true is muted

Videos additionally have readonly `videoWidth` and `videoHeight` bindings.

All of this things can be added to a Medial Element Binding.

It was quite a lot of markup in this tutorial. So if you want to dive into it,
then have a look at this in your own time.

But for now we I want you all see what this actually look like, once we've
added All of the bindings to this `"<videos>"` - Element.

// {{{ App.svlete
[source, html]
----
<script>
    // These values are bound to properties of the video
    let time = 0;
    let duration;
    let paused = true;

    let showControls = true;
    let showControlsTimeout;

    function handleMousemove(e) {
        // {{{
        // Make the controls visible, but fade out after
        // 2.5 seconds of inactivity
        clearTimeout(showControlsTimeout);
        showControlsTimeout = setTimeout(() => showControls = false, 2500);
        showControls = true;

        if (!(e.buttons & 1)) return; // mouse not down
        if (!duration) return; // video not loaded yet

        const { left, right } = this.getBoundingClientRect();
        time = duration * (e.clientX - left) / (right - left);
    } // }}}

    function handleMousedown(e) {
        // {{{
        // we can't rely on the built-in click event, because it fires
        // after a drag — we have to listen for clicks ourselves

        function handleMouseup() {
            if (paused) e.target.play();
            else e.target.pause();
            cancel();
        }

        function cancel() {
            e.target.removeEventListener('mouseup', handleMouseup);
        }

        e.target.addEventListener('mouseup', handleMouseup);

        setTimeout(cancel, 200);
    } // }}}

    function format(seconds) {
        // {{{
        if (isNaN(seconds)) return '...';

        const minutes = Math.floor(seconds / 60);
        seconds = Math.floor(seconds % 60);
        if (seconds < 10) seconds = '0' + seconds;

        return `${minutes}:${seconds}`;
    } // }}}
</script>

<h1>Caminandes: Llamigos</h1>
<p>From <a href="https://cloud.blender.org/open-projects">Blender Open Projects</a>. CC-BY</p>

<div>
    <video
        poster="https://sveltejs.github.io/assets/caminandes-llamigos.jpg"
        src="https://sveltejs.github.io/assets/caminandes-llamigos.mp4"
        on:mousemove={handleMousemove}
        on:mousedown={handleMousedown}
        bind:currentTime={time}
        bind:duration
        bind:paused>
        <track kind="captions">
    </video>

    <div class="controls" style="opacity: {duration && showControls ? 1 : 0}">
        <progress value="{(time / duration) || 0}"/>

        <div class="info">
            <span class="time">{format(time)}</span>
            <span>click anywhere to {paused ? 'play' : 'pause'} / drag to seek</span>
            <span class="time">{format(duration)}</span>
        </div>
    </div>
</div>

<style>
    /*{{{*/
    div {
        position: relative;
    }

    .controls {
        position: absolute;
        top: 0;
        width: 100%;
        transition: opacity 1s;
    }

    .info {
        display: flex;
        width: 100%;
        justify-content: space-between;
    }

    span {
        padding: 0.2em 0.5em;
        color: white;
        font-size: 1.4em;
        text-shadow: 0 0 8px black;
        opacity: 0.7;
    }

    .time {
        width: 3em;
    }

    .time:last-child { text-align: right }

    progress {
        display: block;
        width: 100%;
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
    }

    progress::-webkit-progress-bar {
        background-color: rgba(0,0,0,0.2);
    }

    progress::-webkit-progress-value {
        background-color: rgba(255,255,255,0.6);
    }

    video {
        width: 100%;
    }
    /*}}}*/
</style>
----
// }}}

As you can see from the code above, we bind into the `currentTime`, we bind
into the `duration`, we bind to the `pause` - State; and we're using those to
build the "video player" - UI.

I can click anywhere and the video will start. I can drag, rewind, and click
the pause.

Now, nice thing about the Media Element Bindings is, they're not just using
Native - DOM - Events. They're actually using
`"Window.requestAnimationFrame()"` where applicable. So that the current time
is updated 60 times a second.

**⬆xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc
