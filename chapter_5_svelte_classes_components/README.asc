//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 5
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon May  3 06:28:45 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_5_class_and_components]]
== Chapter-5 Class and Components

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_classes_directive[Class Directive]
| 2.    | xref:_composing_components_with_slots[Composing Components with Slots]
| 3.    | xref:_context_api[Context API]
| 4.    | xref:_special_elements[Special Elements]
| 5.    | xref:_module_context_for_sharing_code[Module Context for Sharing Code]
| 6.    | xref:_debugging_code[Debugging Code]
| 7.    | xref:_creating_a_svelte_app_from_scratch[Creating a Svelte App from Scratch]
|====
//}}}

// {{{ 1 == Classes Directive
[[_classes_directive]]
== Classes Directive

//{{{ image::./images/chapter-5-1.png
[#img-chapter]
[link=./images/chapter-5-1.png,window=_blank]
.Class Directive
image::./images/chapter-5-1.png[align="center"]
//}}}

So just like any other attributes on the DOM - Elements, you can set the Class of
an Element use JavaScript inside curly braces (`"class={}"`).

But this is such common pattern that we have a special by directive for
classes. Specifically that allow you to toggle Classes based on some condition.

// {{{ === Classes / The Class Directive
[[_classes_the_class_directive]]
=== Classes / The Class Directive

Just take a look in this App.svelte code below,

// {{{ app.svelte
[source, html]
----
// app.svelte
<script>
    let current = 'foo';
</script>

<button
    class="{current === 'foo' ? 'selected' : ''}"
    on:click="{() => current = 'foo'}"
>foo</button>

<button
    class="{current === 'bar' ? 'selected' : ''}"
    on:click="{() => current = 'bar'}"
>bar</button>

<button
    class="{current === 'baz' ? 'selected' : ''}"
    on:click="{() => current = 'baz'}"
>baz</button>

<style>
...
...
</style>
----
// }}}

So, instead of having `{current === 'foo' ? 'active' : ''}`, we can just
replace that whole things with, `class:selected={current === 'foo'}`.

// {{{ app.svelte
[source, html]
----
// app.svelte
<script>
    let current = 'foo';
</script>


<button
    class:selected="{current === 'foo'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'foo'}"
>foo</button>

<button
    class:selected="{current === 'bar'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'bar'}"
>bar</button>

<button
    class:selected="{current === 'baz'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'baz'}"
>
    baz
</button>

<style>
...
...

    .selected {
/*  ~~~~~~~~~ */
        background-color: #ff3e00;
        color: white;
    }
</style>
----
// }}}

We apply that to all of those.

So now I will click on these the active - Class, which add this `background`
- style to the button, will get applied whenever this condition
`class:selected={current === 'foo'}` is `"true"` for each of the button intern,
and that's just less stuff to write.

//{{{ image::./images/gif/chapter-5-1.gif
[#img-chapter]
[link=./images/gif/chapter-5-1.gif,window=_blank]
.Classes / The Class Directive
image::./images/gif/chapter-5-1.gif[align="center"]
//}}}
// }}} ===

// {{{ === Classes / Shorthand Class Directive
[[_classes_shorthand_class_directive]]
=== Classes / Shorthand Class Directive

Just like with the `"bind:value"` shorthand , and the `"source=source"`
shorthand that we've already encountered.

You'll very often have a situation like this, Where the Class you're toggling
is the same as the name of the condition.

// {{{ App.svelte
[source, html]
----
// App.svelte
....
....

<div class:big={big}>
    some {big ? 'big' : 'small'} text
</div>

----
// }}}

So if you have something like this Class, `"class:big={big}"`,

We can get rid of the equals `" ={big}"` - part of that to be like,

// {{{ App.svelte
[source, html]
----
// App.svelte
....
....

<div class:big>
//   ~~~~~~~~~
    some {big ? 'big' : 'small'} text
</div>

----
// }}}

Svelte will fill-in the blank for us.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Composing Components with Slots
[[_composing_components_with_slots]]
== Composing Components with Slots

So far when talking about Components containing other Components. It's been
*direct* parent-child relationship.

But very often when you're building an application you will need to pass some
*Content* into the Component, not as "Props", but as "Marker"; and for that we
have something called "Slots".

NOTE: Slot is a process called Component Composition.

// {{{ === Component Composition / Slots
[[_component_composition_slots]]
=== Component Composition / Slots
So in the same way that an Element can have children like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
<div>
    <p>I'm the child of the div</p>
</div>
----
// }}}

A `"<div>"` can contain a `"<p>"`.

A Component can have children, but it needs to know where to put them.

So inside our `"Box.svelte"` here, which is going to contain our Content.

// {{{ Box.svelte
[source, html]
----
// Box.svelte
<div class="box">
    <slot></slot>
</div>

<style>
...
...
</style>
----
// }}}

I'll use `"<slot>"` - Element.

Now that we've done that, inside our `"App.svelte"`, we can put some content
Inside the `"<Box>"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Box from './Box.svelte';
</script>

<Box>
    <h2>Hello!</h2>                                     // <<<
    <p>This is a box. It can contain anything.</p>      // <<<
</Box>
----
// }}}

We can put whatever we like, inside that `"<slot>"`.
// }}} ===

// {{{ === Component Composition / Slots Fallbacks
[[_component_composition_slots_fallbacks]]
=== Component Composition / Slots Fallbacks

In some situation you might need to have some *fallback* content for your
Component.

Inside the `"<slot>"`, you can specify your *fallback* like so,

// {{{ Box.svelte
[source, html]
----
// Box.svelte
<div class="box">
    <slot>
        <em>Content we provided</em>
    </slot>
</div>

<style>
...
...
</style>
----
// }}}

Then if the Component is created without any Content like so,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Box from './Box.svelte';
</script>

<Box>
    <h2>Hello!</h2>
    <p>This is a box. It can contain anything.</p>
</Box>

<Box />     // <<<
----
// }}}

It will use "fallback" marker instead.

//{{{ image::./images/chapter-5-2.png
[#img-chapter]
[link=./images/chapter-5-2.png,window=_blank]
.Component Composition - Slot
image::./images/chapter-5-2.png[align="center"]
//}}}
// }}} ===

// {{{ === Component Composition / Named Slot
[[_component_composition_named_slot]]
=== Component Composition / Named Slot

A component can contain *multiple Slots*. The one we just saw is the so-called
"Default - Slot", but you might have Content that needs to be injected in
a particular place inside a Component. For that we use something called "Name
- Slot".

In this sub-chapter we have a `"ContactCard"` - Component, and we have three
- Slots.

// {{{ COntactCard.svelte
[source, html]
----
// ContactCard.svelte
<article class="contact-card">
    <h2>
        <slot>                                              // <<<
            <span class="missing">Unknown name</span>       // <<<
        </slot>                                             // <<<
    </h2>

    <div class="address">
        <slot>                                              // <<<
            <span class="missing">Unknown address</span>    // <<<
        </slot>                                             // <<<
    </div>

    <div class="email">
        <slot>                                              // <<<
            <span class="missing">Unknown email</span>      // <<<
        </slot>                                             // <<<
    </div>
</article>

<style>
...
...
</style>
----
// }}}

One inside this `"<h2>"`, one inside the `"address"` - class, and one inside
the `"email"` -class.

We just need to provide name for all of those things.

// {{{ COntactCard.svelte
[source, html]
----
// ContactCard.svelte
<article class="contact-card">
    <h2>
        <slot name="name">
//            ~~~~~~~~~~
            <span class="missing">Unknown name</span>
        </slot>
    </h2>

    <div class="address">
        <slot name="address">
//            ~~~~~~~~~~~~~
            <span class="missing">Unknown address</span>
        </slot>
    </div>

    <div class="email">
        <slot name="email">
//            ~~~~~~~~~~~
            <span class="missing">Unknown email</span>
        </slot>
    </div>
</article>

<style>
...
...
</style>
----
// }}}

Then now, if we're using that Component in another Component. We can put in our
contact details and provide the "Slot - Name" as the "Slot - attribute" on the
Element, and it will get put in the correct place.

// {{{ App.svelte
[source, html]
----
// App.svelte
<ContactCard>
    <span slot="name">
//        ~~~~~~~~~~~
        P. Sherman
    </span>

    <span slot="address">
//        ~~~~~~~~~~~~~
        42 Wallaby Way<br>
        Sydney
    </span>
</ContactCard>
----
// }}}

Again if we don't provide any Content fro a particular Slot, like we haven't
provided a `slot="email"`, then it will use the "Fallback" - Content,
specifying the Child - Component.
//}}} ===

// {{{ === Component Composition / Slot Props
[[_component_composition_slot_props]]
=== Component Composition / Slot Props

In some situation, you're going to need to *pass data* from the Child - Component
back to the Parent - Component, so that it can be rendered inside the
Component - content.

Here we have a `"Hoverable"` - Component that look like this,

// {{{ Hoverable.svelte
[source, html]
----
// Hoverable.svelte
<script>
    let hovering;

    function enter() {
        hovering = true;
    }

    function leave() {
        hovering = false;
    }
</script>

<div on:mouseenter={enter} on:mouseleave={leave}>
    <slot></slot>
</div>
----
// }}}

What we want to do is, tell the Contents of the `"Hoverable"` - Component,
whether or not return if we're currently hovering on it.

So it needs to pass the data from the Slot to the Contents.

The Content looks like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable>
    <div class:active={hovering}>
        {#if hovering}
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

So inside the `"Hoverable.svelte"`, we going to add `<slot
hovering={hovering}></slot>`, or we can just do `<slot {hovering}></slot>`

// {{{ Hoverable.svelte
[source, html]
----
// Hoverable.svelte
<script>
    let hovering;

    function enter() {
        hovering = true;
    }

    function leave() {
        hovering = false;
    }
</script>

<div on:mouseenter={enter} on:mouseleave={leave}>
    <slot hovering={hovering}></slot>
//  ~~~~~~~~~~~~~~~~~~~~~~~~~ or
//  <slot {hovering}></slot>
</div>
----
// }}}

Then inside `"App.svelte"`, we're going to expose that by using the "Let
- Directive" (`"let: "`).

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable let:hovering={hovering}>
//         ~~~~~~~~~~~~~~~~~~~~~~~
    <div class:active={hovering}>
        {#if hovering}
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

Now, if you hover this Component, it will tell that it's being hover upon.

//{{{ image::./images/gif/chapter-5-2.gif
[#img-chapter]
[link=./images/gif/chapter-5-2.gif,window=_blank]
.Slot Props
image::./images/gif/chapter-5-2.gif[align="center"]
//}}}

We can change the name of this variable. For example, we change `"{hovering}"`
to `"{active}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable let:hovering={active}>
//                      ~~~~~~~
    <div class:active>
//       ~~~~~~~~~~~~ equal to class:active={active}
        {#if active}
//           ~~~~~~
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

This Scope, the `"let"` - value is Scope of the Contents of the Component. It
won't escape that Scope. So we can have multiple of these `"<Hoverable>"`.

The value of the Scope, will only be applied to the affected Component, none of
its siblings.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
//}}}

// {{{ 3 == Context API
[[_context_api]]
== Context API

The time you'll have a group of Components that need to work together in some
way.

// {{{ === Context API / setContext and getContext
[[context_api_setcontext_and_getcontext]]
=== Context API / setContext and getContext
:fn-mapbox_gl: link:https://mapbox.com

For example, you might have a `"<Map>"` - Components like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Map from './Map.svelte';
    import MapMarker from './MapMarker.svelte';
</script>

<Map lat={35} lon={-84} zoom={3.5}>
    <MapMarker lat={37.8225} lon={-122.0024} label="Svelte Body Shaping"/>
    <MapMarker lat={33.8981} lon={-118.4169} label="Svelte Barbershop & Essentials"/>
    <MapMarker lat={29.7230} lon={-95.4189} label="Svelte Waxing Studio"/>
    <MapMarker lat={28.3378} lon={-81.3966} label="Svelte 30 Nutritional Consultants"/>
    <MapMarker lat={40.6483} lon={-74.0237} label="Svelte Brands LLC"/>
    <MapMarker lat={40.6986} lon={-74.4100} label="Svelte Medical Systems"/>
</Map>
----
// }}}

The `"App.svelte"` renders a "{fn-mapbox_gl}[Mapbox - GL,window=_blank]" map.
Then inside that we might want to have these `"<MapMarker>"` - Components, that
affects the `"<Map>"` in some way.

What we don't want to do is, have to store a reference to the `"Map"`
- Component and pass it down to the `"MapMarker"` - Components or vice-versa.

We want all of that coordination to happen within the Components themselves.
Because that makes our lives, as the users of these Components much easier.

The way we do that in Svelte is, with something called the "Context - API".

NOTE: "Context - API" is a mechanism that allows Components to talk to each
other, *without data being passed around as "Props"*.

The "Context - API" is coming in *two* halves,

- `"setContext"` - is called on a "Parent - Component", and that makes the
  Context available to every "Child - Component" is rendered within it.

- `"getContext"`

So in `"Map.svelte"` here, what we need to do is *set some Context*.

// {{{ Map.svelte
[source, html]
----
// Map.svelte
<script>
    import { onMount, setContext } from 'svelte';
//                    ~~~~~~~~~~
    import { mapbox, key } from './mapbox.js';
//                   ~~~

    setContext(key, {           // <<<
        getMap: () => map       // <<<
    })                          // <<<

    ...
    ...

</script>

...
...
----
// }}}

I'm going to import `"setContext"` from `"svelte"`.

I'm going to import this `"key"` - value from `"mapbox.js"` that will become
clear in a minute.

Then we are going to set the Context with that `"key"`, and then just passing
an Object with a `"getMap"` - method.

Now, that second argument to `"getContext"` can be anything you like. It's
really doesn't matter. But typically what it will be is an Object containing
a variety of functions that the "Child - Components" are going to use to
communicate with the "Parent - Component".

So on the other side of the equation, inside the `"MapMarker"` - Component.
We're going to need to get a reference to the `"mapbox.Map()"`.

// {{{ MapMarker.svelte
[source, html]
----
// MapMarker.svelte
<script>
    import { getContext } from 'svelte';            // <<<
    import { mapbox, key } from './mapbox.js';
//                   ~~~

    const { getMap } = getContext(key);             // <<<
    const map = getMap();                           // <<<

    export let lat;
    export let lon;
    export let label;

    const popup = new mapbox.Popup({ offset: 25 })
        .setText(label);

    const marker = new mapbox.Marker()
        .setLngLat([lon, lat])
        .setPopup(popup)
        .addTo(map);
</script>
...
...
----
// }}}

So we're going to import `"getContext"` from `"svelte"`.

Again we're going to import that `"key"` from `"mapbox.js"`.

Then we're going to call `"getContext"` and get a reference to that `"getMap()"`
- function.

Then each `"MapMarker"` is going to have it's own reference to `"map"`.

//{{{ image::./images/gif/chapter-5-3.gif
[#img-chapter]
[link=./images/gif/chapter-5-3.gif,window=_blank]
.Slot Props
image::./images/gif/chapter-5-3.gif[align="center"]
//}}}

So, let's take a look at what's happening.

Here we have these `'<MapMarker>"` - Components inside the `"<Map>"` in
`"App.svelte"`. They got a *latitude* `"lat"`, and *longitude* `"lon"` and
`"label="`.

The way that they're being applied to the Main `"<Map let={35} lon{-84}
zoom={3.5}"` - Object here is through the `"mapbox"` - API.

Once we have reference to this map `"const map = getMap()"` in
`"MapMarker.svelte". We can create a `"popup"` using the `"mapbox.popup()"`
- API.

Then we create a `"marker"` that use that `"popup()"`.

Then we get added to the Map - Object (`".addto(map)"`) that we had a reference
to.

You can imagine, that we didn't have the Context - API. We would have to
referenced - references to all these things being passed around, and it would
make our `"App.svelte"` a lot more crowded.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 4 == Special Elements
[[_special_elements]]
== Special Elements

So we've seen the Svelte - Components can contain any HTML. Validator - HTML,
has already valid spoke. But op top of that, Svelte provide a member of what we
call Special - Elements.

// {{{ === Special Elements / <svelte:self>
[[_special_elements_svelte_self]]
=== Special Elements / <svelte:self>

The first of these are going to look at `"<svelte:self>"`.

NOTE: `"<svelte:self>"` is a way that a Component can *contain itself*
recursively.

It's really useful for things like "Tree - Views".

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Folder from './Folder.svelte';

    let root = [
        {
            type: 'folder',
            name: 'Important work stuff',
            files: [
                { type: 'file', name: 'quarterly-results.xlsx' }
            ]
        },
        {
            type: 'folder',
            name: 'Animal GIFs',
            files: [
                {
                    type: 'folder',
                    name: 'Dogs',
                    files: [
                        { type: 'file', name: 'treadmill.gif' },
                        { type: 'file', name: 'rope-jumping.gif' }
                    ]
                },
                {
                    type: 'folder',
                    name: 'Goats',
                    files: [
                        { type: 'file', name: 'parkour.gif' },
                        { type: 'file', name: 'rampage.gif' }
                    ]
                },
                { type: 'file', name: 'cat-roomba.gif' },
                { type: 'file', name: 'duck-shuffle.gif' },
                { type: 'file', name: 'monkey-on-a-pig.gif' }
            ]
        },
        { type: 'file', name: 'TODO.md' }
    ];
</script>

<Folder name="Home" files={root} expanded/>
----
// }}}

We have  `"folder"` containing `"files"`, and `"folders"` containing other
`"folders"`.

We want to render this Tree into our app.

So we going to change `"Folder.svelte"` - Component,

What we want to be able to do is, just type in `"<Folder {...file} />"`.

// {{{ Folder.svelte
[source, html]
----
// Folder.svelte
<script>
...
...

{#if expanded}
    </ul>
        {#each files as file}
            <li>
                {#if file.type === 'folder'}
                    <Folder {...file} />
//                  ~~~~~~~~~~~~~~~~~
                {:else}
                    <File {...file}/>
                {/if}
            </li>
        {/each}
    <ul>
{/if}

<style>
...
...
</style>
----
// }}}

But that not going to work. Because this Component does NOT have a *reference*
to anything called `"<Folder>"`.

Instead we need to reference `"<svelte:self>"` like so,

// {{{ Folder.svelte
[source, html]
----
// Folder.svelte
<script>
    import File from './File.svelte';

    export let expanded = false;
    export let name;
    export let files;

    function toggle() {
        expanded = !expanded;
    }
</script>

<span class:expanded on:click={toggle}>{name}</span>

{#if expanded}
    </ul>
        {#each files as file}
            <li>
                {#if file.type === 'folder'}
                    <svelte:self {...file}/>
//                  ~~~~~~~~~~~~~~~~~~~~~~~~
                {:else}
                    <File {...file}/>
                {/if}
            </li>
        {/each}
    <ul>
{/if}

<style>
...
...
</style>
----
// }}}

Now we have a Tree - View that represent the Data - Structure shown below,

//{{{ image::./images/gif/chapter-5-4.gif
[#img-chapter]
[link=./images/gif/chapter-5-4.gif,window=_blank]
.Special Elements / <svelte:self>
image::./images/gif/chapter-5-4.gif[align="center"]
//}}}
// }}} ===

// {{{ === Special Elements / <svelte:component>
[[_special_elements_svelte_component]]
=== Special Elements / <svelte:component>

We also have a `"<svelte:component>"` which allows you to use Dynamic
- Components.

So at the moment we have a `"<select>"` - drop-down that is bound to these
`"<RedThing />"`, `"<GreenThig>"` and `"<Bluething>"` - Components.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

{#if selected.color === 'red'}
    <RedThing/>                         // <<<
{:else if selected.color === 'green'}
    <GreenThing/>                       // <<<
{:else if selected.color === 'blue'}
    <BlueThing/>                        // <<<
{/if}
----

// }}} ===

But it would be a lot nicer if we could just have a single thing that changed
the value of the Component dynamically.

So we just get rid of all that, and we use the special this "Prop", `"this={selected.component}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

<svelte:component this={selected.component}/>   // <<<
----

// }}} ===

That behave exactly the same way as it did before.

If `"this={null}"` - value, then it wouldn't render anything at all.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

<svelte:component this={null}/>   // <<<
----
// }}}
// }}} ===

// {{{ === Special Elements / <svelte:window>
[[_special_elements_svelte_window]]
=== Special Elements / <svelte:window>

In the same way that we can add Event - Listener to DOM - Element. We can add
Event - Listener to the Window - Object with `"<svelte:window>"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let key;
    let keyCode;

    function handleKeydown(event) {
        key = event.key;
        keyCode = event.keyCode;
    }
</script>

<svelte:window on:keydown={handleKeydown}/>     // <<<

<div style="text-align: center">
    {#if key}
        <kbd>{key === ' ' ? 'Space' : key}</kbd>
        <p>{keyCode}</p>
    {:else}
        <p>Focus this window and press any key</p>
    {/if}
</div>

<style>
...
...
</style>

----
// }}}

So here, I'm going to add the `"<svelte:window>"` and add the
`"on:keydown:{handleKeydown}"` - Handler which is define as a `"handleKeydown"`
- function.

So now if I focus to the Window, that `"keydown"` - Handler it is going to get
a call whenever the Window receives a `"keydown"` - Event.

Just like with DOM - Events, we can use Modifiers, like `"preventDefault"` and
so on.
// }}} ===

// {{{ === Special Elements / <svelte:window> Binding
[[_special_elements_svelte_window_binding]]
=== Special Elements / <svelte:window> Binding

We can also add Binding to the Window.

In this `App.svelte"` - Component, we have a bunch of images from the
"firewroks" game. A nice little Parallax effect that they have on their
homepage.

I'm going to bind the `"scroll"` - value of the window to some local - State.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    const layers = [0, 1, 2, 3, 4, 5, 6, 7, 8];

    let y;
</script>

<svelte:window bind:scrollY={y}/>   // <<<

<a class="parallax-container" href="https://www.firewatchgame.com">
    {#each layers as layer}
        <img
        style="transform: translate(0,{-y * layer / (layers.length - 1)}px)"
//             ~~~~~~~~~               ~~
        src="https://www.firewatchgame.com/images/parallax/parallax{layer}.png"
        alt="parallax layer {layer}"
        >
    {/each}
</a>

<div class="text">
    <span style="opacity: {1 - Math.max(0, y / 40)}">
//                                         ~
        scroll down
    </span>

    <div class="foreground">
        You have scrolled {y} pixels
//                        ~~~
    </div>
</div>

<style>
...
...
</style>
----
// }}}

So we have this `"y"` - value which is an initialized and we're using that in
our markup.

We using it to determine the `"transform:"` of each of the images that from
our Parallax - Layer.

We're also using it inside this `"<span>"` - Style.

Also we're using it inside some text `"You have scrolled {y} pixels"`.

So we're going to Bind the value of the Windows `"scroolY"` - value to our
local `"{y}"` - variable | (`"<svelte:window bind:scrollY={y}/>"`).

Now, as I interact with this Window, we get this nice beautiful Parallax
motion.

//{{{ image::./images/gif/chapter-5-5.gif
[#img-chapter]
[link=./images/gif/chapter-5-5.gif,window=_blank]
.Special Elements / <svelte:window> Binding
image::./images/gif/chapter-5-5.gif[align="center"]
//}}}

There's a few different Bindings that we have access to as well as the
`"scrollY"` - value.

The list of properties you can bind to is as follows:

- `"innerWidth"`
- `"innerHeight"`
- `"outerWidth"`
- `"outerHeight"`
- `"scrollX"`
- `"scrollY"`
- `"online"` — an alias for `"window.navigator.onLine"`. It's really useful for
  indicating that the reason that your app isn't receiving any data is because
  the app is currently offline.

All except `"scrollX"` and `"scrollY"` are *readonly*.
// }}} ===

// {{{ === Special Elements / <svelte:body>
[[_special_elements_svelte_body]]
=== Special Elements / <svelte:body>

Just like `"<svelte:window>"`, we have also `"<svelte:body>"` - special Element
that allows you to Listen for Event that fire on `"document.body()"`.

It's particularly useful for the `"mouseenter"` and `"mouseleave"` - Handlers
which don't fire on Window.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let hereKitty = false;

    const handleMouseenter = () => hereKitty = true;
    const handleMouseleave = () => hereKitty = false;
</script>


<svelte:body                            // <<<
    on:mouseenter={handleMouseenter}    // <<<
    on:mouseleave={handleMouseleave}    // <<<
/>

<!-- creative commons BY-NC http://www.pngall.com/kitten-png/download/7247 -->
<img
    class:curious={hereKitty}
    alt="Kitten wants to know what's going on"
    src="tutorial/kitten.png"
>
<style>
...
...
</style>
----
// }}}

So going to find `"<svelte:body>"` - tag here, and add the `on:mouseenter"` and
`"on:mouseleave"` That have been defined.

Now when we move our Mouse into the window, a little cat appear.

//{{{ image::./images/gif/chapter-5-6.gif
[#img-chapter]
[link=./images/gif/chapter-5-6.gif,window=_blank]
.Special Elements / <svelte:body>
image::./images/gif/chapter-5-6.gif[align="center"]
//}}}

// }}} ===

// {{{ === Special Element / <svelte:head>
[[_special_element_svelte_head]]
=== Special Element / <svelte:head>

The `'<svelte:head>"` - Element allow us to inject Content into the `"<head>"`
of the document of the document.

Normally, obviously all of your Body - Content is going to go in the
`"<body>"`. But sometimes you need to do things like add a `"stylesheet"`, we
can do that here,

// {{{ App.svelte
[source, html]
----
// App.svelte
<svelte:head>
    <link rel="stylesheet" href="tutorial/dark-theme.css">
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</svelte:head>

<h1>Hello world!</h1>
----
// }}}

We also can change the Document - Title and other things like that, inside the
`"<svelte:head>"` - Element.

NOTE: In Server-Side Rendering (SSR) mode, contents of <svelte:head> are
returned separately from the rest of your HTML.
// }}} ===

// {{{ === Special Elements / <svelte:options>
=== Special Elements / <svelte:options>

Finally, we hae `"<svelte:options>"` - Elements, which allows you to specify
`"options"` that are used by the Compiler to control the output of the
Component.

We're going to use the `immutable` - Option for example.

This is an app, containing a bunch of "Todo", and what you notice is, anytime
we toggle any of the `"Todos"`, all todo the `"Todos"` is get *re-rendered*.

We can see that because we have this `"afterUpdate"` - `"flash()"` function
that runs.

// {{{ Todo.svelte
[source, html]
----
// Todo.svelte
<script>
    import { afterUpdate } from 'svelte';
    import flash from './flash.js';

    export let todo;

    let div;

    afterUpdate(() => {         // <<<
        flash(div);             // <<<
    });
</script>

<!-- the text will flash red whenever the `todo` object changes -->
<div bind:this={div} on:click>
    {todo.done ? '👍': ''} {todo.text}
</div>

<style>
    div {
        cursor: pointer;
        line-height: 1.5;
    }
    </style>
----
// }}}

`"afterUpdate()"` runs whenever the Component received any new State.

In ideal world, when we change "Todo" that doesn't affect a particular
Component.

So we can optimize this by telling this `"<Todo>"` - Component that it should
expect *immutable data*. Which is to say that, if we're going to give it a new
"Todo", than it's going to be an entirely new Object. We're NOT mutating
anything here.

So, if we add `"<svelte:options>"` - Element to our `"Todo.svelte"`.

// {{{ Todo.svelte
[source, html]
----
// Todo.svelte
<svelte:options immutable={true}/>      // <<<

<script>
    import { afterUpdate } from 'svelte';
    import flash from './flash.js';

    export let todo;

    let div;

    afterUpdate(() => {
        flash(div);
    });
</script>

<!-- the text will flash red whenever the `todo` object changes -->
<div bind:this={div} on:click>
    {todo.done ? '👍': ''} {todo.text}
</div>

<style>
    div {
        cursor: pointer;
        line-height: 1.5;
    }
    </style>
----
// }}}

Then now when we toggle these `"Todos"`, only the one that we're actually
toggling is receiving the "flash". Because the other `"Todos"` is they're
complexly unaffected, their data hasn't changed.

Here is a list of all other things that you can use with `"<svelte:optiions>"`.

The options that can be set here are:

- `"immutable={true}"` — you never use mutable data, so the compiler can do
  simple referential equality checks to determine if values have changed

- `"immutable={false}"` — the default. Svelte will be more conservative about
  whether or not mutable objects have changed

- `"accessors={true}"` — adds getters and setters for the component's props

- `"accessors={false}"` — the default

- `namespace="..."` — the namespace where this component will be used, most
  commonly "svg"

- `tag="..."` — the name to use when compiling this component as a custom element
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 5 == Module Context for Sharing Code
[[_module_context_for_sharing_code]]
== Module Context for Sharing Code

So in order, the example Components that we've looked at so far, we've been
running logic inside the `"<script>"` - block, which means that executes once
the Component *instantiate*, and that's useful for most of the things that we
need to do.

But occasionally, we need to have some logic that runs once for the entire
Module and is Shared between all Instances of the Component.

For that we have something called `"context=module"`.

//{{{ === Module Context / Sharing Code
[[_module_context_sharing_code]]
=== Module Context / Sharing Code

So in this app, we have a bunch of different `"audio"` - Elements. If I start
playing one of them, and then start playing another one. That will play each
other, and that's no goods.

What we want is for each `"play"` to cause all other `"audio"` - Elements to stop
playing.

We can do that by having some State that is shared between all of the
`"<AudioPlayer>"`.

// {{{ AudioPlayer.svelte
[source, html]
----
// AudioPlayer.svelte
<script context="module">
//      ~~~~~~~~~~~~~~~
    let current;
//  ~~~~~~~~~~~
</script>

<script>
    export let src;
    export let title;
    export let composer;
    export let performer;

    let audio;
    let paused = true;

    function stopOthers() {
        if (current && current !== audio) current.pause();      // <<<
        current = audio;                                        // <<<
    }
</script>

<article class:playing={!paused}>
    <h2>{title}</h2>
    <p><strong>{composer}</strong> / performed by {performer}</p>
    <audio
        bind:this={audio}
        bind:paused
        on:play={stopOthers}            // <<<
        controls
        {src}
    ></audio>
</article>

<style>
...
...
</style>
----
// }}}

We begin by creating a `"<script context="module">"`.

Then we're just have a single piece of State here called `"current"`.

Then, in this `"stopOthers()"` - function, which is called whenever the
`autorun` is played (`"on:play={stopOthers}"`)

We're just going to see this is the `current === audio`. If is NOT *pause* it;
and the value of `"current"`.

So now, if we play this piece of audio and then play the second one, the first
first piece of audio will *stop*.
// }}} ===

// {{{ === Module Context / Exports
[[module_context_exports]]
=== Module Context / Exports

Anything that gets exported from a `"context=module"` - script block, becomes
an "export" from the module itself.

So if we "export" a `"stopAll"` - function from `"AudioPlayer.svelte"` like
this

// {{{ AudioPlayer.svelte
[source, html]
----
// AudioPlayer
<script context="module">
    const elements = new Set();

    export function stopAll() {
        elements.forEach(elemnt => {
            element.pause()
        }
    }
</script>
...
...
----
// }}}

We can now import that function into `"App.svelte"` like this,

// {{{ App.svelte
[source, html]
----
//App.svelte
<script>
    import AudioPlayer, { stopAll } from './AudioPlayer.svelte';
//                      ~~~~~~~~~~~
</script>

<button on:click={stopAll}>
//      ~~~~~~~~~~~~~~~~~
    stop all audio
</button>
...
...
----
// }}}

Then we can use it inside this `'<button>"` - "Event - Handler",
`"on:click+{stopAll}"`, like so.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 6 == Debugging Code
[[_debugging_code]]
== Debugging Code

Occasionally, it can be quite useful to inspect a piece of data as its slowing
through your application.

// {{{ === Debugging / The @debug tag
[[_debugging_the_debug_tag]]
=== Debugging / The @debug tag

One approach we've already seen is using `"console.log()"`.

You can use `"console.log()"` inside your markup, as well inside your
`"<script>"` - tag.

But if you want to *pause execution*, as if you're using the "Debugger
- Statement" in JavaScript. You can use the `"{@debug ...}"` with
comma-separated list of all value that you want to inspect.

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let user = {
        firstname: 'Ada',
       lastname: 'Lovelace'
    };
</script>

<input bind:value={user.firstname}>
<input bind:value={user.lastname}>

//{(console.log(user), '')}
{@debug user}
// ~~~~~~~~~

<h1>Hello {user.firstname}!</h1>
----
// }}}

So, let's take this `"console.log()"`, and replace ith with `{"@debug user}"`.

Now, when this `"<input>"` changes it actually pauses execution of the entire
application, and it shows us where we are, and then you can inspect the values
as if you were sing the debugger - tag in your own JavaScript - Modules.

//{{{ image::./images/gif/chapter-5-7.gif
[#img-chapter]
[link=./images/gif/chapter-5-7.gif,window=_blank]
.Debugging Code
image::./images/gif/chapter-5-7.gif[align="center"]
//}}}

// }}} ===

That's it. We've competed the entire sculpture tutorial.

So we've covered a lot of ground. We've covered everything from the very
basics of what a Component looks like through to all of the advanced features
that you might need to lean on when you're building a real world application.

=== Neat Question

*"Q"*: So one question is, was `"<slot>"`. You have to bind a `"<slot>"` to in an
Element, like a physical, or like a `"<div>"` or whatever. If you didn't want
that markup, is there a way to that extra markup of the Container, is there any
way to lie to have that that Container markup?

*"A"*: It's something that's been talked about, but right now you need to have
a Container Element. You can add display Contents and it will be as if it
wasn't there.

*"Q"*: with Fade - Transition, what's the easiest way to accomplish that? Are
you going to get into that like Routing and stuff with Sapper?

*"A"*:  We are, but we're not going to cover Page - Transitions, and it's
basically like any other Transition, we don't have a really good set of
examples of "Fade - Transition" that something that we need to work on
honestly.

It would be a little bit out of scope for course though.

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 7 == Creating a Svelte App from Scratch
[[_creating_a_svelte_app_from_scratch]]
== Creating a Svelte App from Scratch
:fn-repl: link:https://svelte.dev/repl
:fn-svelte_app_scratch: link:../svelte_app_scratch

So, we've been through the entire tutorial, and now you understand how to build
Svelte - Application and what Svelte can do.

On the Svelte - Website, there is an interactive {fn-repl}[REPL,window=_blank]
that you can use to build application and Components of your own.

You can do quite a lot in here. But ultimately at some point, you're going to
want to take this Svelte experience out of the REPL onto your local machine.

This next section of the workshop is going to be about how to do exactly that.

I'm going to show you how to do this from scratch. Because with that way,
you'll get the best possible understanding of how Svelte actually fits into
your existing development workflow.

Then I'll show you an easier way to do just that.

So I'm going to go over to my terminal.

I'm going to create a new project. Inside my terminal I'm going to make
a new project called
"{fn-svelte_app_scratch}[svelte_app_scratch,window=_blank]".

Then make a `"src"` - directory inside of it.

// {{{
[source, bash]
----
mkdir svelte_app_scratch
cd svelte_app_scratch
mkdir src
----
//}}}

// {{{ === Installing Rollup
[[_installing_rollup]]
=== Installing Rollup
:fn-rollup: link:https://rollupjs.org
:fn-webpack: link:https://github.com/sveltejs/svelte-loader
:fn-parcel: link:https://parcel.js
:fn-snowpack: link:https://snowpack.dev
:fn-vite: link:https://vitejs.dev
:fn-localhost_5000: link:http://localhost:5000

For this project, we're going to be using {fn-rollup}[Rollup,window=_blank] to
do our *"module bundling"*.

"Rollup" is a piece of software that can take multiple JavaScript files, and
combine them into a single file that suitable for serving to users.

This is what we use in the default "project-template" right now.

We do also have an official {fn-webpack}[webpack] loader, and there's a bunch
of community plugins for using things like
{fn-parcel}[Parcel,window=_blank], {fn-snowpack}[Snowpack,window=_blank],
{fn-vite}[Vite,window=_blank] and so on;

So it's possible in future we'll be using something like Snowpack or Vite,
which are essentially beneficiaries of the fact that module exist natively in
browser now; And we don't necessarily need to be bundling everything all of the
time.

But for right now, we're going to have to *bundle our application* in order to
use it.

So we are going to install Rollup,

// {{{ pnpm i -D rollup
[source, bash]
----
pnpm i -D rollup
----
// }}}

So that's installed "Rollup" into our Project.

Then we create a `rollup.config.js` - file in our root directory of our project,
*NOT* inside our `"src"` - folder,

// {{{ rollup.config.js
[source, ts]
----
// rollup.config.js
export default {
    input: 'src/main.js',
    output: {
        file: 'public/build/bundle.js',
        format: 'esm',
        sourcemap: true
    }
};
----
// }}}

This config - file is going to expect to find a file called `"/src/*main.js*"`,
and it's going to generate a file called `"public/build/*bundle.js*"`. That is
going to be a file that gets loaded in the application.

Now we need to create that `src/main.js` entry point. We'll also create a test
module to import, so you can see what Rollup does:

// {{{ $ echo "import hello from "./hello.js";
[source, bash]
----
$ echo "import hello from "./hello.js";

hello();" > src/main.js

echo "export default () => {
    console.log("hello!");
}" > src/hello.js
----
// }}}

Above bash command, is just created some source files. We've got "main.js"

// {{{ main.js
[source, javascript]
----
// main.js
export hello from "./hello.js";
----
// }}}

Which import `"hello.js"`.

// {{{ hello.js
[source, javascript]
----
// hello.js
export default () => {
    console.log("hello!");
}
----
// }}}

We see `"hello.js"` just export a function that logs the world `"hello!"`.


Now, if we run Rollup with the config file...

// {{{ pnpx rollup -c
[source, bash]
----
$ pnpx rollup -c

src/main.js → public/build/bundle.js...
created public/build/bundle.js in 18ms
----
// }}}

We can see that it going take that `"input:"` - file (`"src/main.js"`), follows those inputs
and generate our `"public/build/bundle.js"`.

// {{{ bundle.js
[source, javascript]
----
// bundle.js
var hello = () => {
    console.log('hello!');
};

hello();
//# sourceMappingURL=bundle.js.map
----
// }}}

As you can see, it's literally just taking those two modules and stitch them
together

Now we just need to add a `public/index.html` file to actually load the bundle...

// {{{ index.html
[source, html]
----
<!-- index.html -->
<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset='utf-8'>
        <meta name='viewport' content='width=device-width,initial-scale=1'>

        <title>My app</title>

        <script type="module" src='/build/bundle.js'></script>
    </head>
    <body>
        Open the console!
    </body>
</html>
----
// }}}

Then to serve it on the service page, I'm going to install a dependencies
called `"serve"`.

// {{{ pnpm i -D serve
[source, bash]
----
pnpm i -D serve
pnpx serve public

   ┌───────────────────────────────────────────────────┐
   │                                                   │
   │   Serving!                                        │
   │                                                   │
   │   - Local:            http://localhost:5000       │
   │   - On Your Network:  http://192.168.0.109:5000   │
   │                                                   │
   │   Copied local address to clipboard!              │
   │                                                   │
   └───────────────────────────────────────────────────┘
----
// }}}

If you open the console, then we will see that it is indeed logging world `"hello!"`

//{{{ image::./images/chapter-5-3.png
[#img-chapter]
[link=./images/chapter-5-3.png,window=_blank]
.Installing Rollup
image::./images/chapter-5-3.png[align="center"]
//}}}

// }}} ===

// {{{ === Adding plugins
[[_adding_plugins]]
=== Adding plugins
:fn-rollup_plugin_svelte: link:https://www.npmjs.com/package/rollup-plugin-svelte
:fn-rollup_plugin_node_resolve: link:https://www.npmjs.com/package/@rollup/plugin-node-resolve
:fn-rollup_plugin_css_only: link:https://github.com/thgh/rollup-plugin-css-only
:fn-v7: link:https://github.com/sveltejs/rollup-plugin-svelte/blob/master/CHANGELOG.md#700
:fn-147: link:https://github.com/sveltejs/rollup-plugin-svelte/pull/147
:fn-extracting_css: link:https://github.com/sveltejs/rollup-plugin-svelte/blob/master/README.md#extracting-css

Okay. So that's all well and good.

Like you now understand what "Rollup" does, but we need to get Svelte involved.
Rollup itself doesn't understand what a Svelte - Component is or does. So we
need teach it. We need to add a Svelte - Plugin for Rollup.

We also need to add a *plugin* that will teach Rollup how to find things indie
your `"node_modules"` - folder.

So we're going to install two things here,

- `"{fn-rollup_plugin_svelte}[rollup-plugin-svelte,window=_blank]"`
- `"{fn-rollup_plugin_node_resolve}[@rollup/plugin-node-resolve,window=_blank]"`
— teaches Rollup how to find stuff in `node_modules`
- `"{fn-rollup_plugin_css_only}[rollup-plugin-css-only]"`
- `"svelte"` - a main bundle for Svelte engine

// {{{ npm i -D svelte rollup-plugin-svelte @rollup/plugin-node-resolve
[source, bash]
----
$ pnpm i -D svelte rollup-plugin-svelte @rollup/plugin-node-resolve  rollup-plugin-css-only

devDependencies:
+ @rollup/plugin-node-resolve
+ rollup-plugin-css-only 3.1.0
+ rollup-plugin-svelte 7.1.0
+ svelte 3.38.2
----
// }}}

Then add them to our `"rollup.config.js"` :

// {{{ rollup.config.js
[source, diff]
----
// rollup.config.js
+ import resolve from "@rollup/plugin-node-resolve";
+ import svelte from "rollup-plugin-svelte";
+ import css from "rollup-plugin-css-only";

export default {
    input: "src/main.js",
        output: {
        file: "public/build/bundle.js",
        format: "esm",
        sourcemap: true
    },
+   plugins: [
+       resolve(),
+       svelte(),
+       // we'll extract any component CSS out into a separate file - better for performance
+       css({ output: 'bundle.css' }),
+   ]
};
----
// }}}

[NOTE]
Usage: `"emitCss": false` for {fn-extracting_css}[extracting-css,window=_blank]

[NOTE]
Offload CSS handling to Rollup — you will now need an external plugin like
`"rollup-plugin-css-only"` to extract your styles to `".css"` - files as
demonstrated in the template {fn-147}[#147]

So now we have done that. Now that we've added those plugins, we can add
a Svelte -Component. I'm going create `"src/App.svlete"`,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    export let name;
</script>

<h1>Hello {name}!</h1>

<style>
    h1 {
        font-family: 'Comic Sans MS';
    }
</style>
----
// }}}

Then we want to import that Model or Component into our `"main.js"`, and
instantiate that component inside there.

So I'm going to replace the code with this:

// {{{ main.js
[source, javascript]
----
// main.js
import App from './App.svelte';

new App({
    target: document.body,
    props: {
        name: 'world'
    }
});
----
// }}}

This is a client-side Svelte - Component API, at is just regular JavaScript
- Class that you can instatntiate with the `"new"` - keyword.

It takes a bunch of options,

- "`target:"` - is the only options that is *required*. The target in this case
  is going to be the `"document.body"`.

We can also pass a bunch of "Props", which if the app exposes any "Props".
Which in this case, does it exports this `"name"` from `"App.svelte"`, and
we'll get initialized to these value `name: 'world'`.

The last thing we need to do is add a *link* to the new `bundle.css`, that is
being generated here from this part of plugin.

We add that into our `"public/index.html"` - file

// {{{ index.html
[source, html]
----
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width,initial-scale=1'>

    <title>My app</title>

    <link rel="stylesheet" href="/build/bundle.css">
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <script type="module" src='/build/bundle.js'></script>
</head>
<body>
</body>
</html>
----
// }}}

Now if you've set everything up correctly, when we run Rollup, it's going to
find that Svelte - Module and turn it into JavaScript.

Try running,

// {{{ pnpx rollup -c
----
$ pnpx rollup -c
created public/build/bundle.js in 397ms
----
// }}}

So, now when we do `"npx serve public"`,

// {{{ pnpx serve public
[source, bash]
----
pnpx serve public

   ┌───────────────────────────────────────────────────┐
   │                                                   │
   │   Serving!                                        │
   │                                                   │
   │   - Local:            http://localhost:5000       │
   │   - On Your Network:  http://192.168.0.109:5000   │
   │                                                   │
   │   Copied local address to clipboard!              │
   │                                                   │
   └───────────────────────────────────────────────────┘
----
// }}}

It's going to serve Svelte project on `"http://localhost:5000"`.

//{{{ image::./images/chapter-5-4.png
[#img-chapter]
[link=./images/chapter-5-4.png,window=_blank]
.Adding Plugin
image::./images/chapter-5-4.png[align="center"]
//}}}

As you can see that indeed it is creating our application and rendering it to
`"document.body"`.
// }}} ===

// {{{ === The easiest way
[[_the_easiest_way]]
=== The easiest way
:fn-svelte_template: link:https://github.com/sveltejs/template
:fn-degit: link:https://github.com/Rich-Harris/degit

All right, so that's basically all there is to it. The official template which
you can  see on {fn-svelte_template}[sveltejs-template,window=_blank]  it is
slightly fancier - it has `'livereload"` and it has `"built-in development
server"`, and various other things that are quite useful.

The easiest way is to use {fn-degit}[degit], a git-based scaffolding tools,

// {{{ mkdir my-project
[source, bash]
----
mkdir my-project
cd my-project
npx degit sveltejs/template
----
// }}}

//}}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}
