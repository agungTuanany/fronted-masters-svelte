//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 4
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon May  3 06:28:45 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_4_svelte_stores_animation]]
== Chapter-4 Svelte Stores Animation

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_stores_and_derived_state[Stores & Derived State]
|====
//}}}

// {{{ 1 == Stores & Derived State
[[_stores_and_derived_state]]
== Stores & Derived State

//{{{ image::./images/chapter-4-1.png
[#img-chapter]
[link=./images/chapter-4-1.png,window=_blank]
.Stores & Derived State -1
image::./images/chapter-4-1.png[align="center"]
//}}}

So, so far all of the state that we've been dealing with has been State that
belongs to specific Components, and if we need to pass it around between
Components, then we use it. Use "Props" and we use Bindings and use Events.

But that's not always what you want. Sometimes you have State that doesn't
really belong to a specific Component. Sometimes its Global - State, like an
Object representing the "current user" and things like that, and we need to
have a way of *representing those outside the Component*.

For that in Svelte we have the concepts of "Stores". The Stores is pretty
simple. It's just an Object with a Subscribe - method and it's not even Svelte
specific. It's something you could use in any application as we'll see. But it
does have a specific importance to Svelte.

// {{{ === Stores / Writable Stores
[[_stores_writable_stores]]
=== Stores / Writable Stores

So here's our file `"stores.js"`.

// {{{ stores.js
[source, javascript]
----
// stores.js
import { writable } from 'svelte/store';

export const count = writable(0);
----
// }}}

We're importing `"writable"` from `"svelte/store"`. Not the main Svelte
package, but the `"svelte/store"` - package which is one of the number of
packages that live inside the Svelte - namespace.

Then we're initializing it with `"0"` (`"writable(0)"`), and that become our
`"count"` - Store.

Then we're importing that `"count"` - Store into each these Components
`"App.svelte"`, `"Decrementer.svelte"`, `"Incrementer.svelte"`, and
`"Resetter.svelte"`.

As the name suggests, the job of these Components, is to increment, decrement
or reset the "value" of that Store.

So, inside the `"Incrementer"` - Component, let's change the value of the
Store, by calling `"count.update()"`.

Then I'm going to pass in a Handler that *takes* the current value and *return*
the new value.

That the job of the `"update()"` - method.

// {{{ Incrementer.svelte
[source, html]
----
// Incrementer.svelte
<script>
    import { count } from './stores.js';

        function increment() {
            // TODO increment the count
            count.update(n => n + 1);
        //  ~~~~~~~~~~~~~~~~~~~~~~~
    }
</script>

<button on:click={increment}>
	+
</button>
----
// }}}

Now when I click the plus `" + "` - button, the value of the `"count"`
increases.

The way we're getting that value into `"App.svelte"` is, by *subscribing* to
it.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

    let count_value;
//  ~~~~~~~~~~~~~~

    const unsubscribe = count.subscribe(value => {
        count_value = value;
    });
</script>

<h1>The count is {count_value}</h1>
//               ~~~~~~~~~~~~ <<< reference inside the markup

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

So, as you can see, in `"App.svelte"` - code above, we are declaring
`"count_value"`

Then we calling `"count.subscribe()"`, and giving it a callback which takes the
"value", (the current value) which is the callback, that runs every time the
"value" of `"count"` changes as well as when you first subscribe to it, and
then it's passing that value back, up to `"count_value"` which us then
*reference* inside the markup (`"<h1>The count is {count_value}</h1>"`).

So that how clicking the `" + "` - button affect the content of the `"<h1>"`
- Elements.

If you thinking that's quite a lot of boilerplate, you're not wrong. I'm goint
to get to that.

I'm going to wire up the `"Decrementer"` - Component first. Same thing,
`"count.update(n => n - 1)"`

// {{{ Decrementer.svelte
[source, html]
----
// Decrementer.svelte
<script>
    import { count } from './stores.js';

        function decrement() {
            // TODO decrement the count
            count.update(n => n - 1);
        //                    ~~~~~
    }
</script>

<button on:click={increment}>
	-
</button>
----
// }}}

Now we can press the `" - "` - button.

Finally in the `"Resetter"` - Component, we don't care about the "current
- value". We're always just going to set it back to zero, so `"count.set(0)"`.

// {{{ Resetter.svelte
[source, html]
----
// Resetter.svelte
<script>
    import { count } from './stores.js';

        function reset() {
            // TODO reset the count
            count.set(0);
        //        ~~~~~
    }
</script>

<button on:click={increment}>
	reset
</button>
----
// }}}
// }}} ===

// {{{ === Stores / Auto-subscriptions
[[_stores_auto_subscriptions]]
=== Stores / Auto-subscriptions
:fn-auto_subscriptions: link:https://svelte.dev/tutorial/auto-subscriptions

Okay, so that works. But there's actually "subtle - *bug*" in this application,
and the "bug" is, that we're generating this `"unsubscribe"` - function,

// {{{ App.svelte
[source, html]
----
<script>
    ...
    ...

    const unsubscribe = count.subscribe(value => {
//        ~~~~~~~~~~
        ...
        ...
    })
</script>
----
// }}}

Which is the result of calling `"count.subscribe()"`, but it's never gets
called anywhere.

Now, one way that we could fix that is, to use the `onDestroy"` - Lifecycle
function.

Then inside the `"<script>"` - block we call `"onDestroy()"` we call
`"unsubscribe"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onDestroy } from 'svelte';
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

    let count_value;

    const unsubscribe = count.subscribe(value => {
        count_value = value;
    });

    onDestroy(unsubscribe);
//  ~~~~~~~~~~~~~~~~~~~~~~
</script>

<h1>The count is {count_value}</h1>
//               ~~~~~~~~~~~~ <<< reference inside the markup

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

With that way, we're not going to have any *"memory - leaks"*. If there are
lots of these Components and they've been *Created* and *Destroyed*. All of our
"subscribers" are going to be turn down.

But look at all this above code, it's quite a lot for what we're trying to do.

So Svelte has a trick up it's sleeve. Because we have this *fixed* "Store
- Contract" by which I mean the `"subscribe()"` - method, we can reference the
Store - value by *prefixing* the "Store - *name*" with the dollar - symbol
`"$"`.

We can get rid of the `"onDestroy"`, get rid of the `"count_value"`, get rid of
the `"count.subscribe()"`. Just taking that Store and prefix it with the `"$"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

</script>

<h1>The count is {$count}</h1>
//               ~~~~~~~

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

It works exactly the same way.

NOTE: Auto-subscription only works with store variables that are declared (or
imported) at the top-level scope of a Component.

NOTE: Any name beginning with `"$"` is assumed to refer to a store value. It's
effectively a reserved character — Svelte will prevent you from declaring your
own variables with a `"$"` prefix.

Under the hood Svelte is creating that *"subscriber"* the same way that you
would have done manually except that, it's always going to clean it up when
it's no longer valid.

There are some caveats about how this syntax sugar works, and they're detailed
on {fn-auto_subscriptions}[this section,window=_blank].

// }}} ===

// {{{ === Stores / Readable Stores
[[_stores_readable_stores]]
=== Stores / Readable Stores

So that was the "Writable - Store". There are some Store that you don't need to
be able to *set the value of*, or it doesn't make sense to set the value of
them.

You might have a Store that representing the "mouse - position", or Store
representing the uses "geolocation", and those are *"read-only"* essentially.

So this time in our `"store.js"` - file. we're importing `"readable"` instead
of `"writable"`.

// {{{ store.js
[source, js]
----
// store.js
import { readable } from 'svelte/store';
//       ~~~~~~~~

export const time = readable(null, function start(set) {
	// implementation goes here

	return function stop() {};
});
----
// }}}

Then we creating the Store called `"time"`, has no initial value currently.

We haven' implemented the function that gets called when we first subscribe to
the Store. So let's do that now.

// {{{ store.js
[source, js]
----
// store.js
import { readable } from 'svelte/store';
//       ~~~~~~~~

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() => {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
----
// }}}

First argument is the initial - value `"new Date()"`, and when we first
subscribe to the Store, which is already happening, because we're referencing
it inside our `"App.svelte"` with `"$time"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...
</script>

<h1>The time is {formatter.format($time)}</h1>
//                                ~~~~~
----
// }}}

We can create an `"interval"` (`"setInterval()"`). It's going to run once every
second. And it's going to set the current value to a `"new Date()"` - Object.

Then, once everything is *unsubscribe* to this Store, we can clean that up.

So inside the `"stop()"`, we're going to return a function that calls
`"clearInterval()"`. then we pass in `"interval"`.

So now we have this "time" - Store, that is just going to keep taking up as
long as anyone is interested in it, and that can be shared between as many
Components as you want.
// }}} ===

// {{{ === Stores / Derived Stores
[[_stores_derived_stores]]
=== Stores / Derived Stores
:fn-store_derived: link:https://svelte.dev/docs#derived

Finally we have Derived Stores, which are Stores whose value is derived form
other Stores with a `"readable"` or `"writable"` or even other derive Stores.

So taking the previous example, we want to have a Store that represents the
number of seconds that the page has been open.

// {{{ store.js
[source, javascript]
----
// store.js
import { readable, derived } from 'svelte/store';
//                 ~~~~~~

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() => {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };

});

const start = new Date();

export const elapsed = derived(
    time,
    $time => Math.round(($time - start) / 1000)
);
----
// }}}

We already have our "time" - Store setup.

We just need to implement the "elapsed" - Store. So we're importing `"derived"`
alongside `"readable"`.

The *first* argument to this `"derived()"` - function is a Store, and the
*second* argument is a callback that takes the current Stores - value and turn
it into something else.

So we are going to take `"Math.round()"`, and then we'll take the current
- time subtract that from the `"start"` - time when this module was first
evaluated. Then we'll divide it by `"1000"`.

Now you can see the Store representing the number of seconds elapsed since the
page is opened.

It's update in sync with the Store representing the current time.

You can derive Store from multiple input Stores, and you can explicitly set
a value instead of just returning it like we're doing above. That a little bit
more involved.

So if that's something that you need to do, then consult the API
- documentation which you can find up {fn-store_derived}[here,window=_blank]
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Custom Store & Store Bindings
[[_custom_store_store_bindings]]
== Custom Store & Store Bindings

We can also create "Custom" - Store, because remember the Store contract is
very simple. You just need a "subscribe" - method and anything beyond that is
up to you.

// {{{ === Stores / Custom Stores
[[_stores_custom_stores]]
===  Stores / Custom Stores

So if we take our "count" - Store from the first Store example. Then what we
can do is add `"increment()"`, `"decrement()"` and `"reset()"` - methods on
the Store itself.


In our `"store.js"` - file, we have a new function to create a special "count"
- Store, and inside that we beginning by creating `"writable"` - Store just
like we had before. When we were doing all this ourselves and we're
destructing it to get references to (`"{ subscribe, set, update }"`), which are
the three methods that exist on a `"writable"` - Store.

And what we're going to turn that into is a Store where you can only change the
value in specific ways.

So whereas before, you could have a `"count. ..."`, and then you can do
`"count.set(potato)"` or something irrelevant like that.

This time, the Store is going to expose its own API.

Exactly as we had when we had an increment to Component.

So, `"increment()"` - function is going to look like this,

// {{{ store.js
[source, javascript]
----
// store.js
import { writable } from 'svelte/store';

function createCount() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () => update(n => n + 1),    // <<<
        decrement: () => update(n => n - 1),    // <<<
        reset: () => set(0)                     // <<<
    };
}

export const count = createCount();
----
// }}}

Then same with `"decrement()"`, also with `"reset()"` - methods.

Then inside `"App.svelte"`we already referencing those functions.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
</script>

<h1>The count is {$count}</h1>

<button on:click={count.increment}>+</button>
<button on:click={count.decrement}>-</button>
<button on:click={count.reset}>reset</button>
----
// }}}

Now, if we try. All works exactly as you would expect.
// }}} ===

// {{{ === Stores / Store Bindings
[[stores_store_bindings]]
=== Stores / Store Bindings

Just as you can bind to Component - State. You can also Bind to Store - values.

// {{{ store.js
[source, javascript]
----
import { writable, derived } from 'svelte/store';

export const name = writable('world');

export const greeting = derived(
    name,
    $name => `Hello ${$name}!`
);
----
// }}}

So here we have a Store representing a String, which is the name of a "user",
and then we have another Store that is derived from that Store value.

So what we want to do is, wire up this `"<input>"` to the value of the Main
- Store. So that the greeting is automatically derived whenever that changes.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>
//     ~~~~~~~~~~~
----
// }}}

So the `"<h1>"` is displaying the "derived value".

The `"<input>"` is displaying the "input value">

I'm going to change that into Binding with `"bind:value={}"`.

If we try to input some words, it works exactly as a regular input words.

Now we can also change the value of Store inside Components. Either inside the
`"<script>"` - block, or inside the markup.

So we can add a button here,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>

<button on:click="{() => $name += '!'}">
    Add exclamation mark!
</button>
----
// }}}

We give it an "Event - Handler" for every time we click it.

We're going to change the "value" of main directly.

Then now we finally press that the Store - value is updated.

This is the same as doing,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>

<button on:click="{() => name.set($name + '!')}">
    Add exclamation mark!
</button>
----
// }}}

Above code it's just a little bit neater.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc set tw=79
// ▶
