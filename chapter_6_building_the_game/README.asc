//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 6
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sat May  8 09:11:13 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_6_building_a_game]]
= Chapter-6 Building A Game

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_preparation[Preparation]
| 2.    | xref:_creating_the_game_Screen[Creating The Game Screen]
| 3.    | xref:_game_layout_button[Game Layout & Button]
| 4.    | xref:_wiring_up_interactivity[Wiring Up Interactivity]
| 5.    | xref:_game_activity_display[Game Activity Display]
| 6.    | xref:_game_completion_state[Game Completion State]
|====
//}}}

// {{{ 1 == Preparation
[[_preparation]]
== Preparation
:fn-cameo_com: link:http://cameo.com/
:fn-cameoparison: link:https://cameoparison.netlify.app/
:fn-cameo_explorer: link:https://cameo-explorer.netlify.app/celebs

//{{{ image::./images/chapter-6-1.png
[#img-chapter]
[link=./images/chapter-6-1.png,window=_blank]
.Building a Game
image::./images/chapter-6-1.png[align="center"]
//}}}

Time to move onto the fun stuff. We're going to make a game using data from
{fn-cameo_com}[cameo.com,window=_blank], an amazing website that lets you pay
celebrities to record 30 second personalised videos. You can get the "Insane
Clown Posse" to roast your friends or wish your spouse a happy anniversary.

The game is called {fn-cameoparison}[CameoParison,window=_blank], and the goal
is to guess which celebrities are expensive, and which ones are cheap. Since
there's no official API, we'll grab data from
{fn-cameo_explorer}[cameo-explorer.netlify.app,window=_blank], which contains
a scraped snapshot of some of the top celebs.

We'll start by cloning the starter repo:

// {{{ $ git clone git@github.com:Rich-Harris/cameoparison-starter.git
[source, bash]
----
$ git clone git@github.com:Rich-Harris/cameoparison-starter.git
----
// }}}

This is almost identical to the default project template, with the addition of
a couple of image files and some extra `"src"` modules to save time later.

It also has several *branches* that you can check out if you get stuck following
the course and need to get back on track:

- checkpoint-1
- checkpoint-2
- checkpoint-3
- complete

As you follow along, make your changes in the master branch.
// }}}

// {{{ 2  == Creating The Game Screen
[[_creating_the_game_Screen]]
== Creating The Game Screen

All right, so the first order of business is going to be create a "Game
- Screen" - Component, similar to "Welcome - Screen" - Component.

We create a new file Component named `"Game.svelte"` in `"/src/screens/"`.

Then we'll import that inside `"App.svelte"`, the same way that we imported our
"Welcome" - Component.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onMount } from "svelte";

    import Welcome from "./screens/Welcome.svelte";
    import Game from "./screens/Game.svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    import { select } from "./select";

    ....
    ....
</script>
----
// }}}

Then inside the `<main>` - placeholder, we're going to instantiate the "Game"
- Component,

// {{{ App.svelte
[source, html]
----
// App.svelte
</script>
    ...
    ...
<script>

<main>
    {#if state === "welcome"}
        <Welcome on:select={start} />
    {:else}
        <Game {selection} />
//      ~~~~~~~~~~~~~~~~~~~~
    {/if}
</main>
----
// }}}

We're going to pass through the `"selection"`, because that's what the game is
going to use, to actually render the quiz.

So, we open our new Component we make which is `"Game.svelte"`,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;
    console.log(selection);
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    <p>game will go here</p>
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }
</style>
----
// }}}

The first thing we need to do in our "Game" - Component is to make that
`"selection"` - "Prop" available, by doing `"export let selection"`.

I'm going to verify that is getting passed through correctly by logging it
`"console.log(selection)"`.

Then, once again we're just going to rip off some mock-up the one that we made
earlier.

Then the rest is just going to be placeholder stuff. We're going to make an
element that contain the game, `class="game-container"`.

Finally we're going to create that little row of result at the bottom,
`"class="results"`.

Right now everything is getting squeezed into the middle of the screen.

//{{{ image::./images/chapter-6-2.png
[#img-chapter]
[link=./images/chapter-6-2.png,window=_blank]
.Creating a Game Screen -1
image::./images/chapter-6-2.png[align="center"]
//}}}

We want the "Game" - Container to fill as much spaces possible, and then for
the `"<header>"` and the `"results"` to just occupy the "top" and "bottom".

We add the CSS - Style to `"game-container"` - Class to have a `"flex:"` with
value of `"1"`.

Than will make it stretch to occupy as much space as it can.

//{{{ image::./images/chapter-6-3.png
[#img-chapter]
[link=./images/chapter-6-3.png,window=_blank]
.Creating a Game Screen -2
image::./images/chapter-6-3.png[align="center"]
//}}}

So the "Game" - Container as you can see, is occupying most of the screen.

Now, if you look at the `"selection"` - Object that is being passed in as
a "Prop", we can see the *Data -Structure* that we've got to work with.

//{{{ image::./images/chapter-6-4.png
[#img-chapter]
[link=./images/chapter-6-4.png,window=_blank]
.Creating a Game Screen -3
image::./images/chapter-6-4.png[align="center"]
//}}}

As we can see, mos of the stuff that we need is there. We've got `"names"`,
we've got `"prices"`, we've got all of that.

*BUT* we do NOT have the `"image"` that belongs to each of these celebrities.

For that, we're going to need to go back to the API, and we're going to need to
load some more data for each of these.

That essentially means we're going to need to create a bunch of "Promises" that
presenting the result of loading that data.

Let's add some code into "Game" -Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;

    const load_details = async (celeb) => {
        const res = await fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`);
        return await res.json();
    };
    const promises = selection.map(round => Promise.all([
        load_details(round.a),
        load_details(round.b)
    ]));
	let i = 0;
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                {a.name}
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                {b.name}
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }

    .error {
        color: red;
    }
</style>
----
// }}}

So let's do `"const promises = selection.map()"`, and then for each of those
Objects that we just looked at with `"Promise.all()"`.

We're going to load some details "a" - property (`load_details(round.a)`),
and "b" - property (`load_details(round,b)`)

So right now, we just need to implement `"load_details"`.

We just going to grab the URL again
`https://cameo-explorer.netlify.app/celebs/`

//{{{ image::./images/chapter-6-5.pn
[#img-chapter]
[link=./images/chapter-6-5.png,window=_blank]
.Creating a Game Screen -4
image::./images/chapter-6-5.png[align="center"]
//}}}

So each of these `"celebs"` has "JSON" that we can inspect. Which contains all
of the same information as before plus `*"description"*` and plus the `*"image"*`.

We grab that - URL and then just replace the "celebs - name" with the *ID* of the
*Celeb* that we care about,
(`fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`)`)

Then, we just going to return the "JSON" for that response, `return await
res.json()`.

So, that's going to give this bunch of different Promises that represent the
full detail of the celebrities whose have faces (images) we are going to
include in our game.

Now dealing with *"asynchronous" - Object* in *templating languages* has been
a little bit awkward. But Svelte has a *first-class* way of showing "Promises"
in your Component that we looked at earlier, and it's called the *"await"*
- block.

We're going to use one of those here, we're going to do `"{#await something}"`. Then
we're going to have an Array of "a" and "b", because that's what's getting in
return from (`" const promises"`) an Array.

By the way, I'm actually using a shorthand here.

// {{{  {#await something}
[source, html]
----
// Game.svelte
{#await something}
    <p>pending block</p>

{:then value}
    <p>{value}</p>

{/await}
----
// }}}

Before we had a `"await something"`, and then we would have a `"pending
block"`, then you would have `{:then}` - clause.

In cases like above, where we actually *don't want to show anything*, while
*`"pending"` is still the case*, we can shortcut this with `{# await something
then [value]}`, and also we can use `destructuring`.

Then inside `await` - clause, we're going to create the `"game"` - Element it
itself by creating a Class, (`<div class= "game">`)

We're going to have a "card" for the two celebrities images,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>
        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

Okay, on the final version of the game, you can see that as well as having
celebrity `"a"`, and celebrity `"b"`, we have a *button* in the middle that
you're supposed to press, when you're think that they're charging exactly the
same price.

//{{{ image::./images/chapter-6-6.png
[#img-chapter]
[link=./images/chapter-6-6.png,window=_blank]
.Creating a Game Screen -5
image::./images/chapter-6-6.png[align="center"]
//}}}

So we are going to add that button to our markup as well. We just put a little
`<div>` in there, and inside we're going to have a `"<button>"` - Element wit
a Class `"same"`, amd then we put the word `'same price"`, to be like


// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

In some cases like as we've seen, it's possible that there would be an error.
So we use the `"{:catch}"` - clause, we put an error message, then we just
print a message `Failed to load data`, in `"<p>"` - Element, to be like so,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

Then we just add some CSS - style for class - `".error{ color: red }"`

Okay, so what we'll do now is, to figure out what `"something"` should be.

So we have an Array of `"const promises"`, and we're going to step through them
one at the time, and the easiest way to do that would be to just have a value
that represent the *"current - index"* into those `"promises"`

So let's create a new value, `"let i = 0"`, and I'm just take that ip as we go
through the `"rounds"`, and we replace `"something"` with `"promises[i]"`, like
so,

// {{{ {#await promises[i] then [a, b]}
[source, html]
----
// Game.svelte
{#await promises[i] then [a, b]}
//      ~~~~~~~~~~~
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

If we go over to our application, we can see that it is indeed picking out two
- celebrities, and rendering some game UI for those.

//{{{ image::./images/chapter-6-7.png
[#img-chapter]
[link=./images/chapter-6-7.png,window=_blank]
.Creating a Game Screen -6
image::./images/chapter-6-7.png[align="center"]
//}}}

// }}}

// {{{ 3 == Game Layout & Button
[[_game_layout_button]]
== Game Layout & Button

Okay, so it's time to start building the UI a little bit further. We're going
to create some "Cards" for the celebrities, and then use those in the "Game"
- Component.

That means we're going to create a new - Component. That's not a screen, but is
a separate Component. So I'm going to create a new directory inside our
`"source/`, called `"src/components"`. I'm going to create a Component called
`"Card.svelte"`.

Then inside the `"Game.svelte"` - Component, I'm going to import that new
component.

// {{{ Game.svelte
[source, html]
----
<script>
    import Game from "../components/Game.svelte";
    ...
    ...
</script>
...
...

<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card celeb="[a}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                <Card celeb="[b}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>
----
// }}}

[NOTE]
There's really, no, sort of conventions about how you organize your Components.
I put this i a separate Components - Folder, but you could also put in next to
the `"Game.svelte"` - Component. It's really up to your personal preference,.


Then we're just going to replace these `{a.name}` with `"<Card celeb={a} /">`, and
then same down here `"<Card celeb={b} />"`, as like so,

So, let's flash out the layout a little bit of our main "Game" - Component. We
give more CSS - Style.

// {{{ Game.svelte
[source, diff]
----
// Game.svelte
<script>
...
</script>
...
...
<div class="game-container">
...
...
</div>

<style>
     .game-container {
         flex: 1;
     }

+    .game {
+        display: grid;
+        grid-template-rows: 1fr 2em 1fr;
+        grid-gap: 0.5em;
+        width: 100%;
+        height: 100%;
+        max-width: min(100%, 40vh);
+        margin: 0 auto;
+    }
+    .game > div {
+        display: flex;
+        align-items: center;
+    }
+    .same {
+        width: 100%;
+        align-items: center;
+        margin: 0;
+    }
+    .game .card-container button {
+        width: 100%;
+        height: 100%;
+        padding: 0;
+        margin: 0;
+    }
+
     .error {
         color: red;
     }
+
+    @media (min-width: 640px) {
+        .game {
+            max-width: 100%;
+            grid-template-rows: none;
+            grid-template-columns: 1fr 8em 1fr;
+            /* work around apparent safari flex bug */
+            max-height: calc(100vh - 6em);
+        }
+        .same {
+            height: 8em;
+        }
+    }
</style>
----
// }}}

Next, let's go over to the "Card" - Box whole Component and start implementing
that,

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    export let celeb;

</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});">
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
        </div>
    </button>
</div>

<style>
    .card-outer {
        width: 100%;
        height: 100%;
    }

    .card-inner {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: 50% 50% no-repeat;
        background-position: 50% 0;
        background-size: cover;
        overflow: hidden;
        padding: 0;
        text-align: left;
    }

    .details {
        position: absolute;
        width: 100%;
        bottom: 0;
        padding: 1em 0.5em 0.5em 0.5em;
        background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.6) 35%, rgba(0, 0, 0, 0.9));
        color: white;
    }

    h2 {
        margin: 0 0 0.2em 0;
    }

    .type {
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    @media (min-width: 640px) {
        .card-outer {
            height: 0;
            padding: 0 0 100% 0;
        }
    }
</style>
----
// }}}

We're going to create an element to contain everything call that
`"card-outer"`, and inside there, we're going to create a "_button_"

The reason I'm using the button is, because these are *interactive* Elements.
So things that the user is supposed to click-on, and the nice thing using
buttons is, we get a lot of accessibility properties for free.

So right now, in {fn-cameoparison}[deployed site,window=_blank], if someone who
used the keyboard instead the mouse for whatever accessibility reason, I might
have, I can press `tab` - key, and it will take me between the Elements on the
page.

//{{{ image::./images/gif/chapter-6-1.gif
[#img-chapter]
[link=./images/gif/chapter-6-1.gif,window=_blank]
.Creating a Game Screen -8
image::./images/gif/chapter-6-1.gif[align="center"]
//}}}

So, we're going to use button in all three cases where both the celebrities and
the `"same price"` thing in as the middle button.

We create button - with Class name `"card-inner"`.

The button is going to have the background image that corresponds to the
"celebrity image". We use "inline style" `style="background-image:
url({celeb.image});"`.

Then inside there, we're going to have these `"details"` - Elements.

We left the static markup that specific to celebrity, with the properties of
our celebrity Object `"href="https://cameo.com/{celeb.id}"` and `{celeb.name}`,
and `{celeb.type}`.

Then we add some style. You can read above, because our course specific to
Svelte.
//}}}

// {{{ 4 == Wiring Up Interactivity
[[_wiring_up_interactivity]]
== Wiring Up Interactivity

So now we've created the buttons, we've got the buttons inside this "Card"
- Component for the celebrities, and we've got another button for the "same
price"`.

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    import { createEventDispatcher } from "svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    export let celeb;
    const dispatch = createEventDispatcher();
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});" on:click={() => dispatch("select")}>
//                                                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
        </div>
    </button>
</div>

<style>
...
...
</style>
----
// }}}

Now we need to wire those up, which means importing
`"createEventDispatcher()"`.

We create a `"const dispatch"` function.

Once the `"<button>"` - Element get "clicked", we can do `"on:click={() =>
dispatch("select")}"`

Then we get back into our "Game" - Component, we can add a `select` - Handler,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div>
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card
                    celeb="[a}"
                    on:select ={() => {...}}
//                  ~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>

            <div>
                <button class="same" on:click ={() => {...}}> same price </button>
//                                   ~~~~~~~~~~~~~~~~~~~
            </div>

            <div class="card-container">
                <Card
                    celeb="[b}"
                    on:select ={() => {...}}
//                  ~~~~~~~~~~~~~~~~~~~~~~
            />
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<style>
...
...
</style>
----
// }}}

Now, we don't yet know what's going to happen here. So I'm just going to leave
blank like so `"on:select = () => {...}"`.

We going to add a similar thing to the `"<button>"` - Element, except instead
of `"on:select"`, it's going to be an `"on:click"` - Handler.

Then we need to create a function that is going to get called. When each of
these things happens.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    const submit = (a, b, sign) =>{                                                 // <<<
        const result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";   // <<<

        console.log(result);                                                        // <<<

        if (i < selection.length - 1) {                                             // <<<
            i += 1;                                                                 // <<<
        }
        else {                                                                      // <<<
            // TODO end the game                                                    // <<<
        }                                                                           // <<<
    };
</script>

<div>
...
...
</div>

<style>
...
...
</style>
----
// }}}

We called the function name with `"submit"`, because the user is submitting the
response.

What `submit"` is going to need is, going to need the celebrity on the left
(`"a"`), and the celebrity on the right `(`"b"`), and some sort of
representation of the users guess (`"<button>"`).

The way we can do this is, I'm going to pass in the celebrity - Objects as the
*first two arguments*, and then the *third argument* is going to be a `"sign"`,
which is going to be either `"-1"`, `"0"` or `"1"`.

Then, we will see if the `Math.sign()`, which is a function that's *map* out
`"sign"`,

- If you give it a *"positive number"* it will return `"1"`.
- If you give it a *"negative number"* it will return `"-1"`.
- If you give it *"zero"* it will return `"0"`.

So, that's very useful for this particular use-case.

So, we put `"Math.sigh(a.price - b.price)"`, that value is going to be `"1"`.
If `"a"` is the more expensive celebrity. So if that matches the `"sign"` that
was passed in, then the result is `"right"`, otherwise it's `"wrong"`.

Then we can `console.log()` that `"result"`.

Once that's happen, we can increment the index of the current round.

If `"i"` is less then the number of rounds in the game minus `1`,
(`"selection.length - 1"`), then increment it `i += 1`.

Otherwise, it's going to end the game, but we leave that as `"TODO"` for now.

So, now we just need to call this `"submit"` - function from each of those
Event - Handlers.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div>
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card
                    celeb="[a}"
                    on:select ={() => submit(a, b, 1}
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>

            <div>
                <button class="same" on:click ={() => submit(a, b, 0)}> same price </button>
//                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            </div>

            <div class="card-container">
                <Card
                    celeb="[b}"
                    on:select ={() => submit(a, b, -1}
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<style>
...
...
</style>
----
// }}}

Each of those Event - Handlers we put Element directive, like so:

- `"on:select={() => submit(a, b, 1)"`. If we click on card where celebrity
  equal `"a"` then we're guessing that `"a"` is the more expensive celebrity,
  so the `"sign"` is going to be `"1"`, because it's `"a.price - b.price"`, and
  then it'll be the reverse for the other celebrities.

- `"on:select={() => submit(a, b, -1)"`, if we click on card where celebrity
  equal `"b"`, is going to be `"-1"`.

- `"on:select={() => submit(a, b, 0)"`, finally for the guess where it's the
  `"same price"` , is going to be `"0"`.

Next we need to display the `"result"` somehow. But we've got everything pretty
much wired up the way we need it to.

So let's move on to "Game Activity Display".
// }}}

// {{{ 5 == Game Activity Display
[[_game_activity_display]] == Game Activity Display

So in here `"Game"` - Component we're creating this `"result"` - variable that's constant, and logging it. But we can
use that in the UI.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
    const submit = (a, b, sign) => {
        const result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        console.log({ result });    // <<<

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        }
    };
</script>
...
...
----
// }}}

We can say that, once there is a `"result"`, we shown either the "big green check" or the "big red cross".

Before we can do that we're going to need to take it out of that function, let's call it `"last_result"`, then change
`"const result"` into `"last_result"`.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>

    let last_result;
//  ~~~~~~~~~~~~~~~

    const submit = (a, b, sign) => {
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";
//            ~~~~~~~~~~

        console.log({ last_result });

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        }
    };
</script>
...
...
----
// }}}

Then we're going to need to show that check. But you seen that on here, when this happens it appears for a minute and
then it goes away.

//{{{ image::./images/gif/chapter-6-2.gif
[#img-chapter]
[link=./images/gif/chapter-6-2.gif,window=_blank]
.Creating a Game Screen -9
image::./images/gif/chapter-6-2.gif[align="center"]
//}}}

As you can see, it doesn't just immediately advance to the next round. Because then you wouldn't get any useful
feedback.

So, we're going to need to change this `"submit"` - function to an asynchronous function.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    let last_result;

    const submit = async (a, b, sign) => {
//                 ~~~~~
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        // wait for 1500 ms

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };
</script>
----
// }}}

Then after the `"last_result"` has been set, we're going to need to wait for `1500` - milliseconds.

There's several way, but I like to do this, which is to create a `"sleep()"`
- function.

So, we open our `"utils.js"` file. We're going to export a new function. I'm going to called `"sleep"`.

// {{{ utils.js
[[source, javascript]]
----
// utils.js

export function pick_random(array) {
    const index = Math.floor(array.length * Math.random());
    return array[index];
}

export function sleep(ms) {
    return new Promise((fulfil) => {
        setTimeout(fulfil, ms);
    });
}
----
// }}}

This function take `"ms"` as an argument, and it's going to return a `"Promise"`, which takes a Handle here `"fulfil"`,
then we do `"setTimeout(fulfil, ms)"`.

So, we're going to import that function in our "Game" - Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...

    import { sleep } from "../utils.js";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ...
    ...

    let last_result;

    const submit = async (a, b, sign) => {
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);
//      ~~~~~~~~~~~~~~~~

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };
</script>
...
...
----
// }}}

Then, once we've set the result (`last_result`) in our `"submit"` Handler, I'm just going to do `"await sleep(1500)"`,
and nothing else can happen while as going on.

So now we need to actually use that information somehow.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div class="game-container">
...
...
</div>
{#if last_result}                           // <<<
<img                                        // <<<
    class="giant-result"                    // <<<
    alt="{last_result} answer"              // <<<
    src="/icons/{last_result}.svg"          // <<<
    >                                       // <<<
{/if}                                       // <<<

<div class="results">
...
...
</div>

<style>
...
...

    .giant-result {
        position: fixed;
        width: 50vmin;
        height: 50vmin;
        left: calc(50vw - 25vmin);
        top: calc(50vh- 25vmin); opacity: 0.5; }

...
...
</style>
----
// }}}

Let say, if we have a `"last_result"`, we're going to create an image. Give it a class `"giant-result"`, we give it an
`"alt={last_result}"` attribute, which is going to be either right or wrong. So the old attribute is going to be right
answer or wrong answer. Then the source of that image is going to be one of the icons that is already in the public
directory.

Finally we need to add some CSS for `".giant-result"`.

So this if we click on of these celebrities, the image is going to appear in the middle of the screen. That exactly
what we want.

//{{{ image::./images/gif/chapter-6-3.gif
[#img-chapter]
[link=./images/gif/chapter-6-3.gif,window=_blank]
.Creating a Game Screen -10
image::./images/gif/chapter-6-3.gif[align="center"]
//}}}

But it's not getting cleared out, so we're going need to do that after we've finished awaiting. Just do `"last_result
= null"`, and then we can get on this game for next round.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        last_result = null;
//      ~~~~~~~~~~~~~~~~~~

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };

    let i = 0;
</script>
...
...
----
// }}}

So this time, we can get rid the result for the next game.

//{{{ image::./images/gif/chapter-6-4.gif
[#img-chapter]
[link=./images/gif/chapter-6-4.gif,window=_blank]
.Creating a Game Screen -11
image::./images/gif/chapter-6-4.gif[align="center"]
//}}}

Then finally for the "Game" - UI, we need to add row of result at the bottom of the screen.

//{{{ image::./images/chapter-6-8.png
[#img-chapter]
[link=./images/chapter-6-7.png,window=_blank]
.Creating a Game Screen -12
image::./images/chapter-6-8.png[align="center"]
//}}}

We're going to stay with the "Game" - Component.

So we've got this `"<div class="results">"` already, everting is going to go
inside here. But we can do anything, we're going to need an Array that
represents the `"results"` we've had so far.

So let's just do that up.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
    const result = Array(selection.length);
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let last_result;

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        result[i] = last_result;
//      ~~~~~~~~~~~~~~~~~~~~~~~
        last_result = null;

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };

    let i = 0;
</script>
...
...

<div class="results">                                                       // <<<
    {#each results as result}                                               // <<<
        <span class="result">                                               // <<<
            {#if result}                                                    // <<<
                <img alt="{result} answer" src="/icons/{result}.svg" />     // <<<
            {/if}                                                           // <<<
        </span>                                                             // <<<
    {/each}                                                                 // <<<
</div>                                                                      // <<<

<style>
    ...
    ...

    .results {
        display: grid;
        grid-gap: 0.2em;
        width: 100%;
        max-width: 320px;
        margin: 1em auto 0 auto;
    }

    .result {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        padding: 0 0 100% 0;
        transition: background 0.2s;
        transition-delay: 0.2s;
    }

    .result img {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
    }

    ...
    ...
</style>
----
// }}}

Here comes `"results = Array(selection.length)"`, it's just going to be an
empty Array with the same length as the number of rounds.

Then inside `"<div class="results">"` we can iterate over that even thought
it's an empty Array with holds in it, we ca iterate over because it just uses
the "length - Property" which `"results as result"`.

Then we're going to give each of those `"<span>"`.

Then if we have the `"results"` for this round, then we'll use the same image
that we had before, except this time it's not going to have this
`"giant-result"` - CSS Class.

Last thing that we need to do is assigned to the `"results"` - Array at the
same time as we clear out the `"last_result"`,(`"results[i] = last_result"`).

We also need to add some CSS for this `"results"` - Class.

Now because the `"result - div"` is using "CSS - Grid", we need to tell it how
many items is going to have, otherwise it's not going to know how to lay things
out.

So we're just going to repeat for however many things we have in our
`"results"` - Array, and that's going to be `"1fr"`.

So that's just going to get dived into `10` - blocks, each of blocks which is
going to contain one of the images rounds.

So that's working, is taking the big giant image, and then replacing it with
a little one. That's keeping track of performance so far.

[[_neat_question]]
=== Neat Question
:fn-svelte_preprocessor: link:https://github.com/sveltejs/svelte-preprocess

*"Q"*: Does Svelte support SASS or LESS with single within a single file Component?

*"A"*: Yes it does, not natively. Svelte itself doesn't understand anything
other than HTML, CSS, JavaScript. But you can pre-process your Svelte
- Component using a module called
`"{fn-svelte_preprocessor}[svelte-preprocess, window=_blank]"`, which will take
in the context of the Component, and then transform the contents of your
`"<script>"` - block in your `"<style>"` - Block and the Component as a whole
in any way you specify.

// }}}

// {{{ 6 == Game Completion State
[[_game_completion_state]]
== Game Completion State

So we left things with this Big TODO for end the game. We need to do better
than that.

// {{{ Game.svelte
[source, html]
----
<script>
    ...
    ...

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        results[i] = last_result;
        last_result = null;

        if (i < selection.length - 1) {
            i += 1;
        } else {
            // TODO end the game
//          ~~~~~~~~~~~~~~~~~~~
        }
    };

    let i = 0;
</script>
----
// }}}

We need to show the user the `"results"`, and then we need to take them back to
the "Welcome" - screen once they exit.

So let's add another value, called `"done"`.

// {{{ Game.svelte
[source, html]
----
<script>
    ...
    ...
    let done = false;
//  ~~~~~~~~~~~~~~~~

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        results[i] = last_result;
        last_result = null;

        if (i < selection.length - 1) {
            i += 1;
        } else {
            done  = true
//          ~~~~~~~~~~~
        }
    };

    let i = 0;
</script>
----
// }}}

Then we add `"done"` - value under `"submit"` - function to be `"true"`. Means
that we've answered all `10` rounds and we're ready to see what happened.

Then inside our `"game-container"` - div, we need to represent that somehow.
Let's add an `"if"` - block statement.

// {{{ Game.svelte
[source, html]
----
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>???/{results.length}</strong>
//                 ~~~~
            <p>Pops up message goes here</p>
            <button>Back to main screen</button>
        </div>
    {:else}
        {#await promises[i] then [a, b]}
            <div class="game">
                <div class="card-container">
                    <Card celeb={a} on:select={() => submit(a, b, 1)} />
                </div>

                <div>
                    <button class="same" on:click={() => submit(a, b, 0)}> same price </button>
                </div>

                <div class="card-container">
                    <Card celeb={b} on:select={() => submit(a, b, -1)} />
                </div>
            </div>
        {:catch}
            <p class="error">Oops! Failed to load data</p>
        {/await}
    {/if}
</div>
...
...
----
// }}}

We add `"if  *done*"` - block, and then add an `"else"` - block. I'm going to put
all of this `"await"` stuff inside the `"else"` - block.

Then inside the `"if"` - block, we are going to have the element that giving
our result, we leave that blank for now `"???"` because you don't have
a representation of the user score.

We also have the message that pops-up.

Then we have a button that takes the user back to the home screen.

Now let's tackle this `"???"` first. We want to have a value that's derived
from the `"results"` Array, that represent how many answers you got right, and
that's easy enough to do by using a *"Reactive - Declaration"*.

We can do `"$: score = results.filter((x) => x === "right").length;"`. For the
ones where `"x"` is `"right"` we just want to grab the length of that. That is
going to be our `"score"`.

// {{{ Game.svelte
[source, html]
----
<script>
    ....
    ....
    $: score = results.filter((x) => x === "right").length;
</script>
...
...
----
// }}}

Then we can replace this `"???"` marks with Reactive - Variable we named
`"scored"`.

// {{{ Game.svelte
[source, html]
----
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
//                  ~~~~~~
            <p>Pops up message goes here</p>
            <button>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

For the message, we're going to want to have a function that will pick out
a message that is customized based on how the person did playing.

// {{{ Game.svelte
[source, html]
----
<script>
    ...
    ...
    import { sleep, pick_random } from "../utils.js";
//                  ~~~~~~~~~~~

    ...
    ...

    const pick_message = (p) => {
        if (p <= 0.2) return pick_random([`Oof.`, `Better luck next time?`]);
        if (p <= 0.5) return pick_random([`I've seen worse`, `Keep trying!`]);
        if (p <= 0.8) return pick_random([`Yeah!`, `Not bad. Practice makes perfect`]);
        if (p < 1) return pick_random([`Impressive.`]);
        return pick_random([`Flawless victory`, `Top marks`]);
    };
</script>
...
...
----
// }}}

So we create a thing, `"pick_message"` equals `"p"`, which is a value from `0`
to `1`, where `0` is you didn't get any right, and `1` is you got them.

Let's import our  `"pick_random"` function that we're using in the `"select"`
- module. All that's going to do, you pass in an Array, and it will randomly
select an item from that Array by choosing a random number and multiplying it
by the length of the Array. Flooring that, and then returning that Element of
the Array.

Now we can implement our `"pick_message"` - function like above.

- If `"p"` is less than `"2"`, we return a message,  `"['Oof.', 'Better luck
  next time?']"`
- If `"p"` is less than `"5"`, we can return a random one of message like,
  `"['I've seen worse', 'Keep trying!']"`.
- If `"p"` is up to `"8"` out of `"10"`, we can give more encouraging message,
  `"['Yeah!', 'Not bad. Practice makes perfect']"`
- If they get up to `"8"` or `"9"`, then we return a message,
  `"['Impressive.']"`
- Otherwise they got the top result with message, `"['Flawless victory', 'Top
  marks']"`

Then we can use this function inside our template.

// {{{ Game.svelte
[source, html]
----
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            <button>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

We replace our message with `"pick_message"`, and then with an argument
`"score"` divided by `'results.length"`, is going to give us a value between
`0` and `1`.

That is pretty much everything except that we need to add an Event - Handler
when we click the button.

// {{{ Game.svelte
[source, html]
----
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
            <button on:click={() => dispatch("restart")}>Back to main screen</button>
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

We're going to do dispatch `"restart"` - Event.

We have a warning because `"dispatch"` has not yet been defined. So we need to
do the same thing once again.

// {{{ Game.svelte
[source, html]
----
<script>
    import { createEventDispatcher } from "svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ...
    ...

    const dispatch = createEventDispatcher();
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
            <button on:click={() => dispatch("restart")}>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

Just to bring things full circle, inside `"App.svelte". When we hear the
`"restart'` - Event coming from the "Game" - Component we just set the State of
the app back as a whole back to Welcome.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
</script>

<main>
    {#if state === "welcome"}
        <Welcome on:select={start} />
    {:else if state === "playing"}
        <Game {selection} on:restart={() => (state = "welcome")} />
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {/if}
</main>
...
...
----
// }}}

Let's checkup our apps by playing it,

//{{{ image::./images/gif/chapter-6-5.gif
[#img-chapter]
[link=./images/gif/chapter-6-5.gif,window=_blank]
.Creating a Game Screen -13
image::./images/gif/chapter-6-5.gif[align="center"]
//}}}

// }}}
