//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 6
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sat May  8 09:11:13 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_6_building_a_game]]
= Chapter-6 Building A Game

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_preparation[Preparation]
| 2.    | xref:_creating_the_game_Screen[Creating The Game Screen]
| 3.    | xref:_game_layout_button[Game Layout & Button]
| 4.    | xref:_wiring_up_interactivity[Wiring Up Interactivity]
| 5.    | xref:_game_activity_display[Game Activity Display]
| 6.    | xref:_game_completion_state[Game Completion State]
| 7.    | xref:_displaying_game_data[Displaying Game Data]
| 8.    | xref:_polishing_ui_adding_transition[Polishing UI & Adding Transition]
|====
//}}}

// {{{ 1 == Preparation
[[_preparation]]
== Preparation
:fn-cameo_com: link:http://cameo.com/
:fn-cameoparison: link:https://cameoparison.netlify.app/
:fn-cameo_explorer: link:https://cameo-explorer.netlify.app/celebs

//{{{ image::./images/chapter-6-1.png
[#img-chapter]
[link=./images/chapter-6-1.png,window=_blank]
.Building a Game
image::./images/chapter-6-1.png[align="center"]
//}}}

Time to move onto the fun stuff. We're going to make a game using data from
{fn-cameo_com}[cameo.com,window=_blank], an amazing website that lets you pay
celebrities to record 30 second personalised videos. You can get the "Insane
Clown Posse" to roast your friends or wish your spouse a happy anniversary.

The game is called {fn-cameoparison}[CameoParison,window=_blank], and the goal
is to guess which celebrities are expensive, and which ones are cheap. Since
there's no official API, we'll grab data from
{fn-cameo_explorer}[cameo-explorer.netlify.app,window=_blank], which contains
a scraped snapshot of some of the top celebs.

We'll start by cloning the starter repo:

// {{{ $ git clone git@github.com:Rich-Harris/cameoparison-starter.git
[source, bash]
----
$ git clone git@github.com:Rich-Harris/cameoparison-starter.git
----
// }}}

This is almost identical to the default project template, with the addition of
a couple of image files and some extra `"src"` modules to save time later.

It also has several *branches* that you can check out if you get stuck following
the course and need to get back on track:

- checkpoint-1
- checkpoint-2
- checkpoint-3
- complete

As you follow along, make your changes in the master branch.
**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 2  == Creating The Game Screen
[[_creating_the_game_Screen]]
== Creating The Game Screen

All right, so the first order of business is going to be create a "Game
- Screen" - Component, similar to "Welcome - Screen" - Component.

We create a new file Component named `"Game.svelte"` in `"/src/screens/"`.

Then we'll import that inside `"App.svelte"`, the same way that we imported our
"Welcome" - Component.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onMount } from "svelte";

    import Welcome from "./screens/Welcome.svelte";
    import Game from "./screens/Game.svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    import { select } from "./select";

    ....
    ....
</script>
----
// }}}

Then inside the `<main>` - placeholder, we're going to instantiate the "Game"
- Component,

// {{{ App.svelte
[source, html]
----
// App.svelte
</script>
    ...
    ...
<script>

<main>
    {#if state === "welcome"}
        <Welcome on:select={start} />
    {:else}
        <Game {selection} />
//      ~~~~~~~~~~~~~~~~~~~~
    {/if}
</main>
----
// }}}

We're going to pass through the `"selection"`, because that's what the game is
going to use, to actually render the quiz.

So, we open our new Component we make which is `"Game.svelte"`,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;
    console.log(selection);
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    <p>game will go here</p>
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }
</style>
----
// }}}

The first thing we need to do in our "Game" - Component is to make that
`"selection"` - "Prop" available, by doing `"export let selection"`.

I'm going to verify that is getting passed through correctly by logging it
`"console.log(selection)"`.

Then, once again we're just going to rip off some mock-up the one that we made
earlier.

Then the rest is just going to be placeholder stuff. We're going to make an
element that contain the game, `class="game-container"`.

Finally we're going to create that little row of result at the bottom,
`"class="results"`.

Right now everything is getting squeezed into the middle of the screen.

//{{{ image::./images/chapter-6-2.png
[#img-chapter]
[link=./images/chapter-6-2.png,window=_blank]
.Creating a Game Screen -1
image::./images/chapter-6-2.png[align="center"]
//}}}

We want the "Game" - Container to fill as much spaces possible, and then for
the `"<header>"` and the `"results"` to just occupy the "top" and "bottom".

We add the CSS - Style to `"game-container"` - Class to have a `"flex:"` with
value of `"1"`.

Than will make it stretch to occupy as much space as it can.

//{{{ image::./images/chapter-6-3.png
[#img-chapter]
[link=./images/chapter-6-3.png,window=_blank]
.Creating a Game Screen -2
image::./images/chapter-6-3.png[align="center"]
//}}}

So the "Game" - Container as you can see, is occupying most of the screen.

Now, if you look at the `"selection"` - Object that is being passed in as
a "Prop", we can see the *Data -Structure* that we've got to work with.

//{{{ image::./images/chapter-6-4.png
[#img-chapter]
[link=./images/chapter-6-4.png,window=_blank]
.Creating a Game Screen -3
image::./images/chapter-6-4.png[align="center"]
//}}}

As we can see, mos of the stuff that we need is there. We've got `"names"`,
we've got `"prices"`, we've got all of that.

*BUT* we do NOT have the `"image"` that belongs to each of these celebrities.

For that, we're going to need to go back to the API, and we're going to need to
load some more data for each of these.

That essentially means we're going to need to create a bunch of "Promises" that
presenting the result of loading that data.

Let's add some code into "Game" -Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;

    const load_details = async (celeb) => {
        const res = await fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`);
        return await res.json();
    };
    const promises = selection.map(round => Promise.all([
        load_details(round.a),
        load_details(round.b)
    ]));
	let i = 0;
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                {a.name}
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                {b.name}
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }

    .error {
        color: red;
    }
</style>
----
// }}}

So let's do `"const promises = selection.map()"`, and then for each of those
Objects that we just looked at with `"Promise.all()"`.

We're going to load some details "a" - property (`load_details(round.a)`),
and "b" - property (`load_details(round,b)`)

So right now, we just need to implement `"load_details"`.

We just going to grab the URL again
`https://cameo-explorer.netlify.app/celebs/`

//{{{ image::./images/chapter-6-5.pn
[#img-chapter]
[link=./images/chapter-6-5.png,window=_blank]
.Creating a Game Screen -4
image::./images/chapter-6-5.png[align="center"]
//}}}

So each of these `"celebs"` has "JSON" that we can inspect. Which contains all
of the same information as before plus `*"description"*` and plus the `*"image"*`.

We grab that - URL and then just replace the "celebs - name" with the *ID* of the
*Celeb* that we care about,
(`fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`)`)

Then, we just going to return the "JSON" for that response, `return await
res.json()`.

So, that's going to give this bunch of different Promises that represent the
full detail of the celebrities whose have faces (images) we are going to
include in our game.

Now dealing with *"asynchronous" - Object* in *templating languages* has been
a little bit awkward. But Svelte has a *first-class* way of showing "Promises"
in your Component that we looked at earlier, and it's called the *"await"*
- block.

We're going to use one of those here, we're going to do `"{#await something}"`. Then
we're going to have an Array of "a" and "b", because that's what's getting in
return from (`" const promises"`) an Array.

By the way, I'm actually using a shorthand here.

// {{{  {#await something}
[source, html]
----
// Game.svelte
{#await something}
    <p>pending block</p>

{:then value}
    <p>{value}</p>

{/await}
----
// }}}

Before we had a `"await something"`, and then we would have a `"pending
block"`, then you would have `{:then}` - clause.

In cases like above, where we actually *don't want to show anything*, while
*`"pending"` is still the case*, we can shortcut this with `{# await something
then [value]}`, and also we can use `destructuring`.

Then inside `await` - clause, we're going to create the `"game"` - Element it
itself by creating a Class, (`<div class= "game">`)

We're going to have a "card" for the two celebrities images,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>
        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

Okay, on the final version of the game, you can see that as well as having
celebrity `"a"`, and celebrity `"b"`, we have a *button* in the middle that
you're supposed to press, when you're think that they're charging exactly the
same price.

//{{{ image::./images/chapter-6-6.png
[#img-chapter]
[link=./images/chapter-6-6.png,window=_blank]
.Creating a Game Screen -5
image::./images/chapter-6-6.png[align="center"]
//}}}

So we are going to add that button to our markup as well. We just put a little
`<div>` in there, and inside we're going to have a `"<button>"` - Element wit
a Class `"same"`, amd then we put the word `'same price"`, to be like


// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

In some cases like as we've seen, it's possible that there would be an error.
So we use the `"{:catch}"` - clause, we put an error message, then we just
print a message `Failed to load data`, in `"<p>"` - Element, to be like so,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

Then we just add some CSS - style for class - `".error{ color: red }"`

Okay, so what we'll do now is, to figure out what `"something"` should be.

So we have an Array of `"const promises"`, and we're going to step through them
one at the time, and the easiest way to do that would be to just have a value
that represent the *"current - index"* into those `"promises"`

So let's create a new value, `"let i = 0"`, and I'm just take that ip as we go
through the `"rounds"`, and we replace `"something"` with `"promises[i]"`, like
so,

// {{{ {#await promises[i] then [a, b]}
[source, html]
----
// Game.svelte
{#await promises[i] then [a, b]}
//      ~~~~~~~~~~~
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

If we go over to our application, we can see that it is indeed picking out two
- celebrities, and rendering some game UI for those.

//{{{ image::./images/chapter-6-7.png
[#img-chapter]
[link=./images/chapter-6-7.png,window=_blank]
.Creating a Game Screen -6
image::./images/chapter-6-7.png[align="center"]
//}}}

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 3 == Game Layout & Button
[[_game_layout_button]]
== Game Layout & Button

Okay, so it's time to start building the UI a little bit further. We're going
to create some "Cards" for the celebrities, and then use those in the "Game"
- Component.

That means we're going to create a new - Component. That's not a screen, but is
a separate Component. So I'm going to create a new directory inside our
`"source/`, called `"src/components"`. I'm going to create a Component called
`"Card.svelte"`.

Then inside the `"Game.svelte"` - Component, I'm going to import that new
component.

// {{{ Game.svelte
[source, html]
----
<script>
    import Game from "../components/Game.svelte";
    ...
    ...
</script>
...
...

<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card celeb="[a}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                <Card celeb="[b}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>
----
// }}}

[NOTE]
There's really, no, sort of conventions about how you organize your Components.
I put this i a separate Components - Folder, but you could also put in next to
the `"Game.svelte"` - Component. It's really up to your personal preference,.


Then we're just going to replace these `{a.name}` with `"<Card celeb={a} /">`, and
then same down here `"<Card celeb={b} />"`, as like so,

So, let's flash out the layout a little bit of our main "Game" - Component. We
give more CSS - Style.

// {{{ Game.svelte
[source, diff]
----
// Game.svelte
<script>
...
</script>
...
...
<div class="game-container">
...
...
</div>

<style>
     .game-container {
         flex: 1;
     }

+    .game {
+        display: grid;
+        grid-template-rows: 1fr 2em 1fr;
+        grid-gap: 0.5em;
+        width: 100%;
+        height: 100%;
+        max-width: min(100%, 40vh);
+        margin: 0 auto;
+    }
+    .game > div {
+        display: flex;
+        align-items: center;
+    }
+    .same {
+        width: 100%;
+        align-items: center;
+        margin: 0;
+    }
+    .game .card-container button {
+        width: 100%;
+        height: 100%;
+        padding: 0;
+        margin: 0;
+    }
+
     .error {
         color: red;
     }
+
+    @media (min-width: 640px) {
+        .game {
+            max-width: 100%;
+            grid-template-rows: none;
+            grid-template-columns: 1fr 8em 1fr;
+            /* work around apparent safari flex bug */
+            max-height: calc(100vh - 6em);
+        }
+        .same {
+            height: 8em;
+        }
+    }
</style>
----
// }}}

Next, let's go over to the "Card" - Box whole Component and start implementing
that,

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    export let celeb;

</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});">
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
        </div>
    </button>
</div>

<style>
    .card-outer {
        width: 100%;
        height: 100%;
    }

    .card-inner {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: 50% 50% no-repeat;
        background-position: 50% 0;
        background-size: cover;
        overflow: hidden;
        padding: 0;
        text-align: left;
    }

    .details {
        position: absolute;
        width: 100%;
        bottom: 0;
        padding: 1em 0.5em 0.5em 0.5em;
        background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.6) 35%, rgba(0, 0, 0, 0.9));
        color: white;
    }

    h2 {
        margin: 0 0 0.2em 0;
    }

    .type {
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    @media (min-width: 640px) {
        .card-outer {
            height: 0;
            padding: 0 0 100% 0;
        }
    }
</style>
----
// }}}

We're going to create an element to contain everything call that
`"card-outer"`, and inside there, we're going to create a "_button_"

The reason I'm using the button is, because these are *interactive* Elements.
So things that the user is supposed to click-on, and the nice thing using
buttons is, we get a lot of accessibility properties for free.

So right now, in {fn-cameoparison}[deployed site,window=_blank], if someone who
used the keyboard instead the mouse for whatever accessibility reason, I might
have, I can press `tab` - key, and it will take me between the Elements on the
page.

//{{{ image::./images/gif/chapter-6-1.gif
[#img-chapter]
[link=./images/gif/chapter-6-1.gif,window=_blank]
.Creating a Game Screen -8
image::./images/gif/chapter-6-1.gif[align="center"]
//}}}

So, we're going to use button in all three cases where both the celebrities and
the `"same price"` thing in as the middle button.

We create button - with Class name `"card-inner"`.

The button is going to have the background image that corresponds to the
"celebrity image". We use "inline style" `style="background-image:
url({celeb.image});"`.

Then inside there, we're going to have these `"details"` - Elements.

We left the static markup that specific to celebrity, with the properties of
our celebrity Object `"href="https://cameo.com/{celeb.id}"` and `{celeb.name}`,
and `{celeb.type}`.

Then we add some style. You can read above, because our course specific to
Svelte.

**â¬†xref:_table_of_contents[back to top]**
//}}}

// {{{ 4 == Wiring Up Interactivity
[[_wiring_up_interactivity]]
== Wiring Up Interactivity

So now we've created the buttons, we've got the buttons inside this "Card"
- Component for the celebrities, and we've got another button for the "same
price"`.

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    import { createEventDispatcher } from "svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    export let celeb;
    const dispatch = createEventDispatcher();
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});" on:click={() => dispatch("select")}>
//                                                                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
        </div>
    </button>
</div>

<style>
...
...
</style>
----
// }}}

Now we need to wire those up, which means importing
`"createEventDispatcher()"`.

We create a `"const dispatch"` function.

Once the `"<button>"` - Element get "clicked", we can do `"on:click={() =>
dispatch("select")}"`

Then we get back into our "Game" - Component, we can add a `select` - Handler,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div>
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card
                    celeb="[a}"
                    on:select ={() => {...}}
//                  ~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>

            <div>
                <button class="same" on:click ={() => {...}}> same price </button>
//                                   ~~~~~~~~~~~~~~~~~~~
            </div>

            <div class="card-container">
                <Card
                    celeb="[b}"
                    on:select ={() => {...}}
//                  ~~~~~~~~~~~~~~~~~~~~~~
            />
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<style>
...
...
</style>
----
// }}}

Now, we don't yet know what's going to happen here. So I'm just going to leave
blank like so `"on:select = () => {...}"`.

We going to add a similar thing to the `"<button>"` - Element, except instead
of `"on:select"`, it's going to be an `"on:click"` - Handler.

Then we need to create a function that is going to get called. When each of
these things happens.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    const submit = (a, b, sign) =>{                                                 // <<<
        const result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";   // <<<

        console.log(result);                                                        // <<<

        if (i < selection.length - 1) {                                             // <<<
            i += 1;                                                                 // <<<
        }
        else {                                                                      // <<<
            // TODO end the game                                                    // <<<
        }                                                                           // <<<
    };
</script>

<div>
...
...
</div>

<style>
...
...
</style>
----
// }}}

We called the function name with `"submit"`, because the user is submitting the
response.

What `submit"` is going to need is, going to need the celebrity on the left
(`"a"`), and the celebrity on the right `(`"b"`), and some sort of
representation of the users guess (`"<button>"`).

The way we can do this is, I'm going to pass in the celebrity - Objects as the
*first two arguments*, and then the *third argument* is going to be a `"sign"`,
which is going to be either `"-1"`, `"0"` or `"1"`.

Then, we will see if the `Math.sign()`, which is a function that's *map* out
`"sign"`,

- If you give it a *"positive number"* it will return `"1"`.
- If you give it a *"negative number"* it will return `"-1"`.
- If you give it *"zero"* it will return `"0"`.

So, that's very useful for this particular use-case.

So, we put `"Math.sigh(a.price - b.price)"`, that value is going to be `"1"`.
If `"a"` is the more expensive celebrity. So if that matches the `"sign"` that
was passed in, then the result is `"right"`, otherwise it's `"wrong"`.

Then we can `console.log()` that `"result"`.

Once that's happen, we can increment the index of the current round.

If `"i"` is less then the number of rounds in the game minus `1`,
(`"selection.length - 1"`), then increment it `i += 1`.

Otherwise, it's going to end the game, but we leave that as `"TODO"` for now.

So, now we just need to call this `"submit"` - function from each of those
Event - Handlers.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div>
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card
                    celeb="{a}"
                    on:select ={() => submit(a, b, 1}
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>

            <div>
                <button class="same" on:click ={() => submit(a, b, 0)}> same price </button>
//                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            </div>

            <div class="card-container">
                <Card
                    celeb="{b}"
                    on:select ={() => submit(a, b, -1}
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                />
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<style>
...
...
</style>
----
// }}}

Each of those Event - Handlers we put Element directive, like so:

- `"on:select={() => submit(a, b, 1)}"`. If we click on card where celebrity
  equal `"a"` then we're guessing that `"a"` is the more expensive celebrity,
  so the `"sign"` is going to be `"1"`, because it's `"a.price - b.price"`, and
  then it'll be the reverse for the other celebrities.

- `"on:select={() => submit(a, b, -1)}"`, if we click on card where celebrity
  equal `"b"`, is going to be `"-1"`.

- `"on:select={() => submit(a, b, 0)}"`, finally for the guess where it's the
  `"same price"` , is going to be `"0"`.

Next we need to display the `"result"` somehow. But we've got everything pretty
much wired up the way we need it to.

So let's move on to "Game Activity Display".

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 5 == Game Activity Display
[[_game_activity_display]] == Game Activity Display

So in here `"Game"` - Component we're creating this `"result"` - variable that's constant, and logging it. But we can
use that in the UI.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
    const submit = (a, b, sign) => {
        const result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        console.log({ result });    // <<<

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        }
    };
</script>
...
...
----
// }}}

We can say that, once there is a `"result"`, we shown either the "big green check" or the "big red cross".

Before we can do that we're going to need to take it out of that function, let's call it `"last_result"`, then change
`"const result"` into `"last_result"`.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>

    let last_result;
//  ~~~~~~~~~~~~~~~

    const submit = (a, b, sign) => {
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";
//            ~~~~~~~~~~

        console.log({ last_result });

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        }
    };
</script>
...
...
----
// }}}

Then we're going to need to show that check. But you seen that on here, when this happens it appears for a minute and
then it goes away.

//{{{ image::./images/gif/chapter-6-2.gif
[#img-chapter]
[link=./images/gif/chapter-6-2.gif,window=_blank]
.Creating a Game Screen -9
image::./images/gif/chapter-6-2.gif[align="center"]
//}}}

As you can see, it doesn't just immediately advance to the next round. Because then you wouldn't get any useful
feedback.

So, we're going to need to change this `"submit"` - function to an asynchronous function.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    let last_result;

    const submit = async (a, b, sign) => {
//                 ~~~~~
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        // wait for 1500 ms

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };
</script>
----
// }}}

Then after the `"last_result"` has been set, we're going to need to wait for `1500` - milliseconds.

There's several way, but I like to do this, which is to create a `"sleep()"`
- function.

So, we open our `"utils.js"` file. We're going to export a new function. I'm going to called `"sleep"`.

// {{{ utils.js
[source, javascript]
----
// utils.js

export function pick_random(array) {
    const index = Math.floor(array.length * Math.random());
    return array[index];
}

export function sleep(ms) {
    return new Promise((fulfil) => {
        setTimeout(fulfil, ms);
    });
}
----
// }}}

This function take `"ms"` as an argument, and it's going to return a `"Promise"`, which takes a Handle here `"fulfil"`,
then we do `"setTimeout(fulfil, ms)"`.

So, we're going to import that function in our "Game" - Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...

    import { sleep } from "../utils.js";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ...
    ...

    let last_result;

    const submit = async (a, b, sign) => {
        const last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);
//      ~~~~~~~~~~~~~~~~

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };
</script>
...
...
----
// }}}

Then, once we've set the result (`last_result`) in our `"submit"` Handler, I'm just going to do `"await sleep(1500)"`,
and nothing else can happen while as going on.

So now we need to actually use that information somehow.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div class="game-container">
...
...
</div>
{#if last_result}                           // <<<
<img                                        // <<<
    class="giant-result"                    // <<<
    alt="{last_result} answer"              // <<<
    src="/icons/{last_result}.svg"          // <<<
    >                                       // <<<
{/if}                                       // <<<

<div class="results">
...
...
</div>

<style>
...
...

    .giant-result {
        position: fixed;
        width: 50vmin;
        height: 50vmin;
        left: calc(50vw - 25vmin);
        top: calc(50vh- 25vmin); opacity: 0.5; }

...
...
</style>
----
// }}}

Let say, if we have a `"last_result"`, we're going to create an image. Give it a class `"giant-result"`, we give it an
`"alt={last_result}"` attribute, which is going to be either right or wrong. So the old attribute is going to be right
answer or wrong answer. Then the source of that image is going to be one of the icons that is already in the public
directory.

Finally we need to add some CSS for `".giant-result"`.

So this if we click on of these celebrities, the image is going to appear in the middle of the screen. That exactly
what we want.

//{{{ image::./images/gif/chapter-6-3.gif
[#img-chapter]
[link=./images/gif/chapter-6-3.gif,window=_blank]
.Creating a Game Screen -10
image::./images/gif/chapter-6-3.gif[align="center"]
//}}}

But it's not getting cleared out, so we're going need to do that after we've finished awaiting. Just do `"last_result
= null"`, and then we can get on this game for next round.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        last_result = null;
//      ~~~~~~~~~~~~~~~~~~

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };

    let i = 0;
</script>
...
...
----
// }}}

So this time, we can get rid the result for the next game.

//{{{ image::./images/gif/chapter-6-4.gif
[#img-chapter]
[link=./images/gif/chapter-6-4.gif,window=_blank]
.Creating a Game Screen -11
image::./images/gif/chapter-6-4.gif[align="center"]
//}}}

Then finally for the "Game" - UI, we need to add row of result at the bottom of the screen.

//{{{ image::./images/chapter-6-8.png
[#img-chapter]
[link=./images/chapter-6-7.png,window=_blank]
.Creating a Game Screen -12
image::./images/chapter-6-8.png[align="center"]
//}}}

We're going to stay with the "Game" - Component.

So we've got this `"<div class="results">"` already, everting is going to go
inside here. But we can do anything, we're going to need an Array that
represents the `"results"` we've had so far.

So let's just do that up.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
    const result = Array(selection.length);
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let last_result;

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        result[i] = last_result;
//      ~~~~~~~~~~~~~~~~~~~~~~~
        last_result = null;

        if (i < selection.length - 1) { i += 1; } else {
            // TODO end the game
        } };

    let i = 0;
</script>
...
...

<div class="results">                                                       // <<<
    {#each results as result}                                               // <<<
        <span class="result">                                               // <<<
            {#if result}                                                    // <<<
                <img alt="{result} answer" src="/icons/{result}.svg" />     // <<<
            {/if}                                                           // <<<
        </span>                                                             // <<<
    {/each}                                                                 // <<<
</div>                                                                      // <<<

<style>
    ...
    ...

    .results {
        display: grid;
        grid-gap: 0.2em;
        width: 100%;
        max-width: 320px;
        margin: 1em auto 0 auto;
    }

    .result {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        padding: 0 0 100% 0;
        transition: background 0.2s;
        transition-delay: 0.2s;
    }

    .result img {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
    }

    ...
    ...
</style>
----
// }}}

Here comes `"results = Array(selection.length)"`, it's just going to be an
empty Array with the same length as the number of rounds.

Then inside `"<div class="results">"` we can iterate over that even thought
it's an empty Array with holds in it, we ca iterate over because it just uses
the "length - Property" which `"results as result"`.

Then we're going to give each of those `"<span>"`.

Then if we have the `"results"` for this round, then we'll use the same image
that we had before, except this time it's not going to have this
`"giant-result"` - CSS Class.

Last thing that we need to do is assigned to the `"results"` - Array at the
same time as we clear out the `"last_result"`,(`"results[i] = last_result"`).

We also need to add some CSS for this `"results"` - Class.

Now because the `"result - div"` is using "CSS - Grid", we need to tell it how
many items is going to have, otherwise it's not going to know how to lay things
out.

So we're just going to repeat for however many things we have in our
`"results"` - Array, and that's going to be `"1fr"`.

So that's just going to get dived into `10` - blocks, each of blocks which is
going to contain one of the images rounds.

So that's working, is taking the big giant image, and then replacing it with
a little one. That's keeping track of performance so far.

[[_neat_question]]
=== Neat Question
:fn-svelte_preprocessor: link:https://github.com/sveltejs/svelte-preprocess

*"Q"*: Does Svelte support SASS or LESS with single within a single file Component?

*"A"*: Yes it does, not natively. Svelte itself doesn't understand anything
other than HTML, CSS, JavaScript. But you can pre-process your Svelte
- Component using a module called
`"{fn-svelte_preprocessor}[svelte-preprocess, window=_blank]"`, which will take
in the context of the Component, and then transform the contents of your
`"<script>"` - block in your `"<style>"` - Block and the Component as a whole
in any way you specify.

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 6 == Game Completion State
[[_game_completion_state]]
== Game Completion State

So we left things with this Big TODO for end the game. We need to do better
than that.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        results[i] = last_result;
        last_result = null;

        if (i < selection.length - 1) {
            i += 1;
        } else {
            // TODO end the game
//          ~~~~~~~~~~~~~~~~~~~
        }
    };

    let i = 0;
</script>
----
// }}}

We need to show the user the `"results"`, and then we need to take them back to
the "Welcome" - screen once they exit.

So let's add another value, called `"done"`.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    let done = false;
//  ~~~~~~~~~~~~~~~~

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        results[i] = last_result;
        last_result = null;

        if (i < selection.length - 1) {
            i += 1;
        } else {
            done  = true
//          ~~~~~~~~~~~
        }
    };

    let i = 0;
</script>
----
// }}}

Then we add `"done"` - value under `"submit"` - function to be `"true"`. Means
that we've answered all `10` rounds and we're ready to see what happened.

Then inside our `"game-container"` - div, we need to represent that somehow.
Let's add an `"if"` - block statement.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>???/{results.length}</strong>
//                 ~~~~
            <p>Pops up message goes here</p>
            <button>Back to main screen</button>
        </div>
    {:else}
        {#await promises[i] then [a, b]}
            <div class="game">
                <div class="card-container">
                    <Card celeb={a} on:select={() => submit(a, b, 1)} />
                </div>

                <div>
                    <button class="same" on:click={() => submit(a, b, 0)}> same price </button>
                </div>

                <div class="card-container">
                    <Card celeb={b} on:select={() => submit(a, b, -1)} />
                </div>
            </div>
        {:catch}
            <p class="error">Oops! Failed to load data</p>
        {/await}
    {/if}
</div>
...
...
----
// }}}

We add `"if  *done*"` - block, and then add an `"else"` - block. I'm going to put
all of this `"await"` stuff inside the `"else"` - block.

Then inside the `"if"` - block, we are going to have the element that giving
our result, we leave that blank for now `"???"` because you don't have
a representation of the user score.

We also have the message that pops-up.

Then we have a button that takes the user back to the home screen.

Now let's tackle this `"???"` first. We want to have a value that's derived
from the `"results"` Array, that represent how many answers you got right, and
that's easy enough to do by using a *"Reactive - Declaration"*.

We can do `"$: score = results.filter((x) => x === "right").length;"`. For the
ones where `"x"` is `"right"` we just want to grab the length of that. That is
going to be our `"score"`.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ....
    ....
    $: score = results.filter((x) => x === "right").length;
</script>
...
...
----
// }}}

Then we can replace this `"???"` marks with Reactive - Variable we named
`"scored"`.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
//                  ~~~~~~
            <p>Pops up message goes here</p>
            <button>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

For the message, we're going to want to have a function that will pick out
a message that is customized based on how the person did playing.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    import { sleep, pick_random } from "../utils.js";
//                  ~~~~~~~~~~~

    ...
    ...

    const pick_message = (p) => {
        if (p <= 0.2) return pick_random([`Oof.`, `Better luck next time?`]);
        if (p <= 0.5) return pick_random([`I've seen worse`, `Keep trying!`]);
        if (p <= 0.8) return pick_random([`Yeah!`, `Not bad. Practice makes perfect`]);
        if (p < 1) return pick_random([`Impressive.`]);
        return pick_random([`Flawless victory`, `Top marks`]);
    };
</script>
...
...
----
// }}}

So we create a thing, `"pick_message"` equals `"p"`, which is a value from `0`
to `1`, where `0` is you didn't get any right, and `1` is you got them.

Let's import our  `"pick_random"` function that we're using in the `"select"`
- module. All that's going to do, you pass in an Array, and it will randomly
select an item from that Array by choosing a random number and multiplying it
by the length of the Array. Flooring that, and then returning that Element of
the Array.

Now we can implement our `"pick_message"` - function like above.

- If `"p"` is less than `"2"`, we return a message,  `"['Oof.', 'Better luck
  next time?']"`
- If `"p"` is less than `"5"`, we can return a random one of message like,
  `"['I've seen worse', 'Keep trying!']"`.
- If `"p"` is up to `"8"` out of `"10"`, we can give more encouraging message,
  `"['Yeah!', 'Not bad. Practice makes perfect']"`
- If they get up to `"8"` or `"9"`, then we return a message,
  `"['Impressive.']"`
- Otherwise they got the top result with message, `"['Flawless victory', 'Top
  marks']"`

Then we can use this function inside our template.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
//          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            <button>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

We replace our message with `"pick_message"`, and then with an argument
`"score"` divided by `'results.length"`, is going to give us a value between
`0` and `1`.

That is pretty much everything except that we need to add an Event - Handler
when we click the button.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
            <button on:click={() => dispatch("restart")}>Back to main screen</button>
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

We're going to do dispatch `"restart"` - Event.

We have a warning because `"dispatch"` has not yet been defined. So we need to
do the same thing once again.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    import { createEventDispatcher } from "svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ...
    ...

    const dispatch = createEventDispatcher();
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

<header>
...
...
</header>
<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
            <button on:click={() => dispatch("restart")}>Back to main screen</button>
        </div>
    {:else}
        ...
        ...
    {/if}
</div>
...
...
----
// }}}

Just to bring things full circle, inside `"App.svelte". When we hear the
`"restart'` - Event coming from the "Game" - Component we just set the State of
the app back as a whole back to Welcome.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
</script>

<main>
    {#if state === "welcome"}
        <Welcome on:select={start} />
    {:else if state === "playing"}
        <Game {selection} on:restart={() => (state = "welcome")} />
//      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    {/if}
</main>
...
...
----
// }}}

Let's checkup our apps by playing it,

//{{{ image::./images/gif/chapter-6-5.gif
[#img-chapter]
[link=./images/gif/chapter-6-5.gif,window=_blank]
.Creating a Game Screen -13
image::./images/gif/chapter-6-5.gif[align="center"]
//}}}

Don't forget to add CSS style for `"done"` - CSS Class screen.

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 7 == Displaying Game Data
[[_displaying_game_data]]
== Displaying Game Data
:fn-checkpoint_3: link:https://github.com/Rich-Harris/cameoparison-starter/compare/checkpoint-3

There's one little piece of UI that we're missing which is, when you click on
celebrity's face you want to you want to see what the prices. So that you can
see how big the gap between the two celebrities is.

So we add more stuff to our "Card" - Component. We're going to export a couple
more "Props".

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    import { createEventDispatcher } from "svelte";

    export let celeb;
    export let showprice;       // <<<
    export let winner;          // <<<

    const dispatch = createEventDispatcher();
</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});" on:click={() => dispatch("select")}>
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
            {#if showprice}                                 // <<<
                <div class="price" class:large={winner}>    // <<<
                    <span>${celeb.price}</span>             // <<<
                </div>                                      // <<<
            {/if}                                           // <<<
        </div>
    </button>
</div>
<style>
    ...
    ...
    .price {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        background-color: rgba(0, 0, 0, 0.3);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 4em;
        font-weight: 700;
    }

    .price.large {
        font-size: 6em;
    }

    ...
    ...
</style>
----
// }}}

We can export "Props" called `"showprice"`, and one called `"winner"`.

So when `"showprice"` is `"true"`, we're going to show the price. We going to
add that below our `"details"` - Element.

We're going to ouse the "Class - Directive" to apply the `"large"` - Class if
they are winner.

You see this sort of thing all the time, where you have some Boolean - value,
and you want to toggle the Class  based on there.

Inside that Element, we'll have the value itself `"${celeb.price}"`.

We're going to check some CSS in for `"price"` - Class.

Now we need to pass the `"Props"` through the "Card" - Component. So let's get
back to the "Game" - Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>

<div class="game-container">
    {#if done}
        <div class="done">
            <strong>{score}/{results.length}</strong>
            <p>{pick_message(score / results.length)}</p>
            <button on:click={() => dispatch("restart")}>Back to main screen</button>
        </div>
    {:else}
        {#await promises[i] then [a, b]}
            <div class="game">
                <div class="card-container">
                    <Card                                       // <<<
                        celeb={a}                               // <<<
                        on:select={() => submit(a, b, 1)}       // <<<
                        showprice={!!last_result}               // <<<
                        winner={a.price >= b.price}             // <<<
                    />
                </div>

                <div>
                    <button class="same" on:click={() => submit(a, b, 0)}> same price </button>
                </div>

                <div class="card-container">
                    <Card                                       // <<<
                        celeb={b}                               // <<<
                        on:select={() => submit(a, b, -1)}      // <<<
                        showprice={!!last_result}               // <<<
                        winner={b.price >= a.price}             // <<<
                    />
                </div>
            </div>
        {:catch}
            <p class="error">Oops! Failed to load data</p>
        {/await}
    {/if}
</div>

...
...
----
// }}}

So the "Card" - Component we use in `"Game.svelte"`, we want to show the price
when we have a `"last_result"`. So for the firts `"<Card celeb={a}>"`, we give
the`"showprice={!!last_result}"`, it doesn't really matter but I just like to
show that, and for the `"winner"`, if `"a.price"` is greater than or equal
`"b.price"`, because if they have the same price they both the winner.

Then for `"<Card celeb={b}"`, we do a reverse.

So now we can see the prices being displayed.

//{{{ image::./images/gif/chapter-6-6.gif
[#img-chapter]
[link=./images/gif/chapter-6-6.gif,window=_blank]
.Creating a Game Screen -14
image::./images/gif/chapter-6-6.gif[align="center"]
//}}}

All right, we have a functionality complete game, and we're now at
{fn-checkpoint_3}["checkpoint-3",window=_blank] in the git repo.

So once again, if you follow behind and you want to catch up before the final
push to a complete game, than you can stash what you've worked on, and then do
`"git checkout checkpoint-3"`.

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 8  == Polishing UI & Adding Transition
[[_polishing_ui_adding_transition]]
== Polishing UI & Adding Transition
:fn-new_image: link:https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image

All right, so it's time for the final push. We have a functional game and all
we need to do now is Polish up the UI a little bit.

// {{{ === Fix Welcome Button Styles
=== Fix Welcome Button Styles

So, the first thing we're going to do is fix these button styles, because this
looks a little bit ugly.

//{{{ image::./images/chapter-6-9.png
[#img-chapter]
[link=./images/chapter-6-9.png,window=_blank]
.Creating a Game Screen -15
image::./images/chapter-6-9.png[align="center"]
//}}}

So let's go to our "Welcome" - Component like so,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
...
...
</script>
...
...
<style>
    ...
    ...

    .categories {
        width: 100%;
        max-width: 26em;
        margin: 0 auto;
    }

    button {
        padding: 0.5em 1em;
        display: block;
        margin: 0 0 0.2em 0;
        width: 100%;
    }

    @media (min-width: 640px) {
        button {
            display: inline;
            margin: 0 0.2em 0.4em 0.2em;
            width: auto;
        }
    }
</style>
----
// }}}

// }}} ===

// {{{ === Preload Images
=== Preload Images

All right, next we're going to do is, we're going to make sure that when each
round starts with already pre-load the images for that celebrity's face.
Otherwise what happens is, the image gets created and at that point, the
browser start downloading. The image is already visible on the screen so that
can create this nasty *flickering effect*.

We can fix that by loading the image at the same time as we load the data that
the celebrities over the network.

So inside our `"utils.js"`, we're going to create a new function called
`"load_image"`.

// {{{ utils.js
[source, javascript]
----
// utils.js
...
...

export function load_image(src) {
    return new Promise((fulfil, reject) => {
        const img = new Image();
        img.onload = () => fulfil();
        img.onerror = reject;
        img.src = src;
    });
}
----
// }}}

This function takes a `"src"` as an argument, and returns a "Promise".

We use the image Constructor to create a `"{fn-new_image}[new
Image(),window=_blank]"` - Object. This is
similar to doing `document.createElement("img")`.

We give it an `"onload"` - Handler, which `"fulfil"` with the image - Object,
just in case that's needed.

Then we use `"onerror"` - Handler, which is just going to reject with the
error.

Finally we apply the `"src"`, and that's going to tell the browser that we need
to go and fetch that image.

Now, inside the "Game" - Component, we can now use that.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    import { sleep, pick_random, load_image } from "../utils.js";
    ...
    ...

    const load_details = async (celeb) => {
        const res = await fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`);

        const details = await res.json();   // <<<
        await load_image(details.image);    // <<<
        return details;                     // <<<
    };

</script>
...
...
----
// }}}

First we import `"load_images"` from `"utils.js"`.

Then inside our `"load_details"` - function where we're going and getting the
JSON for each individual celebrity.

We're not going to return straight away, which is going to store that in new
variable called `"details"`.

Then we're going to wait until we've been able to load that image.

Once we've done that, we can return those `"details"`.

If we try our apps, you'll notice that there's NO flickering between rounds.
The images are there immediately, no flickering. That's a much nicer
experience.

While we're at it, we can go to our `"App.svelte"`, import the same helper like
so,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...
    import { load_image } from "./utils.js";

    ...
    ...

    onMount(() => {
        celebs_promise = load_celebs();

        load_image("/icons/right.svg");     // <<<
        load_image("/icons/wrong.svg");     // <<<
    });
</script>
...
...
----
// }}}

Once we mounted with `"onMount"` - Handler, we can just preload the icons.
Otherwise, again only load once we first get the result, which can cause that
ugly flicker.

Again we don't need to await anything here. We're just going to kick those off
in the background, so that by the time they're needed, they'll long since have
been loaded.
// }}} ===

// {{{ === Add Fly Transition to Game Element
=== Add Fly Transition to Game Element

Now we have to solve small issue. On the "Game" - Component, right mow it's just
appearing there and then it kind of gets replaced the round. What we want is
for the "Games" have a *nice subtle transition*. We try to use the "fly"
- Transition that we saw earlier when we going through the tutorial.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    import { fly } from "svelte/transition";    // <<<
    import * as eases from "svelte/easing";     // <<<
    ...
    ...
</script>

...
...

<div class="game-container">
    {#if done}
        <div class="done">
            ...
            ...
        </div>
    {:else}
        {#await promises[i] then [a, b]}
            <div
                class="game"                            // <<<
                in:fly={{ duration: 200, y: 20 }}       // <<<
                out:fly={{ duration: 200, y: -20 }}     // <<<
            >
            ...
            ...
        {/await}
    {/if}
</div>
----
// }}}

If you remember, we just need to import `"fly"` from `"svelte/transition"`. We
also going to import an `"easing"` - function or the complete set of `"easing"`
- function from `"svelte/easing"`.

Then on `<div class="game">`, we're going to apply:

- `"in:fly"` - Transition, when it comes in. We're going to come from
  `"20"` - pixels below.
- `"out:fly"` - Transition, we're going to go to `"20"` - pixels above.

But there's a little bit problem, you might have just seen that flicker there
was happening is the new round is being rendered by the old round is still
*outroing*, and that causes a little bit of upset.

//{{{ image::./images/gif/chapter-6-7.gif
[#img-chapter]
[link=./images/gif/chapter-6-7.gif,window=_blank]
.Creating a Game Screen -16
image::./images/gif/chapter-6-7.gif[align="center"]
//}}}

So we're going to make sure that doesn't happen by blocking the rendering of
the new round until the last round is fully off the screen.

That's easy enough to do by adding a new value `"let ready = true"`

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...

    let ready = true;
//  ~~~~~~~~~~~~~~~~
    ...
    ...
</script>

...
...

<div class="game-container">
    {#if done}
        <div class="done">
            ...
            ...
        </div>
    {:else if ready}
//  ~~~~~~~~~~~~~~~
        {#await promises[i] then [a, b]}
            <div
                class="game"
                in:fly={{ duration: 200, y: 20 }}
                out:fly={{ duration: 200, y: -20 }}
                on:outrostart={() => (ready = false)}   // <<<
                on:outroend={() => (ready = true)}      // <<<
            >
            ...
            ...
        {/await}
    {/if}
</div>
----
// }}}
// }}} ===

// {{{ === Cross Fade Transition
=== Cross Fade Transition

Then we need to only rendering the screen when `"ready"` is true in `"else-if"`
- block, and then setting it to `"false"` when the outro is happening.

So we can use:

- `"on:outrostart={() => (ready = false)}"`, we set `"ready"` is `"false"` once
  we start the outro.
- `"on:outroend={() => (ready = true)}"`, we set it `"ready"` back to `"true"`
  once the outro is finished.

So that will prevent from flicker happening when we start jump to new round.

Now you'll notice on the "Deployed Version" if I click the celebrity the icon
is going to `"fly-in"`, and then it's going to go down to the `"result"` block.

//{{{ image::./images/gif/chapter-6-8.gif
[#img-chapter]
[link=./images/gif/chapter-6-8.gif,window=_blank]
.Creating a Game Screen -17
image::./images/gif/chapter-6-8.gif[align="center"]
//}}}

That is an example of `"cross-fade"` - Transition, like we saw in earlier
section of this workshop. We want to add one of those.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    import { fly, crossfade } from "svelte/transition";
//                ~~~~~~~~~~

    ...
    ...

    const [send, receive] = crossfade({     // <<<
        easing: eases.cubicOut,             // <<<
        duration: 300,                      // <<<
    });                                     // <<<

    ...
    ...

    const submit = async (a, b, sign) => {
        last_result = Math.sign(a.price - b.price) === sign ? "right" : "wrong";

        await sleep(1500);

        results[i] = last_result;
        last_result = null;

        await sleep(500);
//      ~~~~~~~~~~~~~~~~

        if (i < selection.length - 1) {
            i += 1;
        } else {
            done = true;
        }
    };

</script>

...
...


{#if last_result}
    <img
        in:fly={{ duration: 200, x: 100 }}      // <<<
        out:send={{ key: i }}                   // <<<
        class="giant-result"
        alt="{last_result} answer"
        src="/icons/{last_result}.svg"
    />
{/if}

<div class="results" style="grid-template-columns: repeat({results.length}, 1fr)">
    {#each results as result, i}
        <span class="result">
            {#if result}
                <img in:receive={{ key: i }} alt="{result} answer" src="/icons/{result}.svg" />
//                   ~~~~~~~~~~~~~~~~~~~~~~~

            {/if}
        </span>
    {/each}
</div>
----
// }}}

We already import some Transition, we just going to add `"crossfade"`
- Transition as well.

We just going to create the `"send"` and `"receive"` - Transitions. We give it
some configuration `"easing: eases.cubicOut:`, and that's going to happen in
`"300"` - milliseconds.

Then we're going to take these Transitions, and we're going to apply the
`"send"` - Transition to the "Giant Image". So *get sent* to the `"results"`
- block.

Then on the `"results"` - block we're going to have the `"receive"`
- Transition.

So that's going to come from the center of the screen - down to where it
belongs.

So the Element itself is NOT moving. There's basically "two Elements",

- One is *"shrinking"* and *"fading-out"*.

- The other is *"shrinking"* and *"fading-in"*.

What we need to do is find our "Giant - Image" (`"giant-result"`), and on that
we're going to add an `in:"` - Transition on the `"giant-result"` - image,
because we want to move onto the screen and then come down.

So we're going to `"fly-in:` from `100` - pixels to the right over `"200"`
- milliseconds.

Then we set the `"out:"` - Transition, that where we're going to use `"send"`,
and we need to give it a `"key"` so that it knows what the correspond to, and
we're just going to use the "index" of the round.

Then we need to apply the corresponding `"receive"` - Transition to little
icon.

We need to have the "index" into the `"results"` - Array visible. So we are
going to add `"1"` like so, `{each results as result, i"`. It same signature
as when you're using `".map()"` and `".forEach()"` on an Array.

We add at the `"<img>"` - Elements `"in:receive={{ key: i }}"`.

//{{{ image::./images/gif/chapter-6-9.gif
[#img-chapter]
[link=./images/gif/chapter-6-9.gif,window=_blank]
.Creating a Game Screen -18
image::./images/gif/chapter-6-9.gif[align="center"]
//}}}

Last thing we need to solve a little problem here is the `"crossfade"`
- Transition wasn't applying. The reason for that is, that we're immediately
going from removing the `"results"` to advancing to the next round if you take
closely in `"submit"` - function we made.

To solve this little issue, we need to have a break for that, and I'm going to
come down into it's new place. So we're going to add inside `"submit"` function
an `"await sleep(500)"`, just give that a chance to get where it belongs.

Now we should see that comes in and goes down to the `"results"` - Array.

//{{{ image::./images/gif/chapter-6-10.gif
[#img-chapter]
[link=./images/gif/chapter-6-10.gif,window=_blank]
.Creating a Game Screen -19
image::./images/gif/chapter-6-10.gif[align="center"]
//}}}

// }}} ===

// {{{  === Add Final Transition
=== Add Final Transition

We just going to add few more Transitions, just to make things nice and slick
on the "Card" - Component.

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    import { createEventDispatcher } from "svelte";
    import { scale } from "svelte/transition";      // <<<
    import { elasticOut } from "svelte/easing";     // <<<

    export let celeb;
    export let showprice;
    export let winner;

    const dispatch = createEventDispatcher();
</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});" on:click={() => dispatch("select")}>
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
            {#if showprice}
                <div class="price" class:large={winner}>
                    <span in:scale={{ easing: elasticOut, duration: 600 }}>${celeb.price}</span>
//                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                </div>
            {/if}
        </div>
    </button>
</div>

----
// }}}

We import the `"scale"` - Transition, and we're going to use our friend
`"elasticOut"` from `"svelte/easing"`.

We're going to apply that Transitions to the `"price"`, so that when the
`"price"` is displayed, those sort of Transition come in, which is a sort of
a fun effect.


We do the same thing for the `"done"` screen.

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    ...
    ...
    import { fly, scale, crossfade } from "svelte/transition";

    ...
    ...
</script>

<div class="game-container">
    {#if done}
        <div class="done" in:scale={{ delay: 200, duration: 800, easing: eases.elasticOut }}>
//                        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            ...
            ...
        </div>
    {:else if ready}
        {#await promises[i] then [a, b]}
            ...
            ....
        {:catch}
            <p class="error">Oops! Failed to load data</p>
        {/await}
    {/if}
</div>

...
...
----
// }}}

First, we add the `"scale"` Transition.

Then we look up for Element `"class=done"`, apply the `"in:scale"`. We give it
a short `"delay:"`, a `"duration:"`, and the `"easing"` - Transition, we use
`"eases.elasticOut"` the same one for the consistency.

Now, when we click on one of the faces, the `"price"` is going to pop-out, and
that's kind of fun.

// }}} ===

Small addition, we subtle tweak in the "Card" - Component, I'm going add
`"border-radius"` using variable that set up in our `"global.css"` and ad
a nice little `"box-shadow"`.

// {{{ Card.svelte
[source, html]
----
...
...
<style>
	.card-outer {
		width: 100%;
		height: 100%;
	}
	.card-inner {
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 100%;
		background: 50% 50% no-repeat;
		background-position: 50% 0;
		background-size: cover;
		border-radius: var(--border-radius);        // <<<
		box-shadow: 2px 4px 6px rgba(0,0,0,0.2);    // <<<
		overflow: hidden;
		padding: 0;
		text-align: left;
  }
  ...
  ...
</style>
----
// }}}

That is basically everything in the Game itself. All that remains is to do
a lighthouse audit and see what it suggests.
// }}}
