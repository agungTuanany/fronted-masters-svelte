//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun May  2 05:37:14 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_3_binding_and_lifecycle]]
== Chapter 3 Binding And Lifecycle

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_input_template_binding[Input & Template Binding]
| 2.    | xref:_media_dimension_binding[Media & Dimension Binding]
| 3.    | xref:_this_component_binding[This & Component Binding]
|====
//}}}

// {{{ 1 == Input & Template Binding
[[_input_template_binding]]
== Input & Template Binding

//{{{ image::./images/chapter-2-1.png
[#img-chapter]
[link=./images/chapter-3-1.png,window=_blank]
.Svelte Binding & Lifecyle -1
image::./images/chapter-3-1.png[align="center"]
//}}}

So now we're going to move on to the "Binding - Section" of the tutorial, and
as general rule data-flow in Svelte as we've seen goes from *"Parent"* - Component
to the *"Child"* - Component.

In other words, it goes TOP - DOWN.

Some times we need to BREAK that rule. Sometimes we want to get information
from an Element or Component back up to its Parent and this is very common when
we're dealing with "form" - Elements, for example.

=== Bindings / Text Inputs

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input value={name}>

<h1>Hello {name}!</h1>
----
// }}}

So, here's  an `"<input>"` - Element. Doesn't currently doing anything.

But what we want to happen is, for the changes in that `"<input>"` - Element to
be reflected in the State of of the Component.

There is one way that we could do this using Events.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input on:input={handleInput} value={name}>
//     ~~~~~~~~~~~~~~~~~~~~~

<h1>Hello {name}!</h1>
----
// }}}

Then we could add Event - Handler and do all of the still that you would
normally do. But it's a little bit *inconvenient*.

Instead in Svelte we can just turn this "Prop" `"value={name}"`, and this
attribute into a "binding" with the "bind - directive" `"bind:value={name}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let name = 'world';
</script>

<input bind:value={name}>
//     ~~~~

<h1>Hello {name}!</h1>
----
// }}}

Now, whenever the value of the `"<input>"` - Element changes, the value also
changed.

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Media Dimension Binding
[[_media_dimension_binding]]
== Media & Dimension Binding
:fn-media_element_binding: link:https://svelte.dev/docs#Media_element_bindings

Another type of binding that might no be obvious because it's not a `"<form>"`
- Element is, the Media- Element Binding, and there's a bunch of different
Media Element Bindings.

Media elements (<audio> and <video>) have their own set of bindings — six
readonly ones...

- duration (readonly) — the total duration of the video, in seconds
- buffered (readonly) — an array of {start, end} objects
- played (readonly) — ditto
- seekable (readonly) — ditto
- seeking (readonly) — boolean
- ended (readonly) — boolean

...and five two-way bindings:

- currentTime — the current playback time in the video, in seconds
- playbackRate — how fast or slow to play the video, where 1 is 'normal'
- paused — this one should be self-explanatory
- volume — a value between 0 and 1
- muted — a boolean value where true is muted

Videos additionally have *readonly* `"videoWidth"` and `"videoHeight"`
bindings.

All of this things can be added to a Media Element Binding.

It was quite a lot of markup in this tutorial. So if you want to dive into it,
then have a look at this in your own time.

But for now we I want you all see what this actually look like, once we've
added All of the bindings to this `"<videos>"` - Element.

// {{{ App.svlete
[source, html]
----
<script>
    // These values are bound to properties of the video
    let time = 0;
    let duration;
    let paused = true;

    let showControls = true;
    let showControlsTimeout;

    function handleMousemove(e) {
        // {{{
        // Make the controls visible, but fade out after
        // 2.5 seconds of inactivity
        clearTimeout(showControlsTimeout);
        showControlsTimeout = setTimeout(() => showControls = false, 2500);
        showControls = true;

        if (!(e.buttons & 1)) return; // mouse not down
        if (!duration) return; // video not loaded yet

        const { left, right } = this.getBoundingClientRect();
        time = duration * (e.clientX - left) / (right - left);
    } // }}}

    function handleMousedown(e) {
        // {{{
        // we can't rely on the built-in click event, because it fires
        // after a drag — we have to listen for clicks ourselves

        function handleMouseup() {
            if (paused) e.target.play();
            else e.target.pause();
            cancel();
        }

        function cancel() {
            e.target.removeEventListener('mouseup', handleMouseup);
        }

        e.target.addEventListener('mouseup', handleMouseup);

        setTimeout(cancel, 200);
    } // }}}

    function format(seconds) {
        // {{{
        if (isNaN(seconds)) return '...';

        const minutes = Math.floor(seconds / 60);
        seconds = Math.floor(seconds % 60);
        if (seconds < 10) seconds = '0' + seconds;

        return `${minutes}:${seconds}`;
    } // }}}
</script>

<h1>Caminandes: Llamigos</h1>
<p>From <a href="https://cloud.blender.org/open-projects">Blender Open Projects</a>. CC-BY</p>

<div>
    <video
        poster="https://sveltejs.github.io/assets/caminandes-llamigos.jpg"
        src="https://sveltejs.github.io/assets/caminandes-llamigos.mp4"
        on:mousemove={handleMousemove}
        on:mousedown={handleMousedown}
        bind:currentTime={time}
        bind:duration
        bind:paused>
        <track kind="captions">
    </video>

    <div class="controls" style="opacity: {duration && showControls ? 1 : 0}">
        <progress value="{(time / duration) || 0}"/>

        <div class="info">
            <span class="time">{format(time)}</span>
            <span>click anywhere to {paused ? 'play' : 'pause'} / drag to seek</span>
            <span class="time">{format(duration)}</span>
        </div>
    </div>
</div>

<style>
    /*{{{*/
    div {
        position: relative;
    }

    .controls {
        position: absolute;
        top: 0;
        width: 100%;
        transition: opacity 1s;
    }

    .info {
        display: flex;
        width: 100%;
        justify-content: space-between;
    }

    span {
        padding: 0.2em 0.5em;
        color: white;
        font-size: 1.4em;
        text-shadow: 0 0 8px black;
        opacity: 0.7;
    }

    .time {
        width: 3em;
    }

    .time:last-child { text-align: right }

    progress {
        display: block;
        width: 100%;
        height: 10px;
        -webkit-appearance: none;
        appearance: none;
    }

    progress::-webkit-progress-bar {
        background-color: rgba(0,0,0,0.2);
    }

    progress::-webkit-progress-value {
        background-color: rgba(255,255,255,0.6);
    }

    video {
        width: 100%;
    }
    /*}}}*/
</style>
----
// }}}

As you can see from the code above, we bind into the `currentTime`, we bind
into the `duration`, we bind to the `pause` - State; and we're using those to
build the "video player" - UI.

I can click anywhere and the video will start. I can drag, rewind, and click
the pause.

Now, nice thing about the Media Element Bindings is, they're not just using
Native - DOM - Events. They're actually using
`"Window.requestAnimationFrame()"` where applicable. So that the current time
is updated 60 times a second.

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 3 == This & Component Binding
[[_this_component_binding]]
== This & Component Binding

We also have `"this"` - binding, which is a way of getting a *reference* to an
Element inside of your Component.

If you've used `"refs"` in ReactJS, this is similar concept.

=== Binding / This

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onMount } from 'svelte';

    let canvas;

    onMount(() => {
        const ctx = canvas.getContext('2d');
        let frame = requestAnimationFrame(loop);

        function loop(t) {
        frame = requestAnimationFrame(loop);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        for (let p = 0; p < imageData.data.length; p += 4) {
            const i = p / 4;
            const x = i % canvas.width;
            const y = i / canvas.height >>> 0;

            const r = 64 + (128 * x / canvas.width) + (64 * Math.sin(t / 1000));
            const g = 64 + (128 * y / canvas.height) + (64 * Math.cos(t / 1000));
            const b = 128;

            imageData.data[p + 0] = r;
            imageData.data[p + 1] = g;
            imageData.data[p + 2] = b;
            imageData.data[p + 3] = 255;
        }

        ctx.putImageData(imageData, 0, 0);
        }

        return () => {
            cancelAnimationFrame(frame);
        };
    });
</script>

<canvas
    width={32}
    height={32}
></canvas>

<style>
    canvas {
        width: 100%;
        height: 100%;
        background-color: #666;
        -webkit-mask: url(svelte-logo-mask.svg) 50% 50% no-repeat;
        mask: url(svelte-logo-mask.svg) 50% 50% no-repeat;
    }
</style>
----
// }}}

So, here we have a `"<canvas>"` - Element; and when Component is rendered, we
want to paint to that "canvas". Which means that we need to get
a reference to the "canvas" so that we can get a reference to the "canvases
- context".

Up here, a value `"let canvas"`.

Then once the Component is *mounted*, using the `"onMount()"` - callback, which
we'll come to later.

We creating the "canvas - context" using `"cavas.getContext('2d')"`.

If you haven't used "canvas - programming:, and this is NOT familiar, don't
worry. It's more straightforward that it looks. But we're not tog et into it
during this course.

So, just roll with it for now.

All we need to do to make this works is, populate this value ('"canvas"`), by
adding `"bind:this={}"`. to the `"<canvas>"` - Element.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...
<canvas
    bind:this={canvas}
//  ~~~~~~~~~~~~~~~~~
    width={32}
    height={32}
></canvas>
----
// }}}

So now we have a nice animated Canvas inside our Component.

Now I know about the order in which everything happens here. So the
`"<script>"` - tag executes first before any content is actually rendered.
Because very often what happens inside the `"<script>"` - tag Element
*determines* what is going to get rendered.

So, because of that, there's no way this `"let canvas"` can have a value until
later.

So, the `"onMount()"` - callback is the first time that you're able to access
the value of any Element with a "bind:this"  - directive.

=== Bindings / Component Bindings

So far, we've only looked at the Element  - Bindings. But Components can also
have "bindings".

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Keypad from './Keypad.svelte';

    let pin;
    $: view = pin ? pin.replace(/\d(?!$)/g, '•') : 'enter your pin';

    function handleSubmit() {
        alert(`submitted ${pin}`);
    }
</script>

<h1 style="color: {pin ? '#333' : '#ccc'}">{view}</h1>

<Keypad on:submit={handleSubmit}/>
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
----
// }}}

So here we have Component called `"Keypad.svelte"`, which is basically a custom
"Form  - Element". You can think of it that way.

What we want to do is, get the value of what been entered into the keypad into
the Component that is using it. So that we can submit for example, a "PIN
- Number"

// {{{ Keypad.svelte
[source, html]
----
<script>
    import { createEventDispatcher } from 'svelte';

    export let value = '';

    const dispatch = createEventDispatcher();

    const select = num => () => value += num;
    const clear  = () => value = '';
    const submit = () => dispatch('submit');
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

<div class="keypad">
    <button on:click={select(1)}>1</button>
    <button on:click={select(2)}>2</button>
    <button on:click={select(3)}>3</button>
    <button on:click={select(4)}>4</button>
    <button on:click={select(5)}>5</button>
    <button on:click={select(6)}>6</button>
    <button on:click={select(7)}>7</button>
    <button on:click={select(8)}>8</button>
    <button on:click={select(9)}>9</button>

    <button disabled={!value} on:click={clear}>clear</button>
    <button on:click={select(0)}>0</button>
    <button disabled={!value} on:click={submit}>submit</button>
</div>

<style>
    .keypad {
        display: grid;
        grid-template-columns: repeat(3, 5em);
        grid-template-rows: repeat(4, 3em);
        grid-gap: 0.5em
    }

    button {
        margin: 0
    }
</style>
----
// }}}

So inside the `"keypad.svelte"` - Component, we've created an "Event
- Dispatcher"

Then we have a `"submit"` - event that happens when you click on the "submit"
- button.

But the value itself, we don't have any Events for that. That is going to be
handled through the Binding.

It's just like using the "text" - input, we do `"bind:value={pin}"`. Then the
right hand side, we give the "name" of the variable that it should be bound to.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...
<Keypad bind:value={pin} on:submit={handleSubmit}/>
//      ~~~~~~~~~~~~~~~
----
// }}}

That's it. You've know how to Bind the Component.

**⬆xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc
