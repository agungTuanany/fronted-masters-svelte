//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 6
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sat May  8 09:11:13 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_6_building_a_game]]
= Chapter-6 Building A Game

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_preparation[Preparation]
| 2.    | xref:_creating_the_game_Screen[Creating The Game Screen]
| 3.    | xref:_game_layout_button[Game Layout & Button]
|====
//}}}

// {{{ 1 == Preparation
[[_preparation]]
== Preparation
:fn-cameo_com: link:http://cameo.com/
:fn-cameoparison: link:https://cameoparison.netlify.app/
:fn-cameo_explorer: link:https://cameo-explorer.netlify.app/celebs

//{{{ image::./images/chapter-6-1.png
[#img-chapter]
[link=./images/chapter-6-1.png,window=_blank]
.Building a Game
image::./images/chapter-6-1.png[align="center"]
//}}}

Time to move onto the fun stuff. We're going to make a game using data from
{fn-cameo_com}[cameo.com,window=_blank], an amazing website that lets you pay
celebrities to record 30 second personalised videos. You can get the "Insane
Clown Posse" to roast your friends or wish your spouse a happy anniversary.

The game is called {fn-cameoparison}[CameoParison,window=_blank], and the goal
is to guess which celebrities are expensive, and which ones are cheap. Since
there's no official API, we'll grab data from
{fn-cameo_explorer}[cameo-explorer.netlify.app,window=_blank], which contains
a scraped snapshot of some of the top celebs.

We'll start by cloning the starter repo:

// {{{ $ git clone git@github.com:Rich-Harris/cameoparison-starter.git
[source, bash]
----
$ git clone git@github.com:Rich-Harris/cameoparison-starter.git
----
// }}}

This is almost identical to the default project template, with the addition of
a couple of image files and some extra `"src"` modules to save time later.

It also has several *branches* that you can check out if you get stuck following
the course and need to get back on track:

- checkpoint-1
- checkpoint-2
- checkpoint-3
- complete

As you follow along, make your changes in the master branch.
// }}}

// {{{ 2  == Creating The Game Screen
[[_creating_the_game_Screen]]
== Creating The Game Screen

All right, so the first order of business is going to be create a "Game
- Screen" - Component, similar to "Welcome - Screen" - Component.

We create a new file Component named `"Game.svelte"` in `"/src/screens/"`.

Then we'll import that inside `"App.svelte"`, the same way that we imported our
"Welcome" - Component.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onMount } from "svelte";

    import Welcome from "./screens/Welcome.svelte";
    import Game from "./screens/Game.svelte";
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    import { select } from "./select";

    ....
    ....
</script>
----
// }}}

Then inside the `<main>` - placeholder, we're going to instantiate the "Game"
- Component,

// {{{ App.svelte
[source, html]
----
// App.svelte
</script>
    ...
    ...
<script>

<main>
    {#if state === "welcome"}
        <Welcome on:select={start} />
    {:else}
        <Game {selection} />
//      ~~~~~~~~~~~~~~~~~~~~
    {/if}
</main>
----
// }}}

We're going to pass through the `"selection"`, because that's what the game is
going to use, to actually render the quiz.

So, we open our new Component we make which is `"Game.svelte"`,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;
    console.log(selection);
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    <p>game will go here</p>
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }
</style>
----
// }}}

The first thing we need to do in our "Game" - Component is to make that
`"selection"` - "Prop" available, by doing `"export let selection"`.

I'm going to verify that is getting passed through correctly by logging it
`"console.log(selection)"`.

Then, once again we're just going to rip off some mock-up the one that we made
earlier.

Then the rest is just going to be placeholder stuff. We're going to make an
element that contain the game, `class="game-container"`.

Finally we're going to create that little row of result at the bottom,
`"class="results"`.

Right now everything is getting squeezed into the middle of the screen.

//{{{ image::./images/chapter-6-2.png
[#img-chapter]
[link=./images/chapter-6-2.png,window=_blank]
.Creating a Game Screen -1
image::./images/chapter-6-2.png[align="center"]
//}}}

We want the "Game" - Container to fill as much spaces possible, and then for
the `"<header>"` and the `"results"` to just occupy the "top" and "bottom".

We add the CSS - Style to `"game-container"` - Class to have a `"flex:"` with
value of `"1"`.

Than will make it stretch to occupy as much space as it can.

//{{{ image::./images/chapter-6-3.png
[#img-chapter]
[link=./images/chapter-6-3.png,window=_blank]
.Creating a Game Screen -2
image::./images/chapter-6-3.png[align="center"]
//}}}

So the "Game" - Container as you can see, is occupying most of the screen.

Now, if you look at the `"selection"` - Object that is being passed in as
a "Prop", we can see the *Data -Structure* that we've got to work with.

//{{{ image::./images/chapter-6-4.png
[#img-chapter]
[link=./images/chapter-6-4.png,window=_blank]
.Creating a Game Screen -3
image::./images/chapter-6-4.png[align="center"]
//}}}

As we can see, mos of the stuff that we need is there. We've got `"names"`,
we've got `"prices"`, we've got all of that.

*BUT* we do NOT have the `"image"` that belongs to each of these celebrities.

For that, we're going to need to go back to the API, and we're going to need to
load some more data for each of these.

That essentially means we're going to need to create a bunch of "Promises" that
presenting the result of loading that data.

Let's add some code into "Game" -Component,

// {{{ Game.svelte
[source, html]
----
// Game.svelte
<script>
    export let selection;

    const load_details = async (celeb) => {
        const res = await fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`);
        return await res.json();
    };
    const promises = selection.map(round => Promise.all([
        load_details(round.a),
        load_details(round.b)
    ]));
	let i = 0;
</script>

<header>
    <p>Tap on the more monetisable celebrity's face, or tap 'same price' if society values them equally.</p>
</header>

<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                {a.name}
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                {b.name}
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>

<div class="results">
    <p>results will go here</p>
</div>

<style>
    .game-container {
        flex: 1;
    }

    .error {
        color: red;
    }
</style>
----
// }}}

So let's do `"const promises = selection.map()"`, and then for each of those
Objects that we just looked at with `"Promise.all()"`.

We're going to load some details "a" - property (`load_details(round.a)`),
and "b" - property (`load_details(round,b)`)

So right now, we just need to implement `"load_details"`.

We just going to grab the URL again
`https://cameo-explorer.netlify.app/celebs/`

//{{{ image::./images/chapter-6-5.pn
[#img-chapter]
[link=./images/chapter-6-5.png,window=_blank]
.Creating a Game Screen -4
image::./images/chapter-6-5.png[align="center"]
//}}}

So each of these `"celebs"` has "JSON" that we can inspect. Which contains all
of the same information as before plus `*"description"*` and plus the `*"image"*`.

We grab that - URL and then just replace the "celebs - name" with the *ID* of the
*Celeb* that we care about,
(`fetch(`https://cameo-explorer.netlify.app/celebs/${celeb.id}.json`)`)

Then, we just going to return the "JSON" for that response, `return await
res.json()`.

So, that's going to give this bunch of different Promises that represent the
full detail of the celebrities whose have faces (images) we are going to
include in our game.

Now dealing with *"asynchronous" - Object* in *templating languages* has been
a little bit awkward. But Svelte has a *first-class* way of showing "Promises"
in your Component that we looked at earlier, and it's called the *"await"*
- block.

We're going to use one of those here, we're going to do `"{#await something}"`. Then
we're going to have an Array of "a" and "b", because that's what's getting in
return from (`" const promises"`) an Array.

By the way, I'm actually using a shorthand here.

// {{{  {#await something}
[source, html]
----
// Game.svelte
{#await something}
    <p>pending block</p>

{:then value}
    <p>{value}</p>

{/await}
----
// }}}

Before we had a `"await something"`, and then we would have a `"pending
block"`, then you would have `{:then}` - clause.

In cases like above, where we actually *don't want to show anything*, while
*`"pending"` is still the case*, we can shortcut this with `{# await something
then [value]}`, and also we can use `destructuring`.

Then inside `await` - clause, we're going to create the `"game"` - Element it
itself by creating a Class, (`<div class= "game">`)

We're going to have a "card" for the two celebrities images,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>
        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

Okay, on the final version of the game, you can see that as well as having
celebrity `"a"`, and celebrity `"b"`, we have a *button* in the middle that
you're supposed to press, when you're think that they're charging exactly the
same price.

//{{{ image::./images/chapter-6-6.png
[#img-chapter]
[link=./images/chapter-6-6.png,window=_blank]
.Creating a Game Screen -5
image::./images/chapter-6-6.png[align="center"]
//}}}

So we are going to add that button to our markup as well. We just put a little
`<div>` in there, and inside we're going to have a `"<button>"` - Element wit
a Class `"same"`, amd then we put the word `'same price"`, to be like


// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{/await}
----
// }}}

In some cases like as we've seen, it's possible that there would be an error.
So we use the `"{:catch}"` - clause, we put an error message, then we just
print a message `Failed to load data`, in `"<p>"` - Element, to be like so,

// {{{ {#await something then [a, b]}
[source, html]
----
// Game.svelte
{#await something then [a, b]}
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

Then we just add some CSS - style for class - `".error{ color: red }"`

Okay, so what we'll do now is, to figure out what `"something"` should be.

So we have an Array of `"const promises"`, and we're going to step through them
one at the time, and the easiest way to do that would be to just have a value
that represent the *"current - index"* into those `"promises"`

So let's create a new value, `"let i = 0"`, and I'm just take that ip as we go
through the `"rounds"`, and we replace `"something"` with `"promises[i]"`, like
so,

// {{{ {#await promises[i] then [a, b]}
[source, html]
----
// Game.svelte
{#await promises[i] then [a, b]}
//      ~~~~~~~~~~~
    <div class="game">
        <div class="card-container">
            {a.name}
        <div>

        <div class="same">
            same price
        </div>

        <div class="card-container">
            {b.name}
        <div>
    </div>
{:catch}
    <p class="error">Oops! Failed to load data</p>
{/await}
----
// }}}

If we go over to our application, we can see that it is indeed picking out two
- celebrities, and rendering some game UI for those.

//{{{ image::./images/chapter-6-7.png
[#img-chapter]
[link=./images/chapter-6-7.png,window=_blank]
.Creating a Game Screen -6
image::./images/chapter-6-7.png[align="center"]
//}}}

// }}}

// {{{ == Game Layout & Button
[[_game_layout_button]]
== Game Layout & Button

Okay, so it's time to start building the UI a little bit further. We're going
to create some "Cards" for the celebrities, and then use those in the "Game"
- Component.

That means we're going to create a new - Component. That's not a screen, but is
a separate Component. So I'm going to create a new directory inside our
`"source/`, called `"src/components"`. I'm going to create a Component called
`"Card.svelte"`.

Then inside the `"Game.svelte"` - Component, I'm going to import that new
component.

// {{{ Game.svelte
[source, html]
----
<script>
    import Game from "../components/Game.svelte";
    ...
    ...
<script>
...
...
<div class="game-container">
    {#await promises[i] then [a, b]}
        <div class="game">
            <div class="card-container">
                <Card celeb="[a}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>

            <div>
                <button class="same"> same price </button>
            </div>

            <div class="card-container">
                <Card celeb="[b}" />
//              ~~~~~~~~~~~~~~~~~~~
            </div>
        </div>
    {:catch}
        <p class="error">Oops! Failed to load data</p>
    {/await}
</div>
----
// }}}

[NOTE]
There's really, no, sort of conventions about how you organize your Components.
I put this i a separate Components - Folder, but you could also put in next to
the `"Game.svelte"` - Component. It's really up to your personal preference,.


Then we're just going to replace these `{a.name}` with `"<Card celeb={a} /">`, and
then same down here `"<Card celeb={b} />"`, as like so,

So, let's flash out the layout a little bit of our main "Game" - Component. We
give more CSS - Style.

// {{{ Game.svelte
[source, diff]
----
// Game.svelte
<script>
...
</script>
...
...
<div class="game-container">
...
...
</div>

<style>
     .game-container {
         flex: 1;
     }

+    .game {
+        display: grid;
+        grid-template-rows: 1fr 2em 1fr;
+        grid-gap: 0.5em;
+        width: 100%;
+        height: 100%;
+        max-width: min(100%, 40vh);
+        margin: 0 auto;
+    }
+    .game > div {
+        display: flex;
+        align-items: center;
+    }
+    .same {
+        width: 100%;
+        align-items: center;
+        margin: 0;
+    }
+    .game .card-container button {
+        width: 100%;
+        height: 100%;
+        padding: 0;
+        margin: 0;
+    }
+
     .error {
         color: red;
     }
+
+    @media (min-width: 640px) {
+        .game {
+            max-width: 100%;
+            grid-template-rows: none;
+            grid-template-columns: 1fr 8em 1fr;
+            /* work around apparent safari flex bug */
+            max-height: calc(100vh - 6em);
+        }
+        .same {
+            height: 8em;
+        }
+    }
</style>
----
// }}}

Next, let's go over to the "Card" - Box whole Component and start implementing
that,

// {{{ Card.svelte
[source, html]
----
// Card.svelte
<script>
    import { createEventDispatcher } from "svelte";

    export let celeb;

    const dispatch = createEventDispatcher();
</script>

<div class="card-outer">
    <button class="card-inner" style="background-image: url({celeb.image});" on:click={() => dispatch("select")}>
        <div class="details">
            <h2><a target="_blank" href="https://cameo.com/{celeb.id}">{celeb.name}</a></h2>

            <p class="type">{celeb.type}</p>
        </div>
    </button>
</div>

<style>
    .card-outer {
        width: 100%;
        height: 100%;
    }

    .card-inner {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: 50% 50% no-repeat;
        background-position: 50% 0;
        background-size: cover;
        overflow: hidden;
        padding: 0;
        text-align: left;
    }

    .details {
        position: absolute;
        width: 100%;
        bottom: 0;
        padding: 1em 0.5em 0.5em 0.5em;
        background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.6) 35%, rgba(0, 0, 0, 0.9));
        color: white;
    }

    h2 {
        margin: 0 0 0.2em 0;
    }

    .type {
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    @media (min-width: 640px) {
        .card-outer {
            height: 0;
            padding: 0 0 100% 0;
        }
    }
</style>
----
// }}}

We're going to create an element to contain everything call that
`"card-outer"`, and inside there, we're going to create a "_button_"

The reason I'm using the button is, because these are *interactive* Elements.
So things that the user is supposed to click-on, and the nice thing using
buttons is, we get a lot of accessibility properties for free.

So right now, in {fn-cameoparison}[deployed site,window=_blank], if someone who
used the keyboard instead the mouse for whatever accessibility reason, I might
have, I can press `tab` - key, and it will take me between the Elements on the
page.

//{{{ image::./images/gif/chapter-6-1.gif
[#img-chapter]
[link=./images/gif/chapter-6-1.gif,window=_blank]
.Creating a Game Screen -8
image::./images/gif/chapter-6-1.gif[align="center"]
//}}}

So, we're going to use button in all three cases where both the celebrities and
the `"same price"` thing in as the middle button.

We create button - with Class name `"card-inner"`.

The button is going to have the background image that corresponds to the
"celebrity image". We use "inline style" `style="background-image:
url({celeb.image});"`.

Then inside there, we're going to have these `"details"` - Elements.

We left the static markup that specific to celebrity, with the properties of
our celebrity Object `"href="https://cameo.com/{celeb.id}"` and `{celeb.name}`,
and `{celeb.type}`.

Then we add some style. You can read above, because our course specific to
Svelte.
//}}}
