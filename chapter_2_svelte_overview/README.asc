//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr 25 08:30:26 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_2_svelte_overview]]
= Chapter-2 Svelte overview

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_why_svelte[Why Svelte]
| 2.    | xref:_svelte_basics[Svelte Basic]
|====
//}}}

// {{{ 1 == Why Svelte
[[_why_svelte]]
== Why Svelte
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead
:fn-write_less_code: https://svelte.dev/blog/write-less-code
:fn-svelte_is_compiler: https://svelte.dev/blog/frameworks-without-the-framework

So the obviousness question that a lot of people have is,  *what is Svelte*?

Exactly a lot of different ways to answer that question.

It's a lot of different things,  but it's probably easiest to understand it is
as an *alternative* to other existing projects that you're familiar with,  "React"
and "Vue" of the two most popular "*Component* - frameworks",  and Svelte
essentially solved a similar problem that
they do.

So,  what is a "Component - framework? Component Frameworks exist to help you
write applications more *declaratively*.

We use that word declare Actively a lot in programming. So it's helpful to
understand exactly what we mean by that.

This declarative code that I'm looking at here.

//{{{ svelte - example
[source,  html]
----
// svelte - example
<script>
    let count = 0;
</script>

<button on:click={() => count += 1}>
    Clicks: {count}
</button>
----
//}}}

This is some Svelte code is roughly equivalent to the vanilla JavaScript
beneath it.

//{{{ vanillaJS - example
[source, javascript]
----
// vanillaJS - example
function component() {
    let count = 0;

    const button = document.createElement('button');
    button.textContent = `Clicks: ${count}`;

    button.addEventListener('click',  () => {
            count += 1;
            button.textContent = `Clicks: ${count}`;
            });

    return button;
}
----
//}}}

You can see what's happening with creating a button using
`document.createElement()` and then we're putting some text inside it.

Then adding an "Event Listener" to,  when you click the button,  it increments
the value of `"count"` and then it updates the `"textContent"` inside the
button.

Then we return that. That's our component.

So the difference is in the *"imperative"* - version with telling the browser
exactly what to do.

In the *"declarative"* - version. We're just saying what outcome we want; And
that's obviously a lot simpler for the developer,  because we're not having to
work through the process of explaining to the browser exactly what it needs to
do each given moment.

More to the point. There's no duplication. Here We've got this initial
`"button.textcontent"` equals "blah"; and then inside the "update Handler",
we've got the same thing.

You tend to find that when you're building web applications,  you have a lot of
that kind of *duplication*. You have the "initial render" and then you have the
"update".

But if you're doing things declaratively,  that's no longer the case.

But it gets worse for the *"imperative"* story. If you want to make a very
small change to your component. For example,  you want to wrap that `"count"` -
variable in a *strong element*. Then if you're doing it,  imperatively,  you need
to almost rewrite the entire component. That's for a very small change.

So you can imagine,  if you're building a large application,  the amount of work
that you would have to do is,  you're *iterating on your design* is much - much
greater with *"imperative'* - code.


So that's the value that component framework provide. They make it a lot easier
for us as developers to build applications.

Historically,  though there has been a little bit of an implicit "trade-off".
Because the framework acts as a *middleman* between you and the browser. With
the middleman introduces inefficiency.

=== How is Svelte Different?

So,  Svelte began back in 2016. Is an experiment to prove that is,  in fact,  a
*"FALSE - DICHOTOMY"*. There is no tension between *"developer - experience"*,
and *"user - experience"*.

Svelte is a *COMPILER*. It takes your *"declarative"* - code and it turns it
into the equivalent *"imperative"* - JavaScript.

Then this has a number of really useful advantages.

- First. Your apps will *generally be quite a lot smaller*.

Because we don't need to have the *actual framework runtime* in the browser.
Normally, the framework has to anticipate every possible use case,  but because
Svelte understands exactly what is going into your app. It can discard most of
it in just ship the code that is actually needed for your specific use case.

JavaScript is the most expensive thing on the web bite for bite. Because you
don't just have to download it. You also have to pause and evaluate it,  and so
if we can use less of it than your apps are going to launch quicker and your
users will be happier.

- Second. You apps will be *Faster*.

Once your applications have already launched,  your apps are going to be faster.
Because we don't need to use costly techniques like *"re-rendering"* the
{fn-virtual_dom}["virtual Dom"] and then dipping it to find out what needs to
change on the page.

Instead,  we can make surgical granular updates. The compiler knows which bits
of the application could change for a given "State" - change,  and it can just
change the "Dom" directly the same way that you would do,  if you using the "Dom
- API" manually.

- Finally,  Your app will be *easier to write*.

Because we have a lot more control over the *"authoring"* - experience. We
don't have the same constraints that are the people do. What this means in
particular,  is that if you're using Svelte,  you will be able to write less
code.


There's a blog post link there that I invite you to check out which explains
why {fn-write_less_code}[writing less code] is so important.  Writing less
code,  means that you'll have fewer *"bugs"* and to be able to spend more time
Outdoors.

Beyond that Svelte aims to make your life easier by shipping a lot of the
things that normally you would have to do as third party liability would
install from "NPM".

So things like *"State - management"*,  *"Element - transitions"*,  *"handling
input"* via "Form" - elements,  scope - CSS. All of those things. Normally with
a framework,  those are things that you have to figure out a solution to
yourself.

But was Svelte,  it's already *built in*,  and we can do that because again,
{fn-svelte_is_compiler}[*we're a "compiler"*],  we can discard the bits that
we're not using.

=== Who Make Svelte?

Well,  it is very much a *community project*.

It's not a project with full-time engineers and corporate funding. It's a
project that is developed in the open by a group of volunteers who work on it,
in their free time. Because we believe in the project.

There is a core team of developers who do the day-to-day stuff,  but the broader
contributor Community is large,  and every decision that we make about,  the
future of the framework is done to the greatest extent possible out in the
open.

Egalitarians,  Communitarian project. We welcome developers of all backgrounds
and with all skill levels,  and we would love for you to be involved as well.

So with that,  I'm going to move on to the next part of the workshop where we're
going to run through the entire Svelte tutorial to learn how to build stock
components.

**â¬†xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Svelte Basics
[[_svelte_basics]]
== Svelte Basics
:fn-svelte_dev_tutorial: https://Svelte.dev/tutorial/basic
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead


Okay. So in this section, we're going to go through the entire "interactors" Svelte
tutorial. By the end of it, you'll have a complete grasp of what's Svelte
can do and how you're right Svelte Component.

So what I invite you to do is in a new tab in you browser, go to
{fn-svelte_dev_tutorial}[Svelte-tutorial,window=_blank] and we're just going to
go through the whole thing top to bottom, Soup To Nuts.

Now, this has some introductory Spiel that I've already basically explained. So
I'm going to just go down there and click on the next button. And we'll begin
with our "Hello world!" - Component.

=== Adding Data

//{{{ image::./images/chapter-2-1.png
[#img-chapter]
[link=./images/chapter-2-1.png,window=_blank]
.Svelte Basic -1
image::./images/chapter-2-1.png[align="center"]
//}}}

So the first thing that you'll notice is that we're writing
HTML into this window here, this `"app.svelte"` - window.

The reason that we use *"HTML"* is our base
language instead of JavaScript is, HTML is *designed to contain* CSS and
JavaScript. So all of the three languages of the web, they all fit together in
Svelte - Component in a very idiomatic way.

//{{{ <h1>Hello World!<h1>
[source, html]
----
<script>
    let name = 'world';
</script>

<h1>Hello {name}!</h1>
----
//}}}

The first thing that we need to do is
*add some data*, so going to create a script tag, Up here; and then we're going to
create a variable, call it `"name"`,  and we'll just give it a value `"world"` like that.

Then inside the *markup*, we can refer to that value by putting it inside
curly braces `"{}"`. Like so.

Now, inside these curly braces (`"{name}"`), we can have any valid
JavaScript. So we can change that to `"{name.toUpperCase}"`, for example.

//{{{ image::./images/chapter-2-1.gif
[#img-chapter]
[link=./images/gif/chapter-2-1.gif,window=_blank]
.Svelte Basic -2
image::./images/gif/chapter-2-1.gif[align="center"]
//}}}

Then obviously as we change that It will re-render the application.

//{{{ image::./images/chapter-2-2.png
[#img-chapter]
[link=./images/chapter-2-2.png,window=_blank]
.Svelte Basic -3
image::./images/chapter-2-2.png[align="center"]
//}}}

By the way, if you ever get stuck, while going through these tutorials and you
want to just skip to the end to the end result, then you can click on the
`"Show Me"` - button down here, and it will take you straight to the end State
and then you can click reset back to the beginning.

=== Dynamic Attribute

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img src={src}>
//   ~~~~~~~~
----
//}}}

Now,   in the same way that we can use curly braces
to put text inside our application, we can use it inside Element - attributes.

So our `"<image>"` - tag here is missing a source attribute (`"<src="">"`). Add
one like that and give it the value of `"src={src}"`,  which is in the script
block.

//{{{ image::./images/chapter-2-3.png
[#img-chapter]
[link=./images/chapter-2-3.png,window=_blank]
.Svelte Basic -3
image::./images/chapter-2-3.png[align="center"]
//}}}

This orange bar beneath
beneath. The mark-up is telling us that an image element should have an `alt=""`
- attribute and this is really important, this is an *accessibility* matter.

Most
people, when they're using a website, they can see the content of the image and
they don't need an `alt=""` attribute.

But there are a lot of users for whom that's not true. That includes people
with impaired Vision who are using assistive Technologies like screen readers.

But it also includes people who are on a slow connection and they've got the
marker but it hasn't yet been able to load the content of the image. So it's
very important that we *always add* an `alt=""` - attribute to *describe* what
is in the image.

So, in this case, `alt="A man dances"`.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img alt="A man dances" src={src}>
----
//}}}

Now accessibility is a *big* and *difficult* topic and there's no way that a
framework likes Svelte can automatically check that you are writing accessible
markup in every case.

For example, this `alt=""` - tag could be absolute gibberish, and it
wouldn't know any better.

So you do have to understand the purpose of the
"accessibility" - *warnings* and make sure that you are actually building accessible
markup, and that includes things like making sure that the "contrast ratio" on the
content that you're building a high enough.

But Svelte will do the best that it can to make sure that you're not making any
*obvious mistakes*, like *putting markup* that's *inaccessible* on the page.

Now, we can also use the curly braces inside, attributes.  So,  let's say we
wanted to add Value name. Then we can put that inside the attribute there.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" {src}>
----
//}}}

And then if I open my "dev - tools" and inspect this
image, You'll see that the alt attribute has been applied as we expect.

//{{{ image::./images/chapter-2-4.png
[#img-chapter]
[link=./images/chapter-2-4.png,window=_blank]
.Svelte Basic -4
image::./images/chapter-2-4.png[align="center"]
//}}}

Now we very often run into this situation here where we have an attribute -
`"name"` and `"value"` that match. So we have a convenient shorthand installed.
We can just get rid of the attribute - `"name"` and the equals in this case
`src=""` and pass it through like this,

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" {src}>
----
//}}}

That's something that will do quite a lot in this Workshop.

=== Styling

Now, I mentioned
before that a small component because it's HTML, it can contain JavaScript and
CSS. So we're going to add some CSS to a component.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<style>
    p {
        color: purple;
        font-family: "Comic Sans MS", cursive;
        font-size: 2em;
    }
</style>

<p>This is paragraph</p>
----
//}}}

We'll open a `"p"` selector and then make it `color: purple`. Give it a nice
"font" (`"font-family:"`), and we'll bump at the size (`"font-size:"`) a little
bit.

Right.And you'll see that it's applied.

//{{{ image::./images/chapter-2-5.png
[#img-chapter]
[link=./images/chapter-2-5.png,window=_blank]
.Svelte Basic -5
image::./images/chapter-2-5.png[align="center"]
//}}}

Those files to the paragraph As we would expect.

=== Nested Component

But wait there's more,  it's Svelte that you have "Nested - Components",
that is to say *a command* can contain *other* components.

In that situation, we don't want the Styles from One Component to *affect*
other Components on the page. Because then it becomes very difficult to
understand where a given style is coming from.

So Svelte actually *Scopes* the Styles inside a component, to just the
markup that belongs in the same Component.

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    p {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

We can show this by During the "script tag" that Imports are "Nested
Component". Just select that whole block and paste it at the top of
`"app.svelte"` that Imports The `:Nest.component"`, which is visible in this
tab here. Then we'll (`"<Nested />"`) put that underneath our paragraph.

//{{{ image::./images/chapter-2-6.png
[#img-chapter]
[link=./images/chapter-2-6.png,window=_blank]
.Svelte Basic -6
image::./images/chapter-2-6.png[align="center"]
//}}}

So the first paragraph `*[1]*` has the Styles defined here but they don't
affect the second paragraph `*[2]*`. Even though it's the same element.

//{{{ image::./images/chapter-2-7.png
[#img-chapter]
[link=./images/chapter-2-7.png,window=_blank]
.Svelte Basic -7
image::./images/chapter-2-7.png[align="center"]
//}}}

The way that this works under the hood is, that *"Svelte - Scopes"* the "CSS -
selector" with a "generated *hash*" (`".svelte-xxx"`).

That is computed from the contents of your style blog. It puts that CSS - class
on the selector in the CSS output, and it also puts it on the element.

With that way, there's no possibility of these selectors *clashing* between
different Components.

Obviously it goes the other way as well.

If I had a style in `"Nested.svelte"`,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    text-transform: uppercase;
    color: blue;
</style>
<p>This is a paragraph.</p>
----
//}}}

//{{{ image::./images/chapter-2-8.png
[#img-chapter]
[link=./images/chapter-2-8.png,window=_blank]
.Svelte Basic -8
image::./images/chapter-2-8.png[align="center"]
//}}}

They will affect the "child - Component" but not the "parent - Component".

We can also do something else. That's quite interesting.

Normally, when you're writing CSS, you have this phenomenon of the *append*
only style-sheet where you add some Styles, and then you add some more Styles
and then you add some more smiles and then you're NOT sure if you still need
these files. But you're *scared* to remove it because you don't know what is
affected by it. Because CSS is inherently Global.

But because we don't have that problem. Because our styles are
Scoped to the Component. We can remove the styles that *aren't used* inside the
Component, by *analyzing* the CSS and the markup together and seeing which select
Being applied.

So if we have this `".unused"` - class here,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    P {
        text-transform: uppercase;
        color: blue;
    }

    .unused {
        color: red;
    }
</style>
<p>This is a paragraph.</p>
----
//}}}

Then we look at the CSS output.

//{{{ image::./images/chapter-2-9.png
[#img-chapter]
[link=./images/chapter-2-9.png,window=_blank]
.Svelte Basic -9
image::./images/chapter-2-9.png[align="center"]
//}}}

That `"color: red"` has been stripped out. It's not included in the CSS that
gets sent to browser.  It's also give a convenient warning tells us that
there's *unused* CSS selector.

So we can go ahead and remove that from our source code.

=== HTML Tags

By default, when you have a curly brace `" {} "` with a Javascript expression
inside. It is evaluated as *"text"*. Which means that I click over the result
- tab, this String contains HTML.  We can actually see the angle bracket `"<
>"` of that time of that tags.

In some situations, you want to put the actual HTML on the page and that's
really easy to do. We just prefix it with `"{@html string}"`. So Special
type of tags.

// {{{  HTML tags App.svelte
[source, html]
----
// App.svelte
<script>
    let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
----
// }}}

Then now you can see that. This "bold" - text now.

//{{{ image::./images/chapter-2-10.png
[#img-chapter]
[link=./images/chapter-2-10.png,window=_blank]
.Svelte Basic -10
image::./images/chapter-2-10.png[align="center"]
//}}}

Now, there is a big caveat here. There's *NO sanitation* that happens.

What that means is, that you could potentially inject some *dangerous* HTML. So
you need to make sure that HTML that you're putting inside your Component comes
from source that you trust.

If it's coming form a source that you don't trust. Like some "user - input"
that you don't control, then you need to make sure that you sanitize that HTML
to remove any "Script - tags" or anything else that could be used in
a *"cross-site scripting attack"* before you include that on a page that is
visible to another user.

=== Add Global Styles

Okay, so we just had a great question about how whether you can add "Global
Styles" if you need to?

So we're going to skip back to the section on "Nested - Component".

We're going to out that nested paragraph inside the Component.

In this time, in our `"App.svelte"` we're going to changes this `"p {}"`
- Selector to a Global `"p {}"` - Selector. We do that using some syntax that
we stole from "CSS - modules" project `":global()"` and we wrap the `"p"`
selector like so,

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    :global(p) {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

Now every `"p {}"` - element on the page will be affected those Styles and the
way that works.

//{{{ image::./images/chapter-2-11.png
[#img-chapter]
[link=./images/chapter-2-11.png,window=_blank]
.Svelte Basic -11
image::./images/chapter-2-11.png[align="center"]
//}}}

If you look at the CSS - output, just hasn't bothered to apply the Scoping
selected "Class - name" do that Selector.

//{{{ image::./images/chapter-2-12.png
[#img-chapter]
[link=./images/chapter-2-12.png,window=_blank]
.Svelte Basic -12
image::./images/chapter-2-12.png[align="center"]
//}}}

So that useful. If you need to do something like change styles on the "Body
- Element". Because obviously you're not going to have the Body - Element
inside your Component.

But generally, that's something that you don't want to use too much if you have
Global Styles.

I personally think they should go in a `"global.css"` - file. That's where
I put my Rules about `"colors"` and `"typography"`. All of my "CSS - Variables"
of the page.

But this techniques is a useful escape hatch for the times that you do need it.



**â¬†xref:_table_of_contents[back to top]**
//}}}

// vim: set syntax=asciidoc
