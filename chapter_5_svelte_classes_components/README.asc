//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 4
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon May  3 06:28:45 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[_chapter_5_class_and_components]]
== Chapter-5 Class and Components

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_classes_directive[Class Directive]
| 2.    | xref:_composing_components_with_slots[Composing Components with Slots]
| 3.    | xref:_context_api[Context API]
| 4.    | xref:_special_elements[Special Elements]
|====
//}}}

// {{{ 1 == Classes Directive
[[_classes_directive]]
== Classes Directive

//{{{ image::./images/chapter-5-1.png
[#img-chapter]
[link=./images/chapter-5-1.png,window=_blank]
.Class Directive
image::./images/chapter-5-1.png[align="center"]
//}}}

So just like any other attributes on the DOM - Elements, you can set the Class of
an Element use JavaScript inside curly braces (`"class={}"`).

But this is such common pattern that we have a special by directive for
classes. Specifically that allow you to toggle Classes based on some condition.

// {{{ === Classes / The Class Directive
[[_classes_the_class_directive]]
=== Classes / The Class Directive

Just take a look in this App.svelte code below,

// {{{ app.svelte
[source, html]
----
// app.svelte
<script>
    let current = 'foo';
</script>

<button
    class="{current === 'foo' ? 'selected' : ''}"
    on:click="{() => current = 'foo'}"
>foo</button>

<button
    class="{current === 'bar' ? 'selected' : ''}"
    on:click="{() => current = 'bar'}"
>bar</button>

<button
    class="{current === 'baz' ? 'selected' : ''}"
    on:click="{() => current = 'baz'}"
>baz</button>

<style>
...
...
</style>
----
// }}}

So, instead of having `{current === 'foo' ? 'active' : ''}`, we can just
replace that whole things with, `class:selected={current === 'foo'}`.

// {{{ app.svelte
[source, html]
----
// app.svelte
<script>
    let current = 'foo';
</script>


<button
    class:selected="{current === 'foo'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'foo'}"
>foo</button>

<button
    class:selected="{current === 'bar'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'bar'}"
>bar</button>

<button
    class:selected="{current === 'baz'}"
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    on:click="{() => current = 'baz'}"
>
    baz
</button>

<style>
...
...

    .selected {
/*  ~~~~~~~~~ */
        background-color: #ff3e00;
        color: white;
    }
</style>
----
// }}}

We apply that to all of those.

So now I will click on these the active - Class, which add this `background`
- style to the button, will get applied whenever this condition
`class:selected={current === 'foo'}` is `"true"` for each of the button intern,
and that's just less stuff to write.

//{{{ image::./images/gif/chapter-5-1.gif
[#img-chapter]
[link=./images/gif/chapter-5-1.gif,window=_blank]
.Classes / The Class Directive
image::./images/gif/chapter-5-1.gif[align="center"]
//}}}
// }}} ===

// {{{ === Classes / Shorthand Class Directive
[[_classes_shorthand_class_directive]]
=== Classes / Shorthand Class Directive

Just like with the `"bind:value"` shorthand , and the `"source=source"`
shorthand that we've already encountered.

You'll very often have a situation like this, Where the Class you're toggling
is the same as the name of the condition.

// {{{ App.svelte
[source, html]
----
// App.svelte
....
....

<div class:big={big}>
    some {big ? 'big' : 'small'} text
</div>

----
// }}}

So if you have something like this Class, `"class:big={big}"`,

We can get rid of the equals `" ={big}"` - part of that to be like,

// {{{ App.svelte
[source, html]
----
// App.svelte
....
....

<div class:big>
//   ~~~~~~~~~
    some {big ? 'big' : 'small'} text
</div>

----
// }}}

Svelte will fill-in the blank for us.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Composing Components with Slots
[[_composing_components_with_slots]]
== Composing Components with Slots

So far when talking about Components containing other Components. It's been
*direct* parent-child relationship.

But very often when you're building an application you will need to pass some
*Content* into the Component, not as "Props", but as "Marker"; and for that we
have something called "Slots".

NOTE: Slot is a process called Component Composition.

// {{{ === Component Composition / Slots
[[_component_composition_slots]]
=== Component Composition / Slots
So in the same way that an Element can have children like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
<div>
    <p>I'm the child of the div</p>
</div>
----
// }}}

A `"<div>"` can contain a `"<p>"`.

A Component can have children, but it needs to know where to put them.

So inside our `"Box.svelte"` here, which is going to contain our Content.

// {{{ Box.svelte
[source, html]
----
// Box.svelte
<div class="box">
    <slot></slot>
</div>

<style>
...
...
</style>
----
// }}}

I'll use `"<slot>"` - Element.

Now that we've done that, inside our `"App.svelte"`, we can put some content
Inside the `"<Box>"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Box from './Box.svelte';
</script>

<Box>
    <h2>Hello!</h2>                                     // <<<
    <p>This is a box. It can contain anything.</p>      // <<<
</Box>
----
// }}}

We can put whatever we like, inside that `"<slot>"`.
// }}} ===

// {{{ === Component Composition / Slots Fallbacks
[[_component_composition_slots_fallbacks]]
=== Component Composition / Slots Fallbacks

In some situation you might need to have some *fallback* content for your
Component.

Inside the `"<slot>"`, you can specify your *fallback* like so,

// {{{ Box.svelte
[source, html]
----
// Box.svelte
<div class="box">
    <slot>
        <em>Content we provided</em>
    </slot>
</div>

<style>
...
...
</style>
----
// }}}

Then if the Component is created without any Content like so,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Box from './Box.svelte';
</script>

<Box>
    <h2>Hello!</h2>
    <p>This is a box. It can contain anything.</p>
</Box>

<Box />     // <<<
----
// }}}

It will use "fallback" marker instead.

//{{{ image::./images/chapter-5-2.png
[#img-chapter]
[link=./images/chapter-5-2.png,window=_blank]
.Component Composition - Slot
image::./images/chapter-5-2.png[align="center"]
//}}}
// }}} ===

// {{{ === Component Composition / Named Slot
[[_component_composition_named_slot]]
=== Component Composition / Named Slot

A component can contain *multiple Slots*. The one we just saw is the so-called
"Default - Slot", but you might have Content that needs to be injected in
a particular place inside a Component. For that we use something called "Name
- Slot".

In this sub-chapter we have a `"ContactCard"` - Component, and we have three
- Slots.

// {{{ COntactCard.svelte
[source, html]
----
// ContactCard.svelte
<article class="contact-card">
    <h2>
        <slot>                                              // <<<
            <span class="missing">Unknown name</span>       // <<<
        </slot>                                             // <<<
    </h2>

    <div class="address">
        <slot>                                              // <<<
            <span class="missing">Unknown address</span>    // <<<
        </slot>                                             // <<<
    </div>

    <div class="email">
        <slot>                                              // <<<
            <span class="missing">Unknown email</span>      // <<<
        </slot>                                             // <<<
    </div>
</article>

<style>
...
...
</style>
----
// }}}

One inside this `"<h2>"`, one inside the `"address"` - class, and one inside
the `"email"` -class.

We just need to provide name for all of those things.

// {{{ COntactCard.svelte
[source, html]
----
// ContactCard.svelte
<article class="contact-card">
    <h2>
        <slot name="name">
//            ~~~~~~~~~~
            <span class="missing">Unknown name</span>
        </slot>
    </h2>

    <div class="address">
        <slot name="address">
//            ~~~~~~~~~~~~~
            <span class="missing">Unknown address</span>
        </slot>
    </div>

    <div class="email">
        <slot name="email">
//            ~~~~~~~~~~~
            <span class="missing">Unknown email</span>
        </slot>
    </div>
</article>

<style>
...
...
</style>
----
// }}}

Then now, if we're using that Component in another Component. We can put in our
contact details and provide the "Slot - Name" as the "Slot - attribute" on the
Element, and it will get put in the correct place.

// {{{ App.svelte
[source, html]
----
// App.svelte
<ContactCard>
    <span slot="name">
//        ~~~~~~~~~~~
        P. Sherman
    </span>

    <span slot="address">
//        ~~~~~~~~~~~~~
        42 Wallaby Way<br>
        Sydney
    </span>
</ContactCard>
----
// }}}

Again if we don't provide any Content fro a particular Slot, like we haven't
provided a `slot="email"`, then it will use the "Fallback" - Content,
specifying the Child - Component.
//}}} ===

// {{{ === Component Composition / Slot Props
[[_component_composition_slot_props]]
=== Component Composition / Slot Props

In some situation, you're going to need to *pass data* from the Child - Component
back to the Parent - Component, so that it can be rendered inside the
Component - content.

Here we have a `"Hoverable"` - Component that look like this,

// {{{ Hoverable.svelte
[source, html]
----
// Hoverable.svelte
<script>
    let hovering;

    function enter() {
        hovering = true;
    }

    function leave() {
        hovering = false;
    }
</script>

<div on:mouseenter={enter} on:mouseleave={leave}>
    <slot></slot>
</div>
----
// }}}

What we want to do is, tell the Contents of the `"Hoverable"` - Component,
whether or not return if we're currently hovering on it.

So it needs to pass the data from the Slot to the Contents.

The Content looks like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable>
    <div class:active={hovering}>
        {#if hovering}
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

So inside the `"Hoverable.svelte"`, we going to add `<slot
hovering={hovering}></slot>`, or we can just do `<slot {hovering}></slot>`

// {{{ Hoverable.svelte
[source, html]
----
// Hoverable.svelte
<script>
    let hovering;

    function enter() {
        hovering = true;
    }

    function leave() {
        hovering = false;
    }
</script>

<div on:mouseenter={enter} on:mouseleave={leave}>
    <slot hovering={hovering}></slot>
//  ~~~~~~~~~~~~~~~~~~~~~~~~~ or
//  <slot {hovering}></slot>
</div>
----
// }}}

Then inside `"App.svelte"`, we're going to expose that by using the "Let
- Directive" (`"let: "`).

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable let:hovering={hovering}>
//         ~~~~~~~~~~~~~~~~~~~~~~~
    <div class:active={hovering}>
        {#if hovering}
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

Now, if you hover this Component, it will tell that it's being hover upon.

//{{{ image::./images/gif/chapter-5-2.gif
[#img-chapter]
[link=./images/gif/chapter-5-2.gif,window=_blank]
.Slot Props
image::./images/gif/chapter-5-2.gif[align="center"]
//}}}

We can change the name of this variable. For example, we change `"{hovering}"`
to `"{active}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

<Hoverable let:hovering={active}>
//                      ~~~~~~~
    <div class:active>
//       ~~~~~~~~~~~~ equal to class:active={active}
        {#if active}
//           ~~~~~~
            <p>I am being hovered upon.</p>
        {:else}
            <p>Hover over me!</p>
        {/if}
    </div>
</Hoverable>

...
...
----
// }}}

This Scope, the `"let"` - value is Scope of the Contents of the Component. It
won't escape that Scope. So we can have multiple of these `"<Hoverable>"`.

The value of the Scope, will only be applied to the affected Component, none of
its siblings.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
//}}}

// {{{ 3 == Context API
[[_context_api]]
== Context API

The time you'll have a group of Components that need to work together in some
way.

// {{{ === Context API / setContext and getContext
[[context_api_setcontext_and_getcontext]]
=== Context API / setContext and getContext
:fn-mapbox_gl: link:https://mapbox.com

For example, you might have a `"<Map>"` - Components like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Map from './Map.svelte';
    import MapMarker from './MapMarker.svelte';
</script>

<Map lat={35} lon={-84} zoom={3.5}>
    <MapMarker lat={37.8225} lon={-122.0024} label="Svelte Body Shaping"/>
    <MapMarker lat={33.8981} lon={-118.4169} label="Svelte Barbershop & Essentials"/>
    <MapMarker lat={29.7230} lon={-95.4189} label="Svelte Waxing Studio"/>
    <MapMarker lat={28.3378} lon={-81.3966} label="Svelte 30 Nutritional Consultants"/>
    <MapMarker lat={40.6483} lon={-74.0237} label="Svelte Brands LLC"/>
    <MapMarker lat={40.6986} lon={-74.4100} label="Svelte Medical Systems"/>
</Map>
----
// }}}

The `"App.svelte"` renders a "{fn-mapbox_gl}[Mapbox - GL,window=_blank]" map.
Then inside that we might want to have these `"<MapMarker>"` - Components, that
affects the `"<Map>"` in some way.

What we don't want to do is, have to store a reference to the `"Map"`
- Component and pass it down to the `"MapMarker"` - Components or vice-versa.

We want all of that coordination to happen within the Components themselves.
Because that makes our lives, as the users of these Components much easier.

The way we do that in Svelte is, with something called the "Context - API".

NOTE: "Context - API" is a mechanism that allows Components to talk to each
other, *without data being passed around as "Props"*.

The "Context - API" is coming in *two* halves,

- `"setContext"` - is called on a "Parent - Component", and that makes the
  Context available to every "Child - Component" is rendered within it.

- `"getContext"`

So in `"Map.svelte"` here, what we need to do is *set some Context*.

// {{{ Map.svelte
[source, html]
----
// Map.svelte
<script>
    import { onMount, setContext } from 'svelte';
//                    ~~~~~~~~~~
    import { mapbox, key } from './mapbox.js';
//                   ~~~

    setContext(key, {           // <<<
        getMap: () => map       // <<<
    })                          // <<<

    ...
    ...

</script>

...
...
----
// }}}

I'm going to import `"setContext"` from `"svelte"`.

I'm going to import this `"key"` - value from `"mapbox.js"` that will become
clear in a minute.

Then we are going to set the Context with that `"key"`, and then just passing
an Object with a `"getMap"` - method.

Now, that second argument to `"getContext"` can be anything you like. It's
really doesn't matter. But typically what it will be is an Object containing
a variety of functions that the "Child - Components" are going to use to
communicate with the "Parent - Component".

So on the other side of the equation, inside the `"MapMarker"` - Component.
We're going to need to get a reference to the `"mapbox.Map()"`.

// {{{ MapMarker.svelte
[source, html]
----
// MapMarker.svelte
<script>
    import { getContext } from 'svelte';            // <<<
    import { mapbox, key } from './mapbox.js';
//                   ~~~

    const { getMap } = getContext(key);             // <<<
    const map = getMap();                           // <<<

    export let lat;
    export let lon;
    export let label;

    const popup = new mapbox.Popup({ offset: 25 })
        .setText(label);

    const marker = new mapbox.Marker()
        .setLngLat([lon, lat])
        .setPopup(popup)
        .addTo(map);
</script>
...
...
----
// }}}

So we're going to import `"getContext"` from `"svelte"`.

Again we're going to import that `"key"` from `"mapbox.js"`.

Then we're going to call `"getContext"` and get a reference to that `"getMap()"`
- function.

Then each `"MapMarker"` is going to have it's own reference to `"map"`.

//{{{ image::./images/gif/chapter-5-3.gif
[#img-chapter]
[link=./images/gif/chapter-5-3.gif,window=_blank]
.Slot Props
image::./images/gif/chapter-5-3.gif[align="center"]
//}}}

So, let's take a look at what's happening.

Here we have these `'<MapMarker>"` - Components inside the `"<Map>"` in
`"App.svelte"`. They got a *latitude* `"lat"`, and *longitude* `"lon"` and
`"label="`.

The way that they're being applied to the Main `"<Map let={35} lon{-84}
zoom={3.5}"` - Object here is through the `"mapbox"` - API.

Once we have reference to this map `"const map = getMap()"` in
`"MapMarker.svelte". We can create a `"popup"` using the `"mapbox.popup()"`
- API.

Then we create a `"marker"` that use that `"popup()"`.

Then we get added to the Map - Object (`".addto(map)"`) that we had a reference
to.

You can imagine, that we didn't have the Context - API. We would have to
referenced - references to all these things being passed around, and it would
make our `"App.svelte"` a lot more crowded.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 4 == Special Elements
[[_special_elements]]
== Special Elements

So we've seen the Svelte - Components can contain any HTML. Validator - HTML,
has already valid spoke. But op top of that, Svelte provide a member of what we
call Special - Elements.

// {{{ === Special Elements / <svelte:self>
[[_special_elements_svelte_self]]
=== Special Elements / <svelte:self>

The first of these are going to look at `"<svelte:self>"`.

NOTE: `"<svelte:self>"` is a way that a Component can *contain itself*
recursively.

It's really useful for things like "Tree - Views".

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Folder from './Folder.svelte';

    let root = [
        {
            type: 'folder',
            name: 'Important work stuff',
            files: [
                { type: 'file', name: 'quarterly-results.xlsx' }
            ]
        },
        {
            type: 'folder',
            name: 'Animal GIFs',
            files: [
                {
                    type: 'folder',
                    name: 'Dogs',
                    files: [
                        { type: 'file', name: 'treadmill.gif' },
                        { type: 'file', name: 'rope-jumping.gif' }
                    ]
                },
                {
                    type: 'folder',
                    name: 'Goats',
                    files: [
                        { type: 'file', name: 'parkour.gif' },
                        { type: 'file', name: 'rampage.gif' }
                    ]
                },
                { type: 'file', name: 'cat-roomba.gif' },
                { type: 'file', name: 'duck-shuffle.gif' },
                { type: 'file', name: 'monkey-on-a-pig.gif' }
            ]
        },
        { type: 'file', name: 'TODO.md' }
    ];
</script>

<Folder name="Home" files={root} expanded/>
----
// }}}

We have  `"folder"` containing `"files"`, and `"folders"` containing other
`"folders"`.

We want to render this Tree into our app.

So we going to change `"Folder.svelte"` - Component,

What we want to be able to do is, just type in `"<Folder {...file} />"`.

// {{{ Folder.svelte
[source, html]
----
// Folder.svelte
<script>
...
...

{#if expanded}
    </ul>
        {#each files as file}
            <li>
                {#if file.type === 'folder'}
                    <Folder {...file} />
//                  ~~~~~~~~~~~~~~~~~
                {:else}
                    <File {...file}/>
                {/if}
            </li>
        {/each}
    <ul>
{/if}

<style>
...
...
</style>
----
// }}}

But that not going to work. Because this Component does NOT have a *reference*
to anything called `"<Folder>"`.

Instead we need to reference `"<svelte:self>"` like so,

// {{{ Folder.svelte
[source, html]
----
// Folder.svelte
<script>
    import File from './File.svelte';

    export let expanded = false;
    export let name;
    export let files;

    function toggle() {
        expanded = !expanded;
    }
</script>

<span class:expanded on:click={toggle}>{name}</span>

{#if expanded}
    </ul>
        {#each files as file}
            <li>
                {#if file.type === 'folder'}
                    <svelte:self {...file}/>
//                  ~~~~~~~~~~~~~~~~~~~~~~~~
                {:else}
                    <File {...file}/>
                {/if}
            </li>
        {/each}
    <ul>
{/if}

<style>
...
...
</style>
----
// }}}

Now we have a Tree - View that represent the Data - Structure shown below,

//{{{ image::./images/gif/chapter-5-4.gif
[#img-chapter]
[link=./images/gif/chapter-5-4.gif,window=_blank]
.Special Elements / <svelte:self>
image::./images/gif/chapter-5-4.gif[align="center"]
//}}}
// }}} ===

// {{{ === Special Elements / <svlete:component>
[[_special_elements_svlete_component]]
=== Special Elements / <svlete:component>

We also have a `"<svelte:component>"` which allows you to use Dynamic
- Components.

So at the moment we have a `"<select>"` - drop-down that is bound to these
`"<RedThing />"`, `"<GreenThig>"` and `"<Bluething>"` - Components.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

{#if selected.color === 'red'}
    <RedThing/>                         // <<<
{:else if selected.color === 'green'}
    <GreenThing/>                       // <<<
{:else if selected.color === 'blue'}
    <BlueThing/>                        // <<<
{/if}
----

// }}} ===

But it would be a lot nicer if we could just have a single thing that changed
the value of the Component dynamically.

So we just get rid of all that, and we use the special this "Prop", `"this={selected.component}"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

<svelte:component this={selected.component}/>   // <<<
----

// }}} ===

That behave exactly the same way as it did before.

If `"this={null}"` - value, then it wouldn't render anything at all.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
...
...
</script>

<select bind:value={selected}>
    {#each options as option}
        <option value={option}>{option.color}</option>
    {/each}
</select>

<svelte:component this={null}/>   // <<<
----
// }}}
// }}} ===

// {{{ === Special Elements / <svelte:window>
[[_special_elements_svelte_window]]
=== Special Elements / <svelte:window>

In the same way that we can add Event - Listener to DOM - Element. We can add
Event - Listener to the Window - Object with `"<svelte:window>"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let key;
    let keyCode;

    function handleKeydown(event) {
        key = event.key;
        keyCode = event.keyCode;
    }
</script>

<svelte:window on:keydown={handleKeydown}/>     // <<<

<div style="text-align: center">
    {#if key}
        <kbd>{key === ' ' ? 'Space' : key}</kbd>
        <p>{keyCode}</p>
    {:else}
        <p>Focus this window and press any key</p>
    {/if}
</div>

<style>
...
...
</style>

----
// }}}

So here, I'm going to add the `"<svelte:window>"` and add the
`"on:keydown:{handleKeydown}"` - Handler which is define as a `"handleKeydown"`
- function.

So now if I focus to the Window, that `"keydown"` - Handler it is going to get
a call whenever the Window receives a `"keydown"` - Event.

Just like with DOM - Events, we can use Modifiers, like `"preventDefault"` and
so on.
// }}} ===

// {{{ === Special Elements / <svelte:window> Binding
[[_special_elements_svelte_window_binding]]
=== Special Elements / <svelte:window> Binding

We can also add Binding to the Window.

In this `App.svelte"` - Component, we have a bunch of images from the
"firewroks" game. A nice little Parallax effect that they have on their
homepage.

I'm going to bind the `"scroll"` - value of the window to some local - State.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    const layers = [0, 1, 2, 3, 4, 5, 6, 7, 8];

    let y;
</script>

<svelte:window bind:scrollY={y}/>   // <<<

<a class="parallax-container" href="https://www.firewatchgame.com">
    {#each layers as layer}
        <img
        style="transform: translate(0,{-y * layer / (layers.length - 1)}px)"
//             ~~~~~~~~~               ~~
        src="https://www.firewatchgame.com/images/parallax/parallax{layer}.png"
        alt="parallax layer {layer}"
        >
    {/each}
</a>

<div class="text">
    <span style="opacity: {1 - Math.max(0, y / 40)}">
//                                         ~
        scroll down
    </span>

    <div class="foreground">
        You have scrolled {y} pixels
//                        ~~~
    </div>
</div>

<style>
...
...
</style>
----
// }}}

So we this `"y"` - value which is an initialized and we're using that in our
markup.

So we using it to determine the `"transform:"` of each of the images that from
our Parallax - Layer.

We're also using it inside this `"<span>"` - Style.

Also we're using it inside some text `"You have scrolled {y} pixels"`.

So we're going to Bind the value of the Windows `"scroolY"` - value to our
local `"{y}"` - variable | (`"<svelte:window bind:scrollY={y}/>"`).

Now, as I interact with this Window, we get this nice beautiful Parallax
motion.

//{{{ image::./images/gif/chapter-5-5.gif
[#img-chapter]
[link=./images/gif/chapter-5-5.gif,window=_blank]
.Special Elements / <svelte:window> Binding
image::./images/gif/chapter-5-5.gif[align="center"]
//}}}

There's a few different Bindings that we have access to as well as the
`"scrollY"` - value.

The list of properties you can bind to is as follows:

- `"innerWidth"`
- `"innerHeight"`
- `"outerWidth"`
- `"outerHeight"`
- `"scrollX"`
- `"scrollY"`
- `"online"` — an alias for `"window.navigator.onLine"`. It's really useful for
  indicating that the reason that your app isn't receiving any data is because
  the app is currently offline.

All except `"scrollX"` and `"scrollY"` are *readonly*.
// }}} ===

// {{{ === Special Elements / <svelte:body>
[[_special_elements_svelte_body]]
=== Special Elements / <svelte:body>

Just like `"<svelte:window>"`, we have also `"<svelte:body>"` - special Element
that allows you to Listen for Event that fire on `"document.body()"`.

It's particularly useful for the `"mouseenter"` and `"mouseleave"` - Handlers
which don't fire on Window.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let hereKitty = false;

    const handleMouseenter = () => hereKitty = true;
    const handleMouseleave = () => hereKitty = false;
</script>


<svelte:body                            // <<<
    on:mouseenter={handleMouseenter}    // <<<
    on:mouseleave={handleMouseleave}    // <<<
/>

<!-- creative commons BY-NC http://www.pngall.com/kitten-png/download/7247 -->
<img
    class:curious={hereKitty}
    alt="Kitten wants to know what's going on"
    src="tutorial/kitten.png"
>
<style>
...
...
</style>
----
// }}}

So going to find `"<svelte:body>"` - tag here, and add the `on:mouseenter"` and
`"on:mouseleave"` That have been defined.

Now when we move our Mouse into the window, a little cat appear.

//{{{ image::./images/gif/chapter-5-6.gif
[#img-chapter]
[link=./images/gif/chapter-5-6.gif,window=_blank]
.Special Elements / <svelte:body>
image::./images/gif/chapter-5-6.gif[align="center"]
//}}}

// }}} ===

// {{{ === Special Element / <svelte:head>
[[_special_element_svelte_head]]
=== Special Element / <svelte:head>

The `'<svelte:head>"` - Element allow us to inject Content into the `"<head>"`
of the document of the document.

Normally, obviously all of your Body - Content is going to go in the
`"<body>"`. But sometimes you need to do things like add a `"stylesheet"`, we
can do that here,

// {{{ App.svelte
----
// App.svelte
<svelte:head>
    <link rel="stylesheet" href="tutorial/dark-theme.css">
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</svelte:head>

<h1>Hello world!</h1>
----
// }}}

We also can change the Document - Title and other things like that, inside the
`"<svelte:head>"` - Element.

NOTE: In Server-Side Rendering (SSR) mode, contents of <svelte:head> are
returned separately from the rest of your HTML.
// }}} ===

// {{{ === Special Elements / <svelte:options>
=== Special Elements / <svelte:options>

Finally, we hae `"<svelte:options>"` - Elements, which allows you to specify
`"options"` that are used by the Compiler to control the output of the
Component.

We're going to use the `immutable` - Option for example.

This is an app, containing a bunch of "to-do", and what you notice is, anytime
we toggle any of the `"Todos"`, all todo the `"Todos"` is get *re-rendered*.

We can see that because we have this `"afterUpdate"` - `"flash()"` function
that runs.

// {{{ Todo.svelte
[source, html]
----
// Todo.svelte
<script>
    import { afterUpdate } from 'svelte';
    import flash from './flash.js';

    export let todo;

    let div;

    afterUpdate(() => {         // <<<
        flash(div);             // <<<
    });
</script>

<!-- the text will flash red whenever the `todo` object changes -->
<div bind:this={div} on:click>
    {todo.done ? '👍': ''} {todo.text}
</div>

<style>
    div {
        cursor: pointer;
        line-height: 1.5;
    }
    </style>
----
// }}}

`"afterUpdate()"` runs whenever the Component received any new State.

In ideal world, when we change "to-do" that doesn't affect a particular
Component.

So we can optimize this by telling this `"<Todo>"` - Component that it should
expect *immutable data*. Which is to say that, if we're going to give it a new
"to-do", than it's going to be an entirely new Object. We're NOT mutating
anything here.

So, if we add `"<svelte:options>"` - Element to our `"Todo.svelte"`.

// {{{ Todo.svelte
[source, html]
----
// Todo.svelte
<svelte:options immutable={true}/>      // <<<

<script>
    import { afterUpdate } from 'svelte';
    import flash from './flash.js';

    export let todo;

    let div;

    afterUpdate(() => {
        flash(div);
    });
</script>

<!-- the text will flash red whenever the `todo` object changes -->
<div bind:this={div} on:click>
    {todo.done ? '👍': ''} {todo.text}
</div>

<style>
    div {
        cursor: pointer;
        line-height: 1.5;
    }
    </style>
----
// }}}

Then now when we toggle these `"Todos"`, only the one that we're actually
toggling is receiving the "flash". Because the other `"Todos"` is they're
complexly unaffected, their data hasn't changed.

Here is a list of all other things that you can use with `"<svelte:optiions>"`.

The options that can be set here are:

- `"immutable={true}"` — you never use mutable data, so the compiler can do
  simple referential equality checks to determine if values have changed

- `"immutable={false}"` — the default. Svelte will be more conservative about
  whether or not mutable objects have changed

- `"accessors={true}"` — adds getters and setters for the component's props

- `"accessors={false}"` — the default

- `namespace="..."` — the namespace where this component will be used, most
  commonly "svg"

- `tag="..."` — the name to use when compiling this component as a custom element
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}
