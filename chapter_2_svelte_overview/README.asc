//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr 25 08:30:26 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_2_svelte_overview]]
= Chapter-2 Svelte overview

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h,~"]
|====
| 1.    | xref:_why_svelte[Why Svelte]
|====
//}}}

// {{{
[[_why_svelte]]
== Why Svelte
:fn-virtual_dom: http:https://svelte.dev/blog/virtual-dom-is-pure-overhead
:fn-write_less_code: https://svelte.dev/blog/write-less-code

So the obviousness question that a lot of people have is, *what is Svelte*?

Exactly a lot of different ways to answer that question.

It's a lot of different things, but it's probably easiest to understand it is
as an *alternative* to other existing projects that you're familiar with, "React"
and "Vue" of the two most popular "*Component* - frameworks", and Svelte
essentially solved a similar problem that
they do.

So, what is a "Component - framework? Component Frameworks exist to help you
write applications more *declaratively*.

We use that word declare Actively a lot in programming. So it's helpful to
understand exactly what we mean by that.

This declarative code that I'm looking at here.

//{{{ svelte - example
[source, html]
----
// svelte - example
<script>
    let count = 0;
</script>

<button on:click={() => count += 1}>
    Clicks: {count}
</button>
----
//}}}


This is some Svelte code is roughly equivalent to the vanilla JavaScript
beneath it.

//{{{ vanillaJS - example
----
// vanillaJS - example
function component() {
    let count = 0;

    const button = document.createElement('button');
    button.textContent = `Clicks: ${count}`;

    button.addEventListener('click', () => {
            count += 1;
            button.textContent = `Clicks: ${count}`;
            });

    return button;
}
----
//}}}

You can see what's happening with creating a button using
`document.createElement()` and then we're putting some text inside it.

Then adding an "Event Listener" to, when you click the button, it increments
the value of `"count"` and then it updates the `"textContent"` inside the
button.

Then we return that. That's our component.

So the difference is in the *"imperative"* - version with telling the browser
exactly what to do.

In the *"declarative"* - version. We're just saying what outcome we want; And
that's obviously a lot simpler for the developer, because we're not having to
work through the process of explaining to the browser exactly what it needs to
do each given moment.

More to the point. There's no duplication. Here We've got this initial
`"button.textcontent"` equals "blah"; and then inside the "update Handler",
we've got the same thing.

You tend to find that when you're building web applications, you have a lot of
that kind of *duplication*. You have the "initial render" and then you have the
"update".

But if you're doing things declaratively, that's no longer the case.

But it gets worse for the *"imperative"* story. If you want to make a very
small change to your component. For example, you want to wrap that `"count"` -
variable in a *strong element*. Then if you're doing it, imperatively, you need
to almost rewrite the entire component. That's for a very small change.

So you can imagine, if you're building a large application, the amount of work
that you would have to do is, you're *iterating on your design* is much - much
greater with *"imperative'* - code.


So that's the value that component framework provide. They make it a lot easier
for us as developers to build applications.

Historically, though there has been a little bit of an implicit "trade-off".
Because the framework acts as a *middleman* between you and the browser. With
the middleman introduces inefficiency.

=== How is Svelte Different?

So, Svelte began back in 2016,is an experiment to prove that is, in fact, a
false dichotomy, there is no tension between developer experience,and user
experience.

Svelte is a *compiler*, it takes your *"declarative"* - code and it turns it
into the equivalent *"imperative"* - JavaScript. Then this has a number of
really useful advantages.

- First. Your apps will *generally be quite a lot smaller*.

Because we don't need to have the *actual framework runtime* in the browser.
Normally,the framework has to anticipate every possible use case, but because
Svelte understands exactly what is going into your app. It can discard most of
it in just ship the code that is actually needed for your specific use case.

JavaScript is the most expensive thing on the web bite for bite. Because you
don't just have to download it. You also have to pause and evaluate it, and so
if we can use less of it than your apps are going to launch quicker and your
users will be happier.

- Second. You apps will be *Faster*.

Once your applications have already launched, your apps are going to be faster.
Because we don't need to use costly techniques like *"re-rendering"* the
{fn-virtual_dom}["virtual Dom"] and then dipping it to find out what needs to
change on the page.

Instead, we can make surgical granular updates. The compiler knows which bits
of the application could change for a given "State" - change, and it can just
change the "Dom" directly the same way that you would do, if you using the "Dom
- API" manually.

- Finally, Your app will be *easier to write*.

Because we have a lot more control over the *"authoring"* - experience. We
don't have the same constraints that are the people do. What this means in
particular, is that if you're using Svelte, you will be able to write less
code.


There's a blog post link there that I invite you to check out which explains
why {fn-write_less_code}[writing less code] is so important.  Writing less
code, means that you'll have fewer *"bugs"* and to be able to spend more time
Outdoors.

Beyond that Svelte aims to make your life easier by shipping a lot of the
things that normally you would have to do as third party liability would
install from "NPM".

So things like *"State - management"*, *"Element - transitions"*, *"handling
input"* via "Form" - elements, scope - CSS. All of those things. Normally with
a framework,those are things that you have to figure out a solution to
yourself.

But was Svelte, it's already *built in*, and we can do that because again,
*we're a "compiler"*, we can discard the bits that we're not using.

=== Who Make Svelte?

Well, it is very much a *community project*.

It's not a project with full-time engineers and corporate funding. It's a
project that is developed in the open by a group of volunteers who work on it,
in their free time. Because we believe in the project.

There is a core team of developers who do the day-to-day stuff, but the broader
contributor Community is large, and every decision that we make about, the
future of the framework is done to the greatest extent possible out in the
open.

Egalitarians, Communitarian project. We welcome developers of all backgrounds
and with all skill levels, and we would love for you to be involved as well.

So with that, I'm going to move on to the next part of the workshop where we're
going to run through the entire Svelte tutorial to learn how to build stock
components.

**â¬†xref:_table_of_contents[back to top]**
//}}}

// vim: set syntax=asciidoc
