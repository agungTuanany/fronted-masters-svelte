//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 4
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Mon May  3 06:28:45 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_4_svelte_stores_animation]]
== Chapter-4 Svelte Stores Animation

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_stores_and_derived_state[Stores & Derived State]
| 2.    | xref:_custom_store_store_bindings[Custom Store & Store Bindings]
| 3.    | xref:_adding_motion_with_easing_spring[Adding Motion with Easing & Spring]
| 4.    | xref:_transition[Transition]
|====
//}}}

// {{{ 1 == Stores & Derived State
[[_stores_and_derived_state]]
== Stores & Derived State

//{{{ image::./images/chapter-4-1.png
[#img-chapter]
[link=./images/chapter-4-1.png,window=_blank]
.Stores & Derived State -1
image::./images/chapter-4-1.png[align="center"]
//}}}

So, so far all of the state that we've been dealing with has been State that
belongs to specific Components, and if we need to pass it around between
Components, then we use it. Use "Props" and we use Bindings and use Events.

But that's not always what you want. Sometimes you have State that doesn't
really belong to a specific Component. Sometimes its Global - State, like an
Object representing the "current user" and things like that, and we need to
have a way of *representing those outside the Component*.

For that in Svelte we have the concepts of "Stores". The Stores is pretty
simple. It's just an Object with a Subscribe - method and it's not even Svelte
specific. It's something you could use in any application as we'll see. But it
does have a specific importance to Svelte.

// {{{ === Stores / Writable Stores
[[_stores_writable_stores]]
=== Stores / Writable Stores

So here's our file `"stores.js"`.

// {{{ stores.js
[source, javascript]
----
// stores.js
import { writable } from 'svelte/store';

export const count = writable(0);
----
// }}}

We're importing `"writable"` from `"svelte/store"`. Not the main Svelte
package, but the `"svelte/store"` - package which is one of the number of
packages that live inside the Svelte - namespace.

Then we're initializing it with `"0"` (`"writable(0)"`), and that become our
`"count"` - Store.

Then we're importing that `"count"` - Store into each these Components
`"App.svelte"`, `"Decrementer.svelte"`, `"Incrementer.svelte"`, and
`"Resetter.svelte"`.

As the name suggests, the job of these Components, is to increment, decrement
or reset the "value" of that Store.

So, inside the `"Incrementer"` - Component, let's change the value of the
Store, by calling `"count.update()"`.

Then I'm going to pass in a Handler that *takes* the current value and *return*
the new value.

That the job of the `"update()"` - method.

// {{{ Incrementer.svelte
[source, html]
----
// Incrementer.svelte
<script>
    import { count } from './stores.js';

        function increment() {
            // TODO increment the count
            count.update(n => n + 1);
        //  ~~~~~~~~~~~~~~~~~~~~~~~
    }
</script>

<button on:click={increment}>
	+
</button>
----
// }}}

Now when I click the plus `" + "` - button, the value of the `"count"`
increases.

The way we're getting that value into `"App.svelte"` is, by *subscribing* to
it.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

    let count_value;
//  ~~~~~~~~~~~~~~

    const unsubscribe = count.subscribe(value => {
        count_value = value;
    });
</script>

<h1>The count is {count_value}</h1>
//               ~~~~~~~~~~~~ <<< reference inside the markup

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

So, as you can see, in `"App.svelte"` - code above, we are declaring
`"count_value"`

Then we calling `"count.subscribe()"`, and giving it a callback which takes the
"value", (the current value) which is the callback, that runs every time the
"value" of `"count"` changes as well as when you first subscribe to it, and
then it's passing that value back, up to `"count_value"` which us then
*reference* inside the markup (`"<h1>The count is {count_value}</h1>"`).

So that how clicking the `" + "` - button affect the content of the `"<h1>"`
- Elements.

If you thinking that's quite a lot of boilerplate, you're not wrong. I'm goint
to get to that.

I'm going to wire up the `"Decrementer"` - Component first. Same thing,
`"count.update(n => n - 1)"`

// {{{ Decrementer.svelte
[source, html]
----
// Decrementer.svelte
<script>
    import { count } from './stores.js';

        function decrement() {
            // TODO decrement the count
            count.update(n => n - 1);
        //                    ~~~~~
    }
</script>

<button on:click={increment}>
	-
</button>
----
// }}}

Now we can press the `" - "` - button.

Finally in the `"Resetter"` - Component, we don't care about the "current
- value". We're always just going to set it back to zero, so `"count.set(0)"`.

// {{{ Resetter.svelte
[source, html]
----
// Resetter.svelte
<script>
    import { count } from './stores.js';

        function reset() {
            // TODO reset the count
            count.set(0);
        //        ~~~~~
    }
</script>

<button on:click={increment}>
	reset
</button>
----
// }}}
// }}} ===

// {{{ === Stores / Auto-subscriptions
[[_stores_auto_subscriptions]]
=== Stores / Auto-subscriptions
:fn-auto_subscriptions: link:https://svelte.dev/tutorial/auto-subscriptions

Okay, so that works. But there's actually "subtle - *bug*" in this application,
and the "bug" is, that we're generating this `"unsubscribe"` - function,

// {{{ App.svelte
[source, html]
----
<script>
    ...
    ...

    const unsubscribe = count.subscribe(value => {
//        ~~~~~~~~~~
        ...
        ...
    })
</script>
----
// }}}

Which is the result of calling `"count.subscribe()"`, but it's never gets
called anywhere.

Now, one way that we could fix that is, to use the `onDestroy"` - Lifecycle
function.

Then inside the `"<script>"` - block we call `"onDestroy()"` we call
`"unsubscribe"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { onDestroy } from 'svelte';
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

    let count_value;

    const unsubscribe = count.subscribe(value => {
        count_value = value;
    });

    onDestroy(unsubscribe);
//  ~~~~~~~~~~~~~~~~~~~~~~
</script>

<h1>The count is {count_value}</h1>
//               ~~~~~~~~~~~~ <<< reference inside the markup

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

With that way, we're not going to have any *"memory - leaks"*. If there are
lots of these Components and they've been *Created* and *Destroyed*. All of our
"subscribers" are going to be turn down.

But look at all this above code, it's quite a lot for what we're trying to do.

So Svelte has a trick up it's sleeve. Because we have this *fixed* "Store
- Contract" by which I mean the `"subscribe()"` - method, we can reference the
Store - value by *prefixing* the "Store - *name*" with the dollar - symbol
`"$"`.

We can get rid of the `"onDestroy"`, get rid of the `"count_value"`, get rid of
the `"count.subscribe()"`. Just taking that Store and prefix it with the `"$"`

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
    import Incrementer from './Incrementer.svelte';
    import Decrementer from './Decrementer.svelte';
    import Resetter from './Resetter.svelte';

</script>

<h1>The count is {$count}</h1>
//               ~~~~~~~

<Incrementer/>
<Decrementer/>
<Resetter/>
----
// }}}

It works exactly the same way.

NOTE: Auto-subscription only works with store variables that are declared (or
imported) at the top-level scope of a Component.

NOTE: Any name beginning with `"$"` is assumed to refer to a store value. It's
effectively a reserved character — Svelte will prevent you from declaring your
own variables with a `"$"` prefix.

Under the hood Svelte is creating that *"subscriber"* the same way that you
would have done manually except that, it's always going to clean it up when
it's no longer valid.

There are some caveats about how this syntax sugar works, and they're detailed
on {fn-auto_subscriptions}[this section,window=_blank].

// }}} ===

// {{{ === Stores / Readable Stores
[[_stores_readable_stores]]
=== Stores / Readable Stores

So that was the "Writable - Store". There are some Store that you don't need to
be able to *set the value of*, or it doesn't make sense to set the value of
them.

You might have a Store that representing the "mouse - position", or Store
representing the uses "geolocation", and those are *"read-only"* essentially.

So this time in our `"store.js"` - file. we're importing `"readable"` instead
of `"writable"`.

// {{{ store.js
[source, js]
----
// store.js
import { readable } from 'svelte/store';
//       ~~~~~~~~

export const time = readable(null, function start(set) {
	// implementation goes here

	return function stop() {};
});
----
// }}}

Then we creating the Store called `"time"`, has no initial value currently.

We haven' implemented the function that gets called when we first subscribe to
the Store. So let's do that now.

// {{{ store.js
[source, js]
----
// store.js
import { readable } from 'svelte/store';
//       ~~~~~~~~

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() => {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };
});
----
// }}}

First argument is the initial - value `"new Date()"`, and when we first
subscribe to the Store, which is already happening, because we're referencing
it inside our `"App.svelte"` with `"$time"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...
</script>

<h1>The time is {formatter.format($time)}</h1>
//                                ~~~~~
----
// }}}

We can create an `"interval"` (`"setInterval()"`). It's going to run once every
second. And it's going to set the current value to a `"new Date()"` - Object.

Then, once everything is *unsubscribe* to this Store, we can clean that up.

So inside the `"stop()"`, we're going to return a function that calls
`"clearInterval()"`. then we pass in `"interval"`.

So now we have this "time" - Store, that is just going to keep taking up as
long as anyone is interested in it, and that can be shared between as many
Components as you want.
// }}} ===

// {{{ === Stores / Derived Stores
[[_stores_derived_stores]]
=== Stores / Derived Stores
:fn-store_derived: link:https://svelte.dev/docs#derived

Finally we have Derived Stores, which are Stores whose value is derived form
other Stores with a `"readable"` or `"writable"` or even other derive Stores.

So taking the previous example, we want to have a Store that represents the
number of seconds that the page has been open.

// {{{ store.js
[source, javascript]
----
// store.js
import { readable, derived } from 'svelte/store';
//                 ~~~~~~

export const time = readable(new Date(), function start(set) {
    const interval = setInterval(() => {
        set(new Date());
    }, 1000);

    return function stop() {
        clearInterval(interval);
    };

});

const start = new Date();

export const elapsed = derived(
    time,
    $time => Math.round(($time - start) / 1000)
);
----
// }}}

We already have our "time" - Store setup.

We just need to implement the "elapsed" - Store. So we're importing `"derived"`
alongside `"readable"`.

The *first* argument to this `"derived()"` - function is a Store, and the
*second* argument is a callback that takes the current Stores - value and turn
it into something else.

So we are going to take `"Math.round()"`, and then we'll take the current
- time subtract that from the `"start"` - time when this module was first
evaluated. Then we'll divide it by `"1000"`.

Now you can see the Store representing the number of seconds elapsed since the
page is opened.

It's update in sync with the Store representing the current time.

You can derive Store from multiple input Stores, and you can explicitly set
a value instead of just returning it like we're doing above. That a little bit
more involved.

So if that's something that you need to do, then consult the API
- documentation which you can find up {fn-store_derived}[here,window=_blank]
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 2 == Custom Store & Store Bindings
[[_custom_store_store_bindings]]
== Custom Store & Store Bindings

We can also create "Custom" - Store, because remember the Store contract is
very simple. You just need a "subscribe" - method and anything beyond that is
up to you.

// {{{ === Stores / Custom Stores
[[_stores_custom_stores]]
===  Stores / Custom Stores

So if we take our "count" - Store from the first Store example. Then what we
can do is add `"increment()"`, `"decrement()"` and `"reset()"` - methods on
the Store itself.


In our `"store.js"` - file, we have a new function to create a special "count"
- Store, and inside that we beginning by creating `"writable"` - Store just
like we had before. When we were doing all this ourselves and we're
destructing it to get references to (`"{ subscribe, set, update }"`), which are
the three methods that exist on a `"writable"` - Store.

And what we're going to turn that into is a Store where you can only change the
value in specific ways.

So whereas before, you could have a `"count. ..."`, and then you can do
`"count.set(potato)"` or something irrelevant like that.

This time, the Store is going to expose its own API.

Exactly as we had when we had an increment to Component.

So, `"increment()"` - function is going to look like this,

// {{{ store.js
[source, javascript]
----
// store.js
import { writable } from 'svelte/store';

function createCount() {
    const { subscribe, set, update } = writable(0);

    return {
        subscribe,
        increment: () => update(n => n + 1),    // <<<
        decrement: () => update(n => n - 1),    // <<<
        reset: () => set(0)                     // <<<
    };
}

export const count = createCount();
----
// }}}

Then same with `"decrement()"`, also with `"reset()"` - methods.

Then inside `"App.svelte"`we already referencing those functions.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { count } from './stores.js';
</script>

<h1>The count is {$count}</h1>

<button on:click={count.increment}>+</button>
<button on:click={count.decrement}>-</button>
<button on:click={count.reset}>reset</button>
----
// }}}

Now, if we try. All works exactly as you would expect.
// }}} ===

// {{{ === Stores / Store Bindings
[[stores_store_bindings]]
=== Stores / Store Bindings

Just as you can bind to Component - State. You can also Bind to Store - values.

// {{{ store.js
[source, javascript]
----
import { writable, derived } from 'svelte/store';

export const name = writable('world');

export const greeting = derived(
    name,
    $name => `Hello ${$name}!`
);
----
// }}}

So here we have a Store representing a String, which is the name of a "user",
and then we have another Store that is derived from that Store value.

So what we want to do is, wire up this `"<input>"` to the value of the Main
- Store. So that the greeting is automatically derived whenever that changes.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>
//     ~~~~~~~~~~~
----
// }}}

So the `"<h1>"` is displaying the "derived value".

The `"<input>"` is displaying the "input value">

I'm going to change that into Binding with `"bind:value={}"`.

If we try to input some words, it works exactly as a regular input words.

Now we can also change the value of Store inside Components. Either inside the
`"<script>"` - block, or inside the markup.

So we can add a button here,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>

<button on:click="{() => $name += '!'}">
    Add exclamation mark!
</button>
----
// }}}

We give it an "Event - Handler" for every time we click it.

We're going to change the "value" of main directly.

Then now we finally press that the Store - value is updated.

This is the same as doing,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { name, greeting } from './stores.js';
</script>

<h1>{$greeting}</h1>
<input bind:value={$name}>

<button on:click="{() => name.set($name + '!')}">
    Add exclamation mark!
</button>
----
// }}}

Above code it's just a little bit neater.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 3 == Adding Motion with Easing & Spring
[[_adding_motion_with_easing_spring]]
== Adding Motion with Easing & Spring

So Stores that are pretty powerful primitive, but we can actually do a lot more
than we've seen so far.

// {{{ === Motion / Tweened
[[_motion_tweened]]
=== Motion / Tweened

//{{{ image::./images/gif/chapter-4-1.gif
[#img-chapter]
[link=./images/gif/chapter-4-1.gif,window=_blank]
.Adding Motion With Easing & Spring -1
image::./images/gif/chapter-4-1.gif[align="center"]
//}}}

Here's a little app with a progress meter. When I click on these buttons it
will change the value of the progress.

What we want is for it to *smoothly* - tween to those value.

We can do that with the "Tween" - Store which we're going to import from
`"svelte/motion"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { tweened } from "svelte/motion";

    const progress = tweened(0);
//                   ~~~~~~~~~
</script>

...
...
----




// }}} ===

Then we just going to change this `"writable"` to `"tweened"`.

//{{{ image::./images/gif/chapter-4-2.gif
[#img-chapter]
[link=./images/gif/chapter-4-1.gif,window=_blank]
.Adding Motion With Easing & Spring -2
image::./images/gif/chapter-4-1.gif[align="center"]
//}}}

Now with exactly the same API as before, we have a smooth between value.

What we're doing here is putting that `"$"` - prefix "Store - name" as the
value of our `"<progress>"` - Element.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { tweened } from "svelte/motion";

    const progress = tweened(0);
</script>

<progress value=${progress}></progress>
//              ~~~~~~~~~~~
...
...
----




// }}} ===

So that works, but it kind of feels a little bit *robotic*. That because we
don't have any Easing to this motion. It just like interpolating between two
values in a purely linear fashion.

So what we're going to do is add an Easing - function, and Svelte has a bunch
of Easing - function readily available for you.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { tweened } from "svelte/motion";
    import { cubicOut } from "svelte/easing";

    const progress = tweened(0, {
        duration: 400,              // <<<
        easing: cubicOut            // <<<
    });
</script>

<progress value=${progress}></progress>
...
...
----




// }}} ===

First we import `"cubicOut"` from `"svelte/easing"`. `"cubicOut"` is a function
that takes a value between `"0"` and `"1"`, then returns another value between
`"O"` and `"1"` after its applied the Easing, and its allows us to do much nicer
motion like this,

//{{{ image::./images/gif/chapter-4-3.gif
[#img-chapter]
[link=./images/gif/chapter-4-3.gif,window=_blank]
.Adding Motion With Easing & Spring -3
image::./images/gif/chapter-4-3.gif[align="center"]
//}}}

Now it's faster at the beginning. Then it slows downs as it eases out into its
final state.

We can pass more options to Twin with the second argument, can contain
a `"delay"` in which case between won't happen immediately.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { tweened } from "svelte/motion";
    import { cubicOut } from "svelte/easing";

    const progress = tweened(0, {
        duration: 400,
        delay: 400,                 // <<<
        easing: cubicOut
    });
</script>

<progress value=${progress}></progress>
...
...
----
// }}}

//{{{ image::./images/gif/chapter-4-4.gif
[#img-chapter]
[link=./images/gif/chapter-4-4.gif,window=_blank]
.Adding Motion With Easing & Spring -4
image::./images/gif/chapter-4-4.gif[align="center"]
//}}}

We can specify the `"duration"` of the function. You can provide a custom
`"interpolator"` if your Tween in between numbers and object of the same shape.
Then Svelte already knows how to handle those. But you can add a custom
- `"interpolator"` that allows you to for example, Twin between two String
representing colors.

All the options that you can pass-in, when you create a new Twin Store, you can
also pass-in when you call `"twin.set(value, options)"`, or `"twin.update(fn,
options)`

So you have a lot flexibility with how these work.
// }}} ===

// {{{ === Motion / Spring
[[_motion_spring]]
=== Motion / Spring

The Spring - Store is similar to the Twin - Store. Except that instead of
passing it and explicit *"using function"* and explicit *"duration"*. It will
use some very basic physic to do same thing.

It's a better option for values that *frequently change*.

Because whereas with the Twin - Store, if you set the value, while a Tween is
happening, it will abruptly stopped, and then change the new value.

With a Spring - Store, it's continuous motion, and if you change the value,
while it's already in the process of moving to the new value, then it will sort
of take that into account and it'll move in a much more natural seemingly.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { writable } from 'svelte/motion';
    import { cubicOut } from "svelte/easing";

    let coords = writable({ x: 50, y: 50 });
    let size = writable(10);
</script>

...
...
----
// }}}

So, right now we have a "Writable" - Store that represent the mouse position.
You can see this little "orange - dot", just follows the mouse around. When
I click the trackpad or a mousepad to gets bigger like so,

//{{{ image::./images/gif/chapter-4-5.gif
[#img-chapter]
[link=./images/gif/chapter-4-5.gif,window=_blank]
.Adding Motion With Easing & Spring -5
image::./images/gif/chapter-4-5.gif[align="center"]
//}}}

Which fine it works. But we can make it nicer by using "Spring" - Store.


So, once again we're going to import from `"svelte/motion"` - package. I'm
going to replace these `'writable"` - Stores with `"spring"` - Stores.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { spring } from 'svelte/motion';
//           ~~~~~~

    let coords = spring({ x: 50, y: 50 });
//               ~~~~~~
    let size = spring(10);
//             ~~~~~~~~~
</script>

...
...
----
// }}}

So now you can see that the "orange - dot" kind of follows the mouse around and
little bit more slowly, and when I click, it gets bigger and smaller with the
same kind of smooth motion;

Those two things are independent. So it can be moving and it can be getting
bigger and smaller at the same time, like so,

//{{{ image::./images/gif/chapter-4-6.gif
[#img-chapter]
[link=./images/gif/chapter-4-6.gif,window=_blank]
.Adding Motion With Easing & Spring -6
image::./images/gif/chapter-4-6.gif[align="center"]
//}}}

That works because down here inside the `"<svg>"` - Element the `"<circle>"` is
again using the name of the Store, prefixed with a `"$"`, and then it's just
taking the `"x"` - property and the `"y"` - property of the `"$coords."`
- Store, and this `"$size"` value directly.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { spring } from 'svelte/motion';

    let coords = spring({ x: 50, y: 50 });
    let size = spring(10);
</script>

...
...

<svg
    on:mousemove="{e => coords.set({ x: e.clientX, y: e.clientY })}"
    on:mousedown="{() => size.set(30)}"
    on:mouseup="{() => size.set(10)}"
>
    <circle cx={$coords.x} cy={$coords.y} r={$size}/>
//          ~~~~~~~~~~~~~  ~~~~~~~~~~~~~  ~~~~~~~~
</svg>

<style>
...
...
</style>
----
// }}}

Now just like the Tween - Store, we can pass in some *options* as the "second
argument".

So for example, we can add some `"stiffness:"` and `"damping:"` - method.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { spring } from 'svelte/motion';

    let coords = spring({ x: 50, y: 50 }, {
        stiffness: 0.1,         // <<<
        damping: 0.25,          // <<<
    });
    let size = spring(10);
</script>

...
...
----
// }}}

It will change how the physic of this behavior as you can see now it's a lot
kind of _"spring"_ here.

//{{{ image::./images/gif/chapter-4-7.gif
[#img-chapter]
[link=./images/gif/chapter-4-7.gif,window=_blank]
.Adding Motion With Easing & Spring -7
image::./images/gif/chapter-4-7.gif[align="center"]
//}}}

Also we can change this values dynamically. Change the "stiffness" way-up, and
I can change the "damping" way-down, and it'll start to get a little bit
silly.

So depending on what kind of effect you're trying to achieve in your UI, you
can customize these values.
// }}} ===

**⬆xref:_table_of_contents[back to top]**
// }}}

// {{{ 4 == Transition
[[_transition]]
== Transition
:fn-jarring: footnote:[disturb]

So when you're building a User Interface, something that you'll need to do
quite often is have Elements appear and disappear in a more graceful way, than
if they're just got rendered to the DOM and then got yanked out of the DOM, and
because that can be jarring{fn-jarring} for users.

// {{{ === Traditions / The Transition Directive
=== Traditions / The Transition Directive

So right now, in this application, we have "checkbox" that is linked to whether
or not this `"<p>"` - Element gets rendered.

If you toggle it, it appears, an then it disappears.

//{{{ image::./images/gif/chapter-4-8.gif
[#img-chapter]
[link=./images/gif/chapter-4-8.gif,window=_blank]
.Transition -1
image::./images/gif/chapter-4-8.gif[align="center"]
//}}}

What we want to happen is, for that Element is going to "fade-in" and
"fade-out".

We can do that in Svelte with an "Element - Transition".

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { fade } from "svelte/transition";
    let visible = true;
</script>

<label>
    <input type="checkbox" bind:checked={visible}>
    visible
</label>

{#if visible}
    <p transition:fade> Fades in and out</p>
{/if}
----
// }}}

First we need to import the `"transition"` from `"svelte/transition"`.

Then all we need to do is add the `"transition"` by directed to our `"<p>"`
- Element.

Now when we toggle the value of "visible", you can see that the Element
gracefully "fades-in" and "fades-out".

//{{{ image::./images/gif/chapter-4-9.gif
[#img-chapter]
[link=./images/gif/chapter-4-9.gif,window=_blank]
.Transition -2
image::./images/gif/chapter-4-9.gif[align="center"]
//}}}

It won't get removed from the DOM until the outro has completed.
// }}} ===

// {{{  === Transition / Adding Parameters
=== Transition / Adding Parameters

We can parameterize these `"transition"` as well.

Let's turn off  "fade-transition" into "fly-transition", and give some
options.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { fly } from "svelte/transition";
    let visible = true;
</script>

<label>
    <input type="checkbox" bind:checked={visible}>
    visible
</label>

{#if visible}
    <p transition:fly="{{ y: 200, duration: 2000 }}"> Fades in and out</p>
{/if}
----
// }}}

We give a `"y"` - value, and `"duration"`.

Now when I toggle this "checkbox", the Element is going to "fly-in" and
"fly-out".

//{{{ image::./images/gif/chapter-4-10.gif
[#img-chapter]
[link=./images/gif/chapter-4-10.gif,window=_blank]
.Transition - Adding Parameter -1
image::./images/gif/chapter-4-10.gif[align="center"]
//}}}

Now you'll notice as I'm interacting with this "checkbox". The Transition is
reversible, if we change the value of `"visible"` while the element is
"in-throwing' or "out-throwing", it won't restart it. It'll gracefully pick up
from where it left off;

So that way, we're able to build robust, but slick User Interfaces and that
would be pretty difficult to do if you're writing by hand. Because there's
a lot of really complex State that you need to keep track-of.
// }}} ===

// {{{ === Transition / In and Out
=== Transition / In and Out

We can also have different intro and outro - Transition.

So the Transition is bi-directional, but we might want to have something
"flies-in" and then "fades-out".

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { fade, fly } from "svelte/transition";
    let visible = true;
</script>

<label>
    <input type="checkbox" bind:checked={visible}>
    visible
</label>

{#if visible}
    <p in:fly="{{ y: 200, duration: 2000 }}" out:fade>
//                                           ~~~~~~~
    Flies in, fades out
</p>
{/if}
----
// }}}

So I add `"fade"` back into our Component.

Then we'll return this trasition into `"in:"`, and then we'll add them
`"out:"`, and then we just pass it the `"fade"` - function.

//{{{ image::./images/gif/chapter-4-11.gif
[#img-chapter]
[link=./images/gif/chapter-4-11.gif,window=_blank]
.Transition - In and Out -1
image::./images/gif/chapter-4-11.gif[align="center"]
//}}}

Again, if you "fade-out" while it's "flying-in", it will combine those
transitions so you get a Grace from the faith.

If you make it visible while it's "fading-out", then it will have to restart.
Because it doesn't have a way of composing those Transition in Reverse. But
that's a pretty rare situation.
// }}} ===

// {{{ === Transition / Custom Transition
[[_transition_custom_transition]]
=== Transition / Custom Transition

So there's bunch of built-in Transitions. We have `"fade"`, `"fly"`, `"scale"`,
`"slide"`, and they all do more or less what their name suggest. But we can
also create our own Custom - Transitions.

So this is what the Transition - function looks like,

// {{{ fadeTransition.js
[source, javascript]
----
// fadeTransition.js
    import { fade } from 'svelte/transition';

    let visible = true;
    function fade(node, {
        delay = 0,
        duration = 400
        }) {
            const o = +getComputedStyle(node).opacity;

            return {
                delay,
                duration,
                css: t => `opacity: ${t * o}`
        };
    }
----
// }}}

Above code is explain how the "fade" - Transition is implemented.

The *first* - argument of the function is the *"mode"* that is going to be
transitioned.

The *second* - argument is the *"set"* of options that were passed in.

Then we have the body of the function, does whatever calculation that it needs
to, to get information about the current State of the node, either what it's
going to look like in.

Then its non transitioning State and then it return an Object. Containing some
information that's Svelte will use to construct and apply the Transition.

So we're going to return a `"delay"` - value, and `"duration"` - value, which
basically going to be whatever gets passed in.

Here is the most interesting part,

// {{{ fadeTransition.js
[source, js]
----
.// fadeTransition.js
...
...
return {
    ...
    ...
    css: t => `opacity: ${t * 0"`
}
----
// }}}

The `"css"` - property is a method that takes in a `"t"` - value which is
a value between `"0'`  and `"1"`, and return some CSS that is calculated from
that `"t"` - value.

`"0"` means that the Element is full *off-screen*.

`"1"` means that the Element is fully *rendered*.

So in between there, we can see how you can interpolate in such a way that you
generate the illusion of a smooth Transition.

So the "fade" - Transition is literally just the `"t"` - value between
`"0'` and `"1"` multiply by the Elements default - `"opacity"`.

So if you start with an Element  that has an `"opacity: 0.5"`, then half-way
through the Transition, the `"opacity"` - of the Element will be `"0.25"`.

You can also return other things, including a `"tick()"` - function, which will
execute JavaScript on each frame. But most of the time we'll be using CSS
- Transition, because it's better for *performance*.

Very often, when you're doing Motion in JavaScript applications, what you'll
find, is that animation libraries do a lot of their work inside
`"requestAnimationFrame()"` - Handler, and that good. It gives you a lot of
flexibility and power, but it means that if any work happens that *block* the
"Main - Thread". That `"requestAnimationFrame()"` - Handler is also going to
get *blocked*.

What that means is, that your animations is going to be *blocking*. If you can
do things using CSS instead, then the CSS animation will often happen
completely off the "Main - Thread". So it will be uninterrupted by any work
that is happening elsewhere in the application.

So what it does is, it simulates running the Transition ahead of time. As soon
as we begin the Transition, Svelte will call that CSS - method with all of the
values between `"0"` and `"1"` immediately.

So call it with `"t = 0"`, `"t = 0.1"`, `"t = 0.2"`, and everything all the way
up to `"1"`, it will collect the return values and it will return it into a CSS
- animation that looks a little bit like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
0% { opacity: 0 }
10% { opacity: 0.1 }
20% { opacity: 0.2 }
/* ... */
100% { opacity: 1 }
----
// }}}

That how we cam tell the Element that it needs to "fade-in" and "fade-out".

It's little bit boring though, we can get a lot more ambitious.

So now we're going to create a Custom - Transition that we're going to call it
`"spin"`. We've got some boilerplate already, now I just got to implement it,
and that Spin - Transition is being applied to this `"<span>"` - Element.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { fade } from 'svelte/transition';
    import { elasticOut } from 'svelte/easing';

    let visible = true;

    function spin(node, { duration }) {
        return {
            duration,
            css: t => {
                const eased = elasticOut(t);
//                            ~~~~~~~~~~~~~


                return `
                transform: scale(${eased}) rotate(${eased * 1080}deg);
//              ~~~~~~~~~
                color: hsl(
               ${~~(t * 360)},
               ${Math.min(100, 1000 - 1000 * t)}%,
               ${Math.min(50, 500 - 500 * t)}%
          );`
            }
        };
    }
</script>

<label>
    <input type="checkbox" bind:checked={visible}>
    visible
</label>

{#if visible}
    <div class="centered" in:spin="{{duration: 8000}}" out:fade>
        <span>transitions!</span>
    </div>
{/if}

<style>
    ...
    ...
</style>
----
// }}}

First I'm going to add an `"easing"` function. Use `"elasticOut"`.

Again, that's that's going to take the value between `"0"` and `"1"`, and gives
another value on the same scale.

We're going to add `'transform:"`, which is going to change the `"scale"` and
the `"rotation"` of the Element.

I'm also going to change the `"color:"`. I'm using the `"hsl"` - colors,
because it's really convenient to be able to interpolate between different Hues
without changing other things.

Is much better color-space to work in if you're doing interpolation then RGB.

So we need to turn it into an Integer. This what this double - tilda mean
`"{~~()}"`.

Then just going to multiply `"t"` which is from `"O"` and `"1"` to multiply by
`"360"`. Because that the "Color - Scale". It's 360-degree Color -Wheel. That
the "*Hue* - value".

The *Saturation* is going to be the minimum of a `"${Math.min(100, 1000 - 1000
* t)}%"`, `"${Math.min(50, 500 - 500 * t)}%"`.

You don't need to know too much about what that's doing. We'll see the result
in a second.

Okay, and if I've doe this correctly. Then when I click this "checkbox"
visible, it's going to "spin-in" and change color in a culture to Smashing.

//{{{ image::./images/gif/chapter-4-12.gif
[#img-chapter]
[link=./images/gif/chapter-4-12.gif,window=_blank]
.Custom Transtition
image::./images/gif/chapter-4-12.gif[align="center"]
//}}}

Again this is all happening with CSS. Even though we've got a lot of very
"Custom - Logic" and we're using an `"easing()"` - function, the `"elasticOut"`
- easing function. That you don't get when you're writing CSS - animations. We
were able to do all of this "logic driven animation" in a way that runs as CSS
- animation and that's *high performance*.
// }}} ====



**⬆xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc set tw=79
// ▶
