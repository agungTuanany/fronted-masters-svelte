//{{{ ** ASCIIDOC HEADER
:description:   Front-end Masters course Svelte with Rich Harris | Chapter - 2
:url-repo:      https://github.com/agungTuanany/fronted-masters-svelte
:Author:        Agung Tuanany
:Email:         agung.tuanany@gmail.com
:Date:          Sun Apr 25 08:30:26 PM WIB 2021
:Revision:      -
:docinfo:
:docifnodir:
:prewrap!:
:figure-caption!:
:source-highlighter: highlight.js
//}}}

[[chapter_2_svelte_overview]]
= Chapter-2 Svelte overview

//{{{ == Table of Contents
[[_table_of_contents]]
== Table of Contents

[cols="10h, ~"]
|====
| 1.    | xref:_why_svelte[Why Svelte]
| 2.    | xref:_svelte_basics[Svelte Basic]
| 3.    | xref:_data_reactivity[Data Reactivity]
| 4.    | xref:_props[Props]
| 5.    | xref:_if_else_block[If - Else Block]
| 6.    | xref:_each_keyed_each_blocks[Each & Keyed Each Blocks]
| 7.    | xref:_asynchronous_await_blocks[Asynchronous Await Blocks]
| 8.    | xref:_events[Events]
|====
//}}}

// {{{ 1 == Why Svelte
[[_why_svelte]]
== Why Svelte
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead
:fn-write_less_code: https://svelte.dev/blog/write-less-code
:fn-svelte_is_compiler: https://svelte.dev/blog/frameworks-without-the-framework

So the obviousness question that a lot of people have is,  *what is Svelte*?

Exactly a lot of different ways to answer that question.

It's a lot of different things,  but it's probably easiest to understand it is
as an *alternative* to other existing projects that you're familiar with,  "React"
and "Vue" of the two most popular "*Component* - frameworks",  and Svelte
essentially solved a similar problem that
they do.

So,  what is a "Component - framework? Component Frameworks exist to help you
write applications more *declaratively*.

We use that word declare Actively a lot in programming. So it's helpful to
understand exactly what we mean by that.

This declarative code that I'm looking at here.

//{{{ svelte - example
[source,  html]
----
// svelte - example
<script>
    let count = 0;
</script>

<button on:click={() => count += 1}>
    Clicks: {count}
</button>
----
//}}}

This is some Svelte code is roughly equivalent to the vanilla JavaScript
beneath it.

//{{{ vanillaJS - example
[source, javascript]
----
// vanillaJS - example
function component() {
    let count = 0;

    const button = document.createElement('button');
    button.textContent = `Clicks: ${count}`;

    button.addEventListener('click',  () => {
            count += 1;
            button.textContent = `Clicks: ${count}`;
            });

    return button;
}
----
//}}}

You can see what's happening with creating a button using
`document.createElement()` and then we're putting some text inside it.

Then adding an "Event Listener" to,  when you click the button,  it increments
the value of `"count"` and then it updates the `"textContent"` inside the
button.

Then we return that. That's our component.

So the difference is in the *"imperative"* - version with telling the browser
exactly what to do.

In the *"declarative"* - version. We're just saying what outcome we want; And
that's obviously a lot simpler for the developer,  because we're not having to
work through the process of explaining to the browser exactly what it needs to
do each given moment.

More to the point. There's no duplication. Here We've got this initial
`"button.textcontent"` equals "blah"; and then inside the "update Handler",
we've got the same thing.

You tend to find that when you're building web applications,  you have a lot of
that kind of *duplication*. You have the "initial render" and then you have the
"update".

But if you're doing things declaratively,  that's no longer the case.

But it gets worse for the *"imperative"* story. If you want to make a very
small change to your component. For example,  you want to wrap that `"count"` -
variable in a *strong element*. Then if you're doing it,  imperatively,  you need
to almost rewrite the entire component. That's for a very small change.

So you can imagine,  if you're building a large application,  the amount of work
that you would have to do is,  you're *iterating on your design* is much - much
greater with *"imperative'* - code.


So that's the value that component framework provide. They make it a lot easier
for us as developers to build applications.

Historically,  though there has been a little bit of an implicit "trade-off".
Because the framework acts as a *middleman* between you and the browser. With
the middleman introduces inefficiency.

// {{{ === How is Svelte Different?
[[_how_is_svelte_different]]
=== How is Svelte Different?

So,  Svelte began back in 2016. Is an experiment to prove that is,  in fact,  a
*"FALSE - DICHOTOMY"*. There is no tension between *"developer - experience"*,
and *"user - experience"*.

Svelte is a *COMPILER*. It takes your *"declarative"* - code and it turns it
into the equivalent *"imperative"* - JavaScript.

Then this has a number of really useful advantages.

- First. Your apps will *generally be quite a lot smaller*.

Because we don't need to have the *actual framework runtime* in the browser.
Normally, the framework has to anticipate every possible use case,  but because
Svelte understands exactly what is going into your app. It can discard most of
it in just ship the code that is actually needed for your specific use case.

JavaScript is the most expensive thing on the web bite for bite. Because you
don't just have to download it. You also have to pause and evaluate it,  and so
if we can use less of it than your apps are going to launch quicker and your
users will be happier.

- Second. You apps will be *Faster*.

Once your applications have already launched,  your apps are going to be faster.
Because we don't need to use costly techniques like *"re-rendering"* the
{fn-virtual_dom}["virtual Dom"] and then dipping it to find out what needs to
change on the page.

Instead,  we can make surgical granular updates. The compiler knows which bits
of the application could change for a given "State" - change,  and it can just
change the "Dom" directly the same way that you would do,  if you using the "Dom
- API" manually.

- Finally,  Your app will be *easier to write*.

Because we have a lot more control over the *"authoring"* - experience. We
don't have the same constraints that are the people do. What this means in
particular,  is that if you're using Svelte,  you will be able to write less
code.


There's a blog post link there that I invite you to check out which explains
why {fn-write_less_code}[writing less code] is so important.  Writing less
code,  means that you'll have fewer *"bugs"* and to be able to spend more time
Outdoors.

Beyond that Svelte aims to make your life easier by shipping a lot of the
things that normally you would have to do as third party liability would
install from "NPM".

So things like *"State - management"*,  *"Element - transitions"*,  *"handling
input"* via "Form" - elements,  scope - CSS. All of those things. Normally with
a framework,  those are things that you have to figure out a solution to
yourself.

But was Svelte,  it's already *built in*,  and we can do that because again,
{fn-svelte_is_compiler}[*we're a "compiler"*],  we can discard the bits that
we're not using.
// }}} ===

// {{{ === Who Make Svelte?
[[_who_make_svelte]]
=== Who Make Svelte?

Well,  it is very much a *community project*.

It's not a project with full-time engineers and corporate funding. It's a
project that is developed in the open by a group of volunteers who work on it,
in their free time. Because we believe in the project.

There is a core team of developers who do the day-to-day stuff,  but the broader
contributor Community is large,  and every decision that we make about,  the
future of the framework is done to the greatest extent possible out in the
open.

Egalitarians,  Communitarian project. We welcome developers of all backgrounds
and with all skill levels,  and we would love for you to be involved as well.

So with that,  I'm going to move on to the next part of the workshop where we're
going to run through the entire Svelte tutorial to learn how to build stock
components.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
//}}}

//{{{ 2 == Svelte Basics
[[_svelte_basics]]
== Svelte Basics
:fn-svelte_dev_tutorial: https://Svelte.dev/tutorial/basic
:fn-virtual_dom: https://svelte.dev/blog/virtual-dom-is-pure-overhead


Okay. So in this section, we're going to go through the entire "Interactors" Svelte
tutorial. By the end of it, you'll have a complete grasp of what's Svelte
can do and how you're right Svelte Component.

So what I invite you to do is in a new tab in you browser, go to
{fn-svelte_dev_tutorial}[Svelte-tutorial,window=_blank] and we're just going to
go through the whole thing top to bottom, Soup To Nuts.

Now, this has some introductory Spiel that I've already basically explained. So
I'm going to just go down there and click on the next button. And we'll begin
with our "Hello world!" - Component.

// {{{ === Adding Data
[[_adding_data]]
=== Adding Data

//{{{ image::./images/chapter-2-1.png
[#img-chapter]
[link=./images/chapter-2-1.png,window=_blank]
.Svelte Basic -1
image::./images/chapter-2-1.png[align="center"]
//}}}

So the first thing that you'll notice is that we're writing
HTML into this window here, this `"app.svelte"` - window.

The reason that we use *"HTML"* is our base
language instead of JavaScript is, HTML is *designed to contain* CSS and
JavaScript. So all of the three languages of the web, they all fit together in
Svelte - Component in a very idiomatic way.

//{{{ <h1>Hello World!<h1>
[source, html]
----
<script>
    let name = 'world';
</script>

<h1>Hello {name}!</h1>
----
//}}}

The first thing that we need to do is
*add some data*, so going to create a script tag, Up here; and then we're going to
create a variable, call it `"name"`,  and we'll just give it a value `"world"` like that.

Then inside the *markup*, we can refer to that value by putting it inside
curly braces `"{}"`. Like so.

Now, inside these curly braces (`"{name}"`), we can have any valid
JavaScript. So we can change that to `"{name.toUpperCase}"`, for example.

//{{{ image::./images/chapter-2-1.gif
[#img-chapter]
[link=./images/gif/chapter-2-1.gif,window=_blank]
.Svelte Basic -2
image::./images/gif/chapter-2-1.gif[align="center"]
//}}}

Then obviously as we change that It will re-render the application.

//{{{ image::./images/chapter-2-2.png
[#img-chapter]
[link=./images/chapter-2-2.png,window=_blank]
.Svelte Basic -2
image::./images/chapter-2-2.png[align="center"]
//}}}

NOTE: By the way, if you ever get stuck, while going through these tutorials
and you want to just skip to the end to the end result, then you can click on
the `"Show Me"` - button down here, and it will take you straight to the end
State and then you can click reset back to the beginning.
// }}} ===

// {{{ === Dynamic Attribute
[[_dynamic_attribute]]
=== Dynamic Attribute

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img src={src}>
//   ~~~~~~~~
----
//}}}

Now,   in the same way that we can use curly braces
to put text inside our application, we can use it inside Element - attributes.

So our `"<image>"` - tag here is missing a source attribute (`"<src="">"`). Add
one like that and give it the value of `"src={src}"`,  which is in the script
block.

//{{{ image::./images/chapter-2-3.png
[#img-chapter]
[link=./images/chapter-2-3.png,window=_blank]
.Svelte Basic -3
image::./images/chapter-2-3.png[align="center"]
//}}}

This orange bar beneath
beneath. The mark-up is telling us that an image element should have an `alt=""`
- attribute and this is really important, this is an *accessibility* matter.

Most
people, when they're using a website, they can see the content of the image and
they don't need an `alt=""` attribute.

But there are a lot of users for whom that's not true. That includes people
with impaired Vision who are using assistive Technologies like screen readers.

But it also includes people who are on a slow connection and they've got the
marker but it hasn't yet been able to load the content of the image. So it's
very important that we *always add* an `alt=""` - attribute to *describe* what
is in the image.

So, in this case, `alt="A man dances"`.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
</script>

<img alt="A man dances" src={src}>
----
//}}}

Now accessibility is a *big* and *difficult* topic and there's no way that a
framework likes Svelte can automatically check that you are writing accessible
markup in every case.

For example, this `alt=""` - tag could be absolute gibberish, and it
wouldn't know any better.

So you do have to understand the purpose of the
"accessibility" - *warnings* and make sure that you are actually building accessible
markup, and that includes things like making sure that the "contrast ratio" on the
content that you're building a high enough.

But Svelte will do the best that it can to make sure that you're not making any
*obvious mistakes*, like *putting markup* that's *inaccessible* on the page.

Now, we can also use the curly braces inside, attributes.  So,  let's say we
wanted to add Value name. Then we can put that inside the attribute there.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" src={src}>
----
//}}}

Then if I open my "dev - tools" and inspect this
image, You'll see that the alt attribute has been applied as we expect.

//{{{ image::./images/chapter-2-4.png
[#img-chapter]
[link=./images/chapter-2-4.png,window=_blank]
.Svelte Basic -4
image::./images/chapter-2-4.png[align="center"]
//}}}

Now we very often run into this situation here where we have an attribute
- `"name"` and `"value"` (`name='value'`) that match. So we have a convenient
shorthand installed.  We can just get rid of the attribute - `"name"` and the
equals (`" = "`) in this case (`src=""`) and pass it through like this,

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<script>
    let src = 'tutorial/image.gif';
    let name = "Rick astley";
</script>

<img alt="{name} dances" {src}>
//                       ~~~~~
----
//}}}

*That's something that will do quite a lot in this Workshop*.
// }}} ===

// {{{ === Styling
[[_styling]]
=== Styling

Now, I mentioned
before that a small component because it's HTML, it can contain JavaScript and
CSS. So we're going to add some CSS to a component.

//{{{ Dynamic Attribute
[source, html]
----
// Dynamic Attribute
<style>
    p {
        color: purple;
        font-family: "Comic Sans MS", cursive;
        font-size: 2em;
    }
</style>

<p>This is paragraph</p>
----
//}}}

We'll open a `"p"` selector and then make it `color: purple`. Give it a nice
"font" (`"font-family:"`), and we'll bump at the size (`"font-size:"`) a little
bit.

Right.And you'll see that it's applied.

//{{{ image::./images/chapter-2-5.png
[#img-chapter]
[link=./images/chapter-2-5.png,window=_blank]
.Svelte Basic -5
image::./images/chapter-2-5.png[align="center"]
//}}}

Those files to the paragraph As we would expect.
// }}} ===

// {{{ === Nested Component
[[_nested_component]]
=== Nested Component

But wait there's more,  it's Svelte that you have "Nested - Components",
that is to say *a command* can contain *other* components.

In that situation, we don't want the Styles from One Component to *affect*
other Components on the page. Because then it becomes very difficult to
understand where a given style is coming from.

So Svelte actually *Scopes* the Styles inside a component, to just the
markup that belongs in the same Component.

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    p {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

We can show this by During the "script tag" that Imports are "Nested
Component". Just select that whole block and paste it at the top of
`"app.svelte"` that Imports The `:Nest.component"`, which is visible in this
tab here. Then we'll (`"<Nested />"`) put that underneath our paragraph.

//{{{ image::./images/chapter-2-6.png
[#img-chapter]
[link=./images/chapter-2-6.png,window=_blank]
.Svelte Basic -6
image::./images/chapter-2-6.png[align="center"]
//}}}

So the first paragraph `*[1]*` has the Styles defined here but they don't
affect the second paragraph `*[2]*`. Even though it's the same element.

//{{{ image::./images/chapter-2-7.png
[#img-chapter]
[link=./images/chapter-2-7.png,window=_blank]
.Svelte Basic -7
image::./images/chapter-2-7.png[align="center"]
//}}}

The way that this works under the hood is, that *"Svelte - Scopes"* the "CSS -
selector" with a "generated *hash*" (`".svelte-xxx"`).

That is computed from the contents of your style blog. It puts that CSS - class
on the selector in the CSS output, and it also puts it on the element.

With that way, there's no possibility of these selectors *clashing* between
different Components.

Obviously it goes the other way as well.

If I had a style in `"Nested.svelte"`,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    text-transform: uppercase;
    color: blue;
</style>
<p>This is a paragraph.</p>
----
//}}}

//{{{ image::./images/chapter-2-8.png
[#img-chapter]
[link=./images/chapter-2-8.png,window=_blank]
.Svelte Basic -8
image::./images/chapter-2-8.png[align="center"]
//}}}

They will affect the "child - Component" but not the "parent - Component".

We can also do something else. That's quite interesting.

Normally, when you're writing CSS, you have this phenomenon of the *append*
only style-sheet where you add some Styles, and then you add some more Styles
and then you add some more smiles and then you're NOT sure if you still need
these files. But you're *scared* to remove it because you don't know what is
affected by it. Because CSS is inherently Global.

But because we don't have that problem. Because our styles are
Scoped to the Component. We can remove the styles that *aren't used* inside the
Component, by *analyzing* the CSS and the markup together and seeing which select
Being applied.

So if we have this `".unused"` - class here,

//{{{ Nested.svelte
[source, html]
----
// Nested.svelte
<style>
    P {
        text-transform: uppercase;
        color: blue;
    }

    .unused {
        color: red;
    }
</style>
<p>This is a paragraph.</p>
----
//}}}

Then we look at the CSS output.

//{{{ image::./images/chapter-2-9.png
[#img-chapter]
[link=./images/chapter-2-9.png,window=_blank]
.Svelte Basic -9
image::./images/chapter-2-9.png[align="center"]
//}}}

That `"color: red"` has been stripped out. It's not included in the CSS that
gets sent to browser.  It's also give a convenient warning tells us that
there's *unused* CSS selector.

So we can go ahead and remove that from our source code.
// }}}

// {{{ === HTML Tags
[[_html_tags]]
=== HTML Tags

By default, when you have a curly brace `" {} "` with a JavaScript expression
inside. It is evaluated as *"text"*. Which means that I click over the result
- tab, this String contains HTML.  We can actually see the angle bracket `"<
>"` of that time of that tags.

In some situations, you want to put the actual HTML on the page and that's
really easy to do. We just prefix it with `"{@html string}"`. So Special
type of tags.

// {{{  HTML tags App.svelte
[source, html]
----
// App.svelte
<script>
    let string = `this string contains some <strong>HTML!!!</strong>`;
</script>

<p>{@html string}</p>
----
// }}}

Then now you can see that. This "bold" - text now.

//{{{ image::./images/chapter-2-10.png
[#img-chapter]
[link=./images/chapter-2-10.png,window=_blank]
.Svelte Basic -10
image::./images/chapter-2-10.png[align="center"]
//}}}

Now, there is a big caveat here. There's *NO sanitation* that happens.

What that means is, that you could potentially inject some *dangerous* HTML. So
you need to make sure that HTML that you're putting inside your Component comes
from source that you trust.

If it's coming form a source that you don't trust. Like some "user - input"
that you don't control, then you need to make sure that you sanitize that HTML
to remove any "Script - tags" or anything else that could be used in
a *"cross-site scripting attack"* before you include that on a page that is
visible to another user.
// }}} ===

// {{{ === Add Global Styles
[[_add_global_styles]]
=== Add Global Styles

Okay, so we just had a great question about how whether you can add "Global
Styles" if you need to?

So we're going to skip back to the section on "Nested - Component".

We're going to out that nested paragraph inside the Component.

In this time, in our `"App.svelte"` we're going to changes this `"p {}"`
- Selector to a Global `"p {}"` - Selector. We do that using some syntax that
we stole from "CSS - modules" project `":global()"` and we wrap the `"p"`
selector like so,

//{{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Nested from './Nested.svelte';
</script>

<style>
    :global(p) {
        color: purple;
        font-family: 'Comic Sans MS', cursive;
        font-size: 2em;
    }
</style>

<p>This is a paragraph.</p>     // [1]
<Nested />                      // [2]

// Nested.svelte
<p>This is a paragraph.</p>
----
//}}}

Now every `"p {}"` - element on the page will be affected those Styles and the
way that works.

//{{{ image::./images/chapter-2-11.png
[#img-chapter]
[link=./images/chapter-2-11.png,window=_blank]
.Svelte Basic -11
image::./images/chapter-2-11.png[align="center"]
//}}}

If you look at the CSS - output, just hasn't bothered to apply the Scoping
selected "Class - name" do that Selector.

//{{{ image::./images/chapter-2-12.png
[#img-chapter]
[link=./images/chapter-2-12.png,window=_blank]
.Svelte Basic -12
image::./images/chapter-2-12.png[align="center"]
//}}}

So that useful. If you need to do something like change styles on the "Body
- Element". Because obviously you're not going to have the Body - Element
inside your Component.

But generally, that's something that you don't want to use too much if you have
Global Styles.

I personally think they should go in a `"global.css"` - file. That's where
I put my Rules about `"colors"` and `"typography"`. All of my "CSS - Variables"
of the page.

But this techniques is a useful escape hatch for the times that you do need it.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
//}}}

// {{{ 3 == Data Reactivity
[[_data_reactivity]]
== Data Reactivity

// {{{ === Reactivity / Assignment
[[_reactivity_assignment]]
=== Reactivity / Assignment

So far all the data we've used inside this Components has been *static*. It
hasn't changed.  But a lot of time when you're building web app, the data in
your Components will change and Svelte has a powerful system of *Reactivity* to
make that possible.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
let count  = 0;

function handleClick() {
    count += 1;
}
</script>

<button onclick={handleClick}>
    Clicked {count{ {count === 1 ? "time" : "times"}
</button>
----
// }}}

So first, we're going to add an Event - handler to this "button". We are go
into more detail about Event - handlers.  What they are and how they work in
a later section of this tutorial.

But for now just roll with it. `"on:click"` equals and then `"handleClick"`
give it a reference to this function. Which is defined inside our `<script>`
- block. Then we just need to implement `"handleClick()"`, and is very simple.
`"count += 1"`.

Now when we click this button, the `"count"` clicks up.

The way this works is, that Svelte instruments the "Assignment". When it sees
this `"count += 1"` it replaces that with in "generated code", which we'll look
at in more detail later.

It Instrumented with this call to a function called `*"$$invalidate()"*`

//{{{ image::./images/chapter-2-13.png
[#img-chapter]
[link=./images/chapter-2-13.png,window=_blank]
.Svelte Basic -12
image::./images/chapter-2-13.png[align="center"]
//}}}

Which tells the component that a specific value is changed.

The Component in turn, tells that "Svelte - *Scheduler*" that the Component
needs to be re-rendered.

That is how Reactivity works on a per-value level.
// }}} ===

// {{{ === Reactivity / Declarations
[[_reactivity_declarations]]
=== Reactivity / Declarations

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;
    let doubled = count * 2;

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>
----
// }}}

Now, very often you'll have some State that is *derived* from other parts of
your State.  So you got button here that increments the "counter".

Let's say we want to add a *double value* which is `"count"` times  `"2"`. We
could do this `"let double = count * 2"` and then add some text beneath it
`"{count} doubled is {doubled}"`.

But it's not updating. The reason for that is, the contents of this
`"<script>"` - block executes *once* when a Component is created per Component.
So this `"let doubled = count * 2"`, that going to run at the start of the
Component - "Life cycle".  Then it's never going to be re-run.

//{{{ image::./images/chapter-2-2.gif
[#img-chapter]
[link=./images/gif/chapter-2-2.gif,window=_blank]
.Svelte Basic -13
image::./images/gif/chapter-2-2.gif[align="center"]
//}}}

We want that statement to re-run every time the value of `"count"` changes, and
we ca do that with a convenient little piece of syntax. Change that `"let"` to
`"$:"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;
    $: doubled = count * 2;
// ~~~

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>
----
// }}}

//{{{ image::./images/chapter-2-3.gif
[#img-chapter]
[link=./images/gif/chapter-2-3.gif,window=_blank]
.Svelte Basic -14
image::./images/gif/chapter-2-3.gif[align="center"]
//}}}

It doubled as you would expect.

Now this might look a little bit strange. Because this isn't JavaScript syntax
that you're probably familiar with, is in fact, valid JavaScript. This `"$:"`
called a *"Label"*, and it's used when you're building a `"while - loop"` or
`"while - loop"`.

You have a *"Label"*, then later you can do break "Label - name". That allows
you to control the flow of your application.

In a way you don't generally don't need. Outside the context of "loop" it has
no value whatsoever.

So when we were buildings Svelte we though, let's just steal that.

The reason that we have to make everything *valid* - JavaScript is, because as
I'll explain you later, we're using off the Svelte - JavaScript passes to pass
everything inside the `"<script>"` - block.

So everything has to be "Syntactically - VALID". But it doesn't mean that this
`"$: doubled = "` need to behave the way that if would ordinary behave inside
JavaScript.

We get to make the rules. So, this `"$:"` here what we call a *"Reactive
- Declaration"*.

We can have as many as we like. So I can have one that depends on Reactive
- Value of `"doubled'.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let count = 0;

    $: quadrupled = doubled * 2;
    $: doubled = count * 2;
// ~~~

    function handleClick() {
        count += 1;
    }
</script>

<button on:click={handleClick}>
    Clicked {count} {count === 1 ? 'time' : 'times'}
</button>

<p>
    {count} doubled is {doubled}
</p>

<p>
    {count} quadrupled is {quadrupled}
</p>
----
// }}}

That also works as you would expect.

You will notice that these,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...

    $: quadrupled = doubled * 2;
    $: doubled = count * 2;

    ...
    ...
</script>
----
// }}}

Aren't defined in the order that they wouldn't ordinary need to run.  Instead
they are executed in what's called "Topological - Order".

Which means that Svelte understand the `"quadrupled"` depends on the value of
`"doubled"` and therefore need to calculated `"doubled"` before it calculate
`"quadrupled"`.

So this might look a little bit weird and a little bit alien. But I promise you
that, once you get used to it, it becomes second nature and it's a very
convenient feature.
// }}} ===

// {{{ === Reactivity / Statement
[[_reactivity_statement]]
=== Reactivity / Statement

It's not just Declarations that we can run Reactively. We can also run any
*arbitrary* - Statement in the same way.

So, for example. We can do

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: console.log(`the count is ${count}`)
...
...
</script>
----
// }}}

Then you see in console - column it gets logged every time the value changes.

So that's really useful for debugging.

You also can group Statement together by a *group*.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: {
        console.log(`the count is ${count}`);
        alert(`I SAID THE COUNT IS ${count}`);
    }
...
...
</script>
----
// }}}

You can even put the `"$:"` in front of things like `"if"` - blocks.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    $: if (count >= 10) {
        alert(`count is dangerously high!`);
        count = 9;
    }
...
...
</script>
----
// }}}
// }}} ===

// {{{ === Reactivity / Updating Arrays and Objects
[[_reactivity_updating_arrays_and_objects]]
=== Reactivity / Updating Arrays and Objects

It's also not just simple Primitives that we can update in this fashion. We can
also use the Reactivity to updates Arrays and Objects.

But there is a caveat, which we're going to explore here.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let numbers = [1, 2, 3, 4];

    function addNumber() {
        numbers.push(numbers.length + 1);
    }

    $: sum = numbers.reduce((t, n) => t + n, 0);
</script>

<p>{numbers.join(' + ')} = {sum}</p>

<button on:click={addNumber}>
    Add a number
</button>
----
// }}}

So we have this function `"addNumber()"`, which is going to push to our
`"numbers"` - Array. If I click the button it's not doing anything.

That because `"numbers.push*()"` is not Reactive.

Svelte doesn't look at that and say oh, when you taking this Array, therefore,
we need to recalculate anything that involves `"numbers"`. It needs to see an
assignment, that how the system works.

So we can do underneath `"numbers = numbers"`.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = numbers;
    }
...
...
</script>
----
// }}}

That one way of doing this.

But it's not very idiomatic. It looks a little bit weird. It's useful in
a pinch. But it's actually better if rather than mutating that `"numbers"`
- Arrays and then reassigning it to itself, if we can create a new copy of that
Array.

So, we create a new - Array, spread the existing value into it, spread the
existing value, and then add the new value.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = [...numbers, numbers.length + 1]
    }
...
...
</script>
----
// }}}

Now if you try to click `"Add a number"` - button. It's exactly works the same
way, and you can use similar *pattern* to replace `"pop()"`, `"shift()"`,
`"unshift()"` and `"splice()"`.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 4 == Props
[[_props]]
== Props

// {{{ === Reactivity / Updating Arrays and Objects
[[_reactivity_updating_arrays_and_objects]]
=== Reactivity / Updating Arrays and Objects

We can also assign directly to properties of a recent Objects. The same way
that we assign two free.

So another way that we could do this is,

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
...
...
    function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = [numbers.length] = numbers.length + 1;
    //            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    }
...
...
</script>
----
// }}}

That works exactly how you would expect.
// }}} ===

// {{{ === Props / Declaring Props
[[_props_declaring_props]]
=== Props / Declaring Props

Some point when you're building an application, you're going to need to pass
data from one Component to another, and for that we use something called a *"Prop"*.

A "Prop" is basically like an *attribute* on an Element and it stand for "Properties".

// {{{ Nested.svelte
[source, html]
----
<script>
// Nested.svelte
    let answer;
</script>

<p>The answer is {answer}</p>
----
// }}}

So here we have some State inside the `"Nested.svelte"` Component `"answer"`,
and we are showing it inside this `<p>` - tag, and it's coming across as `"undefined"`.

Even though we're passing it from `<Nested answer={42} />`.

// {{{ App.svelte
[source, html]
----
<script>
// App.svelte
    import Nested from "./Nested.svelte";
</script>

<Nested answer={42} />
//~~~~~~~~~~~~~~~~
----
// }}}

The reason for that is, that as far Nested - Component (`"Nested.svelte"`) is
concerned, this `"let answer"` is *private State* that nothing else gets to interfere.

With what we need to do is, tells Svelte that answer should be considered
a property that can be set by a Parent - Component.

The way we do that is, again by abusing some existing JavaScript syntax. We're
going to use `"export"` - keyword.

This tell Svelte that, if the Parent sets the value for `"answer"` we just pass
it through, and obviously we change that, it'll update in the manner that you
would expect.

So there's a little caveat down here. This might seem a little bit weird if
you're used to using the `"export"` keyword in your JavaScript modules.

Again, it has to be syntactically valid and this is a really convenient way of
using something that's in the language that we weren't. Otherwise be very
difficult and awkward.

So just kind of roll with it for now, and it will soon become a second nature.

So we can set a d default value for an `"answer"` like,

// {{{ Nested.svelte
[source, html]
----
<script>
// Nested.svelte
    let answer = "a mystery";
    //            ~~~~~~~~~
</script>

<p>The answer is {answer}</p>
----
// }}}

Then if the Parent - Component doesn't provide a value for that `"Prop"` then
it will fall back to the default.

//{{{ image::./images/chapter-2-14.png
[#img-chapter]
[link=./images/chapter-2-14.png,window=_blank]
.Svelte Basic -15
image::./images/chapter-2-14.png[align="center"]
//}}}

First `"answers"` is `"42"`, and the second `"answers"` is determined by the
Child.
// }}} ===

// {{{ === Props / Spread Props
[[_props_spread_props]]
=== Props / Spread Props

Finally in Props section we have the concept of "Spread - Props".

Sometimes you have bundle of properties and you want to pass them all through to component.
In some situation, you might not know what it is going to be in that Object and physically unable to say `"a = b"`,
`"b = c"`, `"c = d"`, because you don't know what it's going to be.

So we use Spread - syntax `" ... "` which look like this,

[source, html]
----
<Info {...pkg}/>
----

I'm just get rid all of these individual properties.

[source, html]
----
<Info name={pkg.name} version={pkg.version} speed={pkg.speed} website={pkg.website}/>
----

Pass them through like so,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import Info from './Info.svelte';

    const pkg = {
        name: 'svelte',
        version: 3,
        speed: 'blazing',
        website: 'https://svelte.dev'
    };
</script>

<Info {...pkg}/>
----
// }}}

Then inside `"Info.svelte"` we're exporting all of the properties that "Spread
- Object", as "individual - Props".

So nothing needs to change inside the Child - Component.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 5 == If - Else Block
[[_if_else_block]]
== If - Else Block

In just about every web application, you will need to use logic inside your
template. Whether that's `"if{}"` - blocks to control whether or not something
rendered, or each `"block{}"` - block switch control how list of thing are
rendered.

An HTML, doesn't have native way of declaring conditions, so we've added some
syntax insights Svelte that lets you do that.

// {{{ === Logic / If Block
[[_logic_if_block]]
=== Logic / If Block

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    function toggle() {
        user.loggedIn = !user.loggedIn;
    }
</script>

<button on:click={toggle}>
    log out
</button>

<button on:click={toggle}>
    log in
</button>
----
//}}}

So we got two buttons. One is `"Log in"` - button, another is `"Log out"`
- button. We only want to show *one at a time* because "mutually exclusive". We
can do that by wrapping the buttons in an `"if"` - block that looks like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    function toggle() {
        user.loggedIn = !user.loggedIn;
    }
</script>

{#if user.loggedIn}
    <button on:click={toggle}>
        log out
    </button>
{/if}

{#if user.loggedIn}
    <button on:click={toggle}>
        log in
    </button>
{/if}
----
//}}}

So now any *one* of the buttons are shown at any one time.

If you click the button, then it's no longer rendered and its gets replaced
with the opposite button.
// }}} ===

// {{{ === Logic / Else Block
[[_logic_else_block]]
=== Logic / Else Block

Now it's a common case, the two conditions `"user.loggedIn"` and
`"!user.loggedI"` in mutually exclusive. So we can replace the two `"if{}"`
- block with single `"if-else{}"` - block. Just like you would do i JavaScript.

// {{{ App.svelte
[source, html]
----
// App.svelte
function toggle() {
    user.loggedIn = !user.loggedIn;
}
</script>

{#if user.loggedIn}
    <button on:click={toggle}>
        log out
    </button>
{:else}
    <button on:click={toggle}>
    log in
    </button>
{/if}

----
//}}}

Above `"if-else{}"` - block behave exactly the same way.

So there are *three* new bits of syntax here,

- When we're *opening* a block, we use the 'pound' - sign `" # "`,

- When we're *continuing* a block, we use the 'colon' - sign `" : "`,

- Remember *closing* it, we use the 'slash' - sign, `" / "` like you are
  closing an Element

That's  something you'll see in other of block we'll introduce soon.

That's basically the entirety of the Svelte syntax that you need to learn,
apart from "Element - directors", which will come to you soon.
// }}} ===

// {{{ === Logic / Else-If  Block
[[_logic_else_if_block]]
=== Logic / Else-If  Block

We can also have `"else-if{}"` blocks.

// {{{  App.svelte
[source, html]
----
// App.svelte
<script>
    let x = 7;
</script>

{#if x > 10}
    <p>{x} is greater than 10</p>
{:else}
    {#if 5 > x}
        <p>{x} is less than 5</p>
    {:else}
        <p>{x} is between 5 and 10</p>
    {/if}
{/if}
----
// }}}

So, above code we've got an `"if{}"` - block, and then `"else{}"` - block. Then
inside `"else{}"` - block, we've got another `"if-else{}"` - block.

It would be easier if we could have `"{:else if 5 > x}"` .

// {{{  App.svelte
[source, html]
----
// App.svelte
...
...

{:else if 5 > x}
    <p>{x} is less than 5</p>
{:else}
    <p>{x} is between 5 and 10</p>
{/if}
----
// }}}

So `"x"` equals to `"7"`, if it's greater than `"10"` render this `"<p>{x} is
greater than 10</p>"`.

Otherwise?

If it's greater than or if it is less than `"x"` then show `"<p>{x} Is between
5 and 10</p>"`.

We've done everything, and that behaves is, it was it exactly as it would in
JavaScript.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 6 == Each & Keyed Each Blocks
[[_each_keyed_each_blocks]]
== Each & Keyed Each Blocks

So, in most web applications, you need to loop over a list of data. At some
point.

// {{{ === Logic / Each Blocks
[[_logic_each_blocks]]
=== Logic / Each Blocks

// {{{ App.svelte
[source, html]
----
<script>
    let cats = [
        { id: 'J---aiyznGQ', name: 'Keyboard Cat' },
        { id: 'z_AbfPXTKms', name: 'Maru' },
        { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' }
    ];
</script>

<h1>The Famous Cats of YouTube</h1>

<ul>
<!-- open each block -->
    <li><a target="_blank" href="https://www.youtube.com/watch?v={cat.id}">
    {cat.name}
    </a></li>
    <!-- close each block -->
</ul>
----
// }}}

Here, we have a list of data of the celebrated `"cast"` of YouTube, and the
way that we ca loop over them is Svelte - Components is, with the `"each{}"`
- block. Than looks a little bit like this,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

{#each cats as cat}
    <li><a target="_blank" href="https://www.youtube.com/watch?v={cat.id}">
        {cat.name}
    </a></li>
{/each}
----
// }}}}

Each `"cats"` as  `'cat"`, and then close it with the slash - sign `" / "`
again.

That renders our list.

So this `"cat"` - variable, is being created by the `"each{}"` - block, and
then you can use that inside it, to pull out `"{cat.id}"` in `"cats"` - Array
of Object property, and `"{cat.name}"`.

Often you'll also need to get the `"index"` of the current Element. So in the
same way that you would have a *second - argument*, if you are using
a `"array.map()"` or `"array.forEach()"`. You can do something here,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

{#each cats as cat, i}
//                 ~~
    <li><a target="_blank" href="https://www.youtube.com/watch?v={cat.id}">
        {i + 1}: {cat.name}
    //  ~~~~~~
        </a></li>
{/each}
----
// }}}}

//{{{ image::./images/chapter-2-15.png
[#img-chapter]
[link=./images/chapter-2-15.png,window=_blank]
.Svelte Basic -16
image::./images/chapter-2-15.png[align="center"]
//}}}

So, we use `"i"` as "second - argument", and then inside `"each{}"` block we
can do `"{i + 1}"`, and then the cats are numbered.

We can also use the "destructuring " inside here, the same way that you could
in a regular JavaScript - function.

So instead of passing trhough this `"cat"` - value, we can destructure it into
its Component - properties.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

{#each cats as {id, name}, i}
//             ~~~~~~~~~
    <li><a target="_blank" href="https://www.youtube.com/watch?v={id}">
        //                                                       ~~~~
        {i + 1}: {name}
    //           ~~~~~~
        </a></li>
{/each}
----
// }}}}

We choose `"{id, name}"`, and then replace the references `"cat."` with the
values directly like so `"{id}"` and `"{name}"`.
// }}} ===

// {{{ === Logic / Keyed Each Blocks
[[_logic_keyed_each_blocks]]
=== Logic / Keyed Each Blocks

Now, *"keyed"* - blocks are a little bit harder to explain, so bear with me.

What happend before, was that we created a list and then if that list were to
*change", it would always

- *add* items at the end of the list, or

- remove items from the end of the list.


It wouldn't remove items from the middle of the list, or add items in the
middle of the list.

That is sometimes a problem.

So in this component. In this `"Thing.svelte"`. We're exporting a value called
`"current"`. But we're also creating a value called `"initial"`, which is
*fixed* to the value of `"current"`, when the Component  is first instantiated.

We're doing that so that we can demonstrate something that goes wrong when you
are using a regular `"each{}"` - block.

If we remove the first item from this Array,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

let things = [
    { id: 1, color: 'darkblue' },
    { id: 2, color: 'indigo' },
    { id: 3, color: 'deeppink' },
    { id: 4, color: 'salmon' },
    { id: 5, color: 'gold' }
];
----
// }}}

And this is what our block look like,

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

{#each things as thing}
    <Thing current={thing.color}/>
{/each}

----
// }}}

We have `"<Thing />"` - Component, and we're passing `"{thing.color}"`. If we
click the `"Remove first thing"` - button.

//{{{ image::./images/chapter-2-4.gif
[#img-chapter]
[link=./images/gif/chapter-2-4.gif,window=_blank]
.Svelte Basic -17
image::./images/gif/chapter-2-4.gif[align="center"]
//}}}

Then the current value is changing, it's passing through the second, third,
fourth, and fifth - values of the Components.

If we press once again that button, now the third, fourth, and fifth as values
of the Component and so on.

But the Components themselves, have the first value and the second value. That
*obviously wrong*, because we want those two things to match.

What we want. When we remove the first thing, is for the first component to get
taken out, for the second, third, fourth, and firth to stay where they are.

Rather than removing the fifth  - Component, and then the fourth - Component,
and then changing the data inside them.

To do that, we use the `"keyed"` to `"each{}"` - block.

The way that works is, inside the `"each{}"` - block opening tag, we specify
a way of indenting each item uniquely.

We put that inside parentheses like so, `"(thing.id)"`

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...

{#each things as thing (thing.id)}
    <Thing current={thing.color}/>
{/each}

----
// }}}

//{{{ image::./images/chapter-2-5.gif
[#img-chapter]
[link=./images/gif/chapter-2-5.gif,window=_blank]
.Svelte Basic -18
image::./images/gif/chapter-2-5.gif[align="center"]
//}}}

Now when you remove the first thing, instead of removing the last item, and
then changing the data and all others. It's actually going to remove the first
`"thing"` - Component. So the color continue to match.

This become *particularly important* when you start using "Element
- Transition" on items inside of `"each{}"` - block.

It's also generally more efficient. If you have this type of data that's
changing, because Svelte is able to remove blocks that no longer exists and
leave other Components untouched.
// }} ===

**â¬†xref:_table_of_contents[back to top]**
// }}}

// {{{ 7 == Asynchronous Await Blocks
[[_asynchronous_await_blocks]]
== Asynchronous Await Blocks

Very often when you building web applications, you will need to deal with
asynchronous values.

That is to say, you're `"fetching()"` some data over the network, and it's
represented as a "Promise" and that often quite difficult inside the templates.

So Svelte introduces something called the `"Await"` - block, which is a way of
handling Promises natively right inside you template markup.

// {{{ === Logic / Await Blocks
[[_logic_await_blocks]]
=== Logic / Await Blocks

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let promise = getRandomNumber();

    async function getRandomNumber() {
        const res = await fetch(`tutorial/random-number`);
        const text = await res.text();

        if (res.ok) {
            return text;
        } else {
            throw new Error(text);
        }
    }


    function handleClick() {
        promise = getRandomNumber();
    }
</script>

<button on:click={handleClick}>
    generate random number
</button>

<!-- replace this element -->
<p>{promise}</p>
----
// }}}

So, here we have a Promise. Which is getting a random number from this API
- Endpoint `fetch('tutorial/random-number')`

If the response was okay, it returns the value of the API - Response. Gets the
number, and then it resolves the `"fetch()"`.

If it didn't work, for whatever reason, which sometimes it doesn't. Because
this Endpoints is programmed in such a way that it will occasionally fail. Just
to demonstrate the point that we're making. It will throw an error instead.

So we can have a Promise that can resolve all reject.

Whenever we click this button,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    ...
    ...
    function handleclick() {
        promise = getRandomNumber();
    }
</script>
----
// }}}

It always get a new random number.

So right now, we're just putting the Promise right there on the template, and
it's showing up as an `"[Object Promise]"` - String, which is not very helpful.

I'm going to replace that with the `"await{}"` - block.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...
{#await promise}
    <p>...waiting</p>
{/await}
----
// }}}

So far we've got the waiting section.

So this is when the "Promise" is still *pending*, this is what is visible,

When we've got the value that we want, we pass it to the `"{:then}"` - Clause
of your `"await{}"` - block.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...
{#await promise}
    <p>...waiting</p>
{:then number}                       // <<<
    <p>The Number is {number}</p>   //  <<<
{/await}
----
// }}}

You will see what happen there, it went away to get the data, took a little
while to come back, but when it did *resolve*, it prints the number to the
    screen.

If we try to click the button again. It's going to wait a little bit and then
it's going to print the number to the screen.

Sometimes it will go *wrong*. So we need to have a `"{:catch}"` - Clause as
well.

// {{{ App.svelte
[source, html]
----
// App.svelte
...
...
{#await promise}
    <p>...waiting</p>
{:then number}
    <p>The Number is {number}</p>
{:catch error}                                      // <<<
    <p style="color: red">{error.message}</p>       // <<<
{/await}
----
// }}}

With inside the `"{:catch}"` - Clause, we have access to an `"error"`.

If that happens. We'll print the "error - message" to the screen.

Now, I don't have time to keep clicking this button until an error appears. So
what I'm going to do is, I'm going to open the "dev-tools" going to "networks"
- tabs and turn everything offline.

So now in theory, when I click "generate random number" - button, is going to
give us an error `"failed to fetch"`.

So this is a really easy way of structuring code that needs to deal with
*"asynchronous - values"*.
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
//}}}

// {{{ 8 == Events
[[_events]]
== Events

So as we saw earlier in the course, we can add Events to Elements with thing we
call the "On - Directive". That basically equivalent to doing
`"element.addEventListener()"` in vanilla JavaScript.

// {{{ === Events / DOM - Events
[[_events_dom_events]]
=== Events / DOM - Events

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let m = { x: 0, y: 0 };

    function handleMousemove(event) {
        m.x = event.clientX;
        m.y = event.clientY;
    }
</script>

<style>
    div { width: 100%; height: 100%; }
</style>

<div>
    The mouse position is {m.x} x {m.y}
</div>
----
// }}}

So in this application here, we have a "mouseMove" - Handler. Which is going to
change this value `"let m = [x: 0, y: 0]"` to the current position of the
mouse.

Then we just display in that inside the markup here `"<div>"`.

Now, if we now add "mouseMove" - Handler to the `<div
on:mouseMove={handleMousemove}">`. We pass in the reference
(`"handleMousemove"`) to the function.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let m = { x: 0, y: 0 };

    function handleMousemove(event) {
        m.x = event.clientX;
        m.y = event.clientY;
    }
</script>

<style>
    div { width: 100%; height: 100%; }
</style>

<div on:mouseMove={handleMousemove}>
//   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    The mouse position is {m.x} x {m.y}
</div>
----
// }}}

Then now as you move the mouse around the text on the screen, will change.

You'll notice that this "function - reference" (`"handleMousemove"`) is being
called with the `"(event)"` - Object that you would get if you using
`"EventListener"`. It is exactly the same.
// }}} ===

// {{{ === Events / Inline Handlers
[[_events_inline_handlers]]
=== Events / Inline Handlers

We can also declare events handlers inline. We don't need to pass "function
- reference". We can do it like this instead,

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    let m = { x: 0, y: 0 };
</script>

<style>
    div { width: 100%; height: 100%; }
</style>

<div on:mousemove="{e => m = { x: e.clientX, y: e.clientY }}">
//   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    The mouse position is {m.x} x {m.y}
</div>
----
// }}}

It still works.

Now, we can get rid of that handler (`"handleMousemove"`) because we no longer
need it.

This technique can be very convenient at times, but it's also something that
you can use to make your templates look like absolute Gibberish.

So generally, once your "Events - Handler" get more complicate than above. You
want to hoist them into the `"<script>"` - block and give them a "name".

I should point out something head. If you're using an editor where this syntax
- highlighting causes problems, because it's not typical HTML, you can wrap the
whole thing in quote - marks (`" "`). Just so that you don't have those syntax
highlighting problems.

As far as Svelte concerned. Those two thing are identical. It's not going to
treat this (`"e => m = { x: e.clientX, y: e.clientY }"`) as a String.
// }}} ===

// {{{ === Events / Events Modifier
[[_events_events_modifier]]
=== Events / Events Modifier
:fn-capture_modifier: link:https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture

So we can also add *modifiers* to our "Event - Handlers".

What "modifiers" do is, they change the behavior of the "Event - Handler"
in some way.

For example, we can add a once "modifier" to this `"on:click="` - handler.

Right now. If I do click `"click me"` - button, I'll get an "alert".

I do `"click me"` again I get another "alert".

Third time I get a third "alert".

But sometimes you want an event only happens *once*. So we use the "Pipe"
- syntax (`" | "`)

// {{{ App.svelte
[source, HTML]
----
//App.svelte

...
...
<button on:click|once={handleClick}>
//              ~~~~~
    Click me
</button>
----
// }}}

The "Pipe" the event through the ones "modifiers", and now if we try to click
more than once is nothing happen.

There's a few different "modifiers" that we have access to,

- `preventDefault` â€” Modifier. It calls `event.preventDefault()` before
  running the handler. Useful for form submission client-side, for example.

- `stopPropagation` â€” Modifier. It calls `event.stopPropagation()`, which means
  that the Event doesn't bubble to out of elements. In another word, preventing
  the event reaching the next element

- `passive` â€” Modifier. It improves scrolling performance on touch/wheel
  events (Svelte will add it automatically where it's safe to do so)

- `nonpassive` â€” Modifier. It explicitly set passive: false

- `capture` â€” Modifier. It fires the handler during the capture phase instead
  of the bubbling phase ({fn-capture_modifier}[MDN docs,window=_blank]).

Basically what that means is, Events work their way in, from the window when
they first happen. So if you click on an Element, the window receive the Events
during the capture phase.

Then any Parent Elements, get it all the way down to the Element there's
actually clicked, which is called the "Event - Target".

Then it goes to the "bubble - phase"; and it's way back out again.

NOTE: By default, Svelte - Event Handlers will be handled in the "bubble
- phase". But very occasionally you will need to handle them in the `capture"
- phase, and that "modifier allow you to do so.

- `once` â€” Modifier. It remove the handler after the first time it runs

- `self` â€” Modifier. It only trigger handler if event.target is the element
  itself rather than a child of that element

So that what DOM - Vent loo like.
// }}} ===

// {{{ === Events / Component Events
[[_events_component_events]]
=== Events / Component Events

WE also have Component - Events, which are way that Components can
*communicate* with each other.

So typically, our data will *flow* into Component as *"Props"*, but it can flow
back out of Component in cases where it needs to as Events.

// {{{ App.svelte
[source, html]
----
<script>
    import Inner from './Inner.svelte';

    function handleMessage(event) {
        alert(event.detail.text);
    }
</script>

<Inner on:message={handleMessage}/>
----
// }}}

In our `"App.svelte"` we have an `"Inner"` - Component, and we have
`"on:mesage={}"` - Event Handler that's going to alert the details of that
message.

// {{{ Inner.svlete
[source, html]
----
// Inner.svelte
<script>
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();

    function sayHello() {
        dispatch('message', {
            text: 'Hello!'
        });
    }
</script>

<button on:click={sayHello}>
    Click to say hello
</button>
----
// }}}

In our `"Inside.svlete"` - Component, we need to set that up, so that this
Event gets dispatched.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();

    function sayHello() {
        dispatch('message', {
            text: 'Hello!'
        });
    }
</script>
----
// }}}

The way we do it is by imposing a function called `"createEventDispatcher()"`
from `"svelte"` it self.

Once we've done that, we create a `"dispatch()"` - function.

Then inside the `"sayHello"` - function here. We're going to call `"dispatch()'`
with the name of the Event, which in this case is `dispatch('message', {})`,
and optional "payload" of Data.

Now, when we click on this button, the "Inner" - Component creates the Event
- Broadcast it, and then the "Outer" - Component, which in this case
`"App.svelte"` is able to handle it.

If we log the Event in "Outer" - Component,

//{{{ image::./images/chapter-2-16.png
[#img-chapter]
[link=./images/chapter-2-16.png,window=_blank]
.Svelte Basic -18
image::./images/chapter-2-16.png[align="center"]
//}}}

You'll see that what we're using is the "native" - DOM Custom Event. Which
among other things has this detailed property which corresponds to the
"payload" that we passed to the `"dispatch()"` - function.

Now, a question that we get a lot is, why do we need to do this two lines
stanza, where we import `"createEventDispatcher"` and then we create
a `"dispatch()"` - function.

// {{{ Inner.svelte
[source, html]
----
// Inner.svelte
<script>
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();
</script>
----
// }}}

Wouldn't it be easier if, we just do `import { dispatch } from Svelte` and then
get rid of `"const dispatch"`?

So the way that it works is, when this `"<script>"` - block is being executed
by the Component is created. Svelte knows which Component is currently
instantiating.

So when we call a function, like `"createEventDispatcher()"`, we were able to
create a function that is *bound* to that specific Component.

Whereas, if we were just importing a function called `"dispatch()"` which
doesn't exist from Svelte.

Then When we called it, Svelte have NO way of knowing which Component was
*"dispatched"* in the Event; and so it wouldn't know which Handlers needed to
be triggered.

So, that's why we have the above two line - stanza `"createEventDispatcher"`
and then this `"const dispatch"` need to run at the top level of the
`"<script>"` - block.
// }}} ===

// {{{ === Events / Event Forwarding
[[_events_event_forwarding]]
=== Events / Event Forwarding

In the DOM, when an Event is triggered on an Element. It will "bubble - out"
from that Element to its Parents until it eventually reaches the window that
doesn't happen with Components.

If you want to listen to an Event on some "Nested" - Component, then the
"Intermediate" - Components need to *forward* that you're interested in.

So now we have similar case to before. We have an "Inner" - Component, that is
going to dispatch an Event, but it's wrapped in and "Outer" - Component; And
the "Outer" - Component is what's inside the main `"App.svelte"`.

So, what we need to do here is, forward the Event from in a via "Outer.svelte" up
all the way to `App.svelte".

// {{{ Outer.svelte
[source, html]
----
<script>
    import Inner from './Inner.svelte';
    import { createEventDispatcher } from 'svelte';

    const dispatch = createEventDispatcher();

    function forward(event) {
        dispatch('message', event.detail);
    }
</script>

<Inner on:message={forward}/>
----
// }}}

One way we could do that is, by going through the whole rigmarole creating the
event dispatcher inside the Outer" - Component.

Do the whole `"const dispatch = createEventDispatcher()"`.

Then we'll create a `"forward(event)"` - Handler.

Then just forward the Event - detail from the "Inner" - Component up to the
"App". `"<inner on:message={forward}>"`.

Now, when you click that button, the Event is forwarded.

But that's an awful lot of boilerpalte to do something fairly straightforward.

So, svelte gives us a slightly easier way to do this. If we just have
`"on:message"` just like that.

// {{{ Outer.svelte
[source, html]
----
<script>
    import Inner from './Inner.svelte';
</script>

<Inner on:message/>
//     ~~~~~~~~~~
----
// }}}

It will do, all that behind the scenes. It recognizes that.

That is you asking the "Outer" - Component to forward that message from the
"Inner" - Component to its parents (`"App.svelte"`).
// }}} ===

// {{{ === Events / DOM Event Elements
[[_events_dom_event_elements]]
=== Events / DOM Event Elements

We can do the same thing with DOM - Element.

So we have `"CustomButton"` - Component here with some fancy styling.

// {{{ CustomButton.svelte
[source, html]
----
// CustomButton.svelte
<button>
    Click me
</button>

<style>
    button {
        background: #E2E8F0;
        color: #64748B;
        border: unset;
        border-radius: 6px;
        padding: .75rem 1.5rem;
        cursor: pointer;
    }
    button:hover {
        background: #CBD5E1;
        color: #475569;
    }
    button:focus {
        background: #94A3B8;
        color: #F1F5F9;
    }
</style>
----
// }}}

We want to get `"click"` - Events handled inside the `"App.svelte"`.

// {{{ App.svelte
[source, html]
----
// App.svelte
<script>
    import CustomButton from './CustomButton.svelte';

    function handleClick() {
        alert('Button Clicked');
    }
</script>

<CustomButton on:click={handleClick}/>
//            ~~~~~~~~
----
// }}}

Right now, the button doesn't have an Event - Handler and again, we could wire
up some logic to forward the Event manually, but it's a lot easier if we just
do `"on:click"`.

// {{{ CustomButton.svelte
[source, html]
----
// CustomButton.svelte
<button on:click>
//      ~~~~~~~
    Click me
</button>
...
...
----
// }}}

So now, any click Events from the button will be forwarded through the
"CustomButton" - Component. Anything that includes the "CustomButton"
- Component like our "App.svelte".
// }}} ===

**â¬†xref:_table_of_contents[back to top]**
// }}}

// vim: set syntax=asciidoc set tw=79
